const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function yellow(str) {
    return run(str, code([
        33
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
function bgBlue(str) {
    return run(str, code([
        44
    ], 49));
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", 
].join("|"), "g");
async function exists(filePath) {
    try {
        await Deno.lstat(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 63];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 15) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
let cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
let heap_next = heap.length;
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
function getObject(idx) {
    return heap[idx];
}
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
let WASM_VECTOR_LEN = 0;
let cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function create_hash(algorithm) {
    var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ret = wasm.create_hash(ptr0, len0);
    return DenoHash.__wrap(ret);
}
function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
function update_hash(hash, data) {
    _assertClass(hash, DenoHash);
    var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.update_hash(hash.ptr, ptr0, len0);
}
let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest_hash(hash) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(hash, DenoHash);
        wasm.digest_hash(retptr, hash.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v0 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v0;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DenoHashFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_denohash_free(ptr)
);
class DenoHash {
    static __wrap(ptr) {
        const obj = Object.create(DenoHash.prototype);
        obj.ptr = ptr;
        DenoHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DenoHashFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_denohash_free(ptr);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbindgen_string_new: function(arg0, arg1) {
            var ret = getStringFromWasm0(arg0, arg1);
            return addHeapObject(ret);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        },
        __wbindgen_rethrow: function(arg0) {
            throw takeObject(arg0);
        }
    }
};
const wasmModule = new WebAssembly.Module(decode("AGFzbQEAAAAB64CAgAAQYAAAYAF/AGABfwF/YAF/AX5gAn9/AGACf38Bf2ADf39/AGADf39/AX9gBH\
9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AFf39/fn8AYAd/f39+f39/AX9gAn9+AGAC\
fn8BfwKMgYCAAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fc3RyaW5nX25ldw\
AFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxBfX3diaW5kZ2VuX3Rocm93AAQYX193YmluZGdlbl9w\
bGFjZWhvbGRlcl9fEl9fd2JpbmRnZW5fcmV0aHJvdwABA8aBgIAAxAEGBgQEBQYCDAYEBA0BBAQEAQ\
cFBA4EBAQHCgQEBAQLBAQEBAQEBAQEBAQEBAQEAQQEBAQEBAQHBQQEBAYGBgYEBAQEBA8BBAQEBAEE\
BgYGBgYEBAQEBAQEBgQEBgQEBAYEBAQEBAQEBAQGBAQEBAQEBAQEBgQEBAQEBAQECQUFAQEGBgYGBg\
QBAAUEBwcBBggBBgEBBwEBAQQBBwIBAQcBBQUCBQUGBAAFAQEBAQIAAAUEAQMCAgICAgICAgICAgIC\
AAQBBIWAgIAAAXABcXEFg4CAgAABABEGiYCAgAABfwFBgIDAAAsHroGAgAAJBm1lbW9yeQIAE19fd2\
JnX2Rlbm9oYXNoX2ZyZWUAkAELY3JlYXRlX2hhc2gABwt1cGRhdGVfaGFzaACRAQtkaWdlc3RfaGFz\
aACNARFfX3diaW5kZ2VuX21hbGxvYwCeARJfX3diaW5kZ2VuX3JlYWxsb2MAoQEfX193YmluZGdlbl\
9hZGRfdG9fc3RhY2tfcG9pbnRlcgCwAQ9fX3diaW5kZ2VuX2ZyZWUAqQEJnoGAgAABAEEBC3CnAcUB\
qwGmAbMBxgFbGGFNwQE4UVVpnwG9AXVQVGh0UjxXmgG/AWtTHzCTAcABTmI7VpkBal4vRJYBvAFzLT\
KVAbsBck8ZJYMBwgFdGiqCAcMBXD9GQqwBuAF6QTc0rgG3AX0+JyOtAbkBd0ArKa8BugF5RUN8NjN4\
JiR7LCh+ogELIjWKAb4BHo4BOowBpAGAAYEBtgGjAQrs84aAAMQBkVoCAX8ifiMAQYABayIDJAAgA0\
EAQYABEJ0BIQMgACkDOCEEIAApAzAhBSAAKQMoIQYgACkDICEHIAApAxghCCAAKQMQIQkgACkDCCEK\
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\
CnZzaiAeaiAiICVqIhsgAiAhc3EgIXNqIBtBGncgG0EVd3MgG0EHd3NqQfLxxbN8aiIeaiELIBwgCm\
ohCiAjIAlqIQkgICAIaiEIIB0gB2ogHmohByAbIAZqIQYgAiAFaiEFICEgBGohBCABQcAAaiIBIAxH\
DQALCyAAIAQ2AhwgACAFNgIYIAAgBjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACALNg\
IAC4ouASJ/IwBBwABrIgJBGGoiA0IANwMAIAJBIGoiBEIANwMAIAJBOGoiBUIANwMAIAJBMGoiBkIA\
NwMAIAJBKGoiB0IANwMAIAJBCGoiCCABKQAINwMAIAJBEGoiCSABKQAQNwMAIAMgASgAGCIKNgIAIA\
QgASgAICIDNgIAIAIgASkAADcDACACIAEoABwiBDYCHCACIAEoACQiCzYCJCAHIAEoACgiDDYCACAC\
IAEoACwiBzYCLCAGIAEoADAiDTYCACACIAEoADQiBjYCNCAFIAEoADgiDjYCACACIAEoADwiATYCPC\
AAIA4gAyABIAsgAigCACIFIAkoAgAiCSAFIAcgAigCDCIPIAIoAgQiECABIAUgASAMIAIoAhQiAiAF\
IAAoAggiESAAKAIEIhJzIAAoAgwiE3MgACgCACIUampBC3cgACgCECIVaiIWQQp3IhdqIA8gEUEKdy\
IRaiAQIBVqIBEgEnMgFnNqQQ53IBNqIhUgF3MgCCgCACIIIBNqIBYgEkEKdyIScyAVc2pBD3cgEWoi\
E3NqQQx3IBJqIhYgE0EKdyIRcyAJIBJqIBMgFUEKdyIScyAWc2pBBXcgF2oiE3NqQQh3IBJqIhdBCn\
ciFWogAyAWQQp3IhZqIAogEmogEyAWcyAXc2pBB3cgEWoiEiAVcyAEIBFqIBcgE0EKdyITcyASc2pB\
CXcgFmoiFnNqQQt3IBNqIhcgFkEKdyIRcyALIBNqIBYgEkEKdyIScyAXc2pBDXcgFWoiE3NqQQ53IB\
JqIhZBCnciFWogBiAXQQp3IhdqIBIgB2ogEyAXcyAWc2pBD3cgEWoiEiAVcyARIA1qIBYgE0EKdyIT\
cyASc2pBBncgF2oiFnNqQQd3IBNqIhEgFkEKdyIYcyATIA5qIBYgEkEKdyIZcyARc2pBCXcgFWoiFX\
NqQQh3IBlqIhdBCnciEmogDyAMIAYgBSAAKAIcIhpBCnciE2ogBCAAKAIgIhZqIA4gACgCJCIbaiAC\
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\
akHEABCXARogAkHYAGoiAyACQcgCakE8aikCADcDACACQdAAaiIEIAJByAJqQTRqKQIANwMAIAJByA\
BqIgUgAkHIAmpBLGopAgA3AwAgAkHAAGoiBiACQcgCakEkaikCADcDACACQThqIgcgAkHIAmpBHGop\
AgA3AwAgAkEwaiIIIAJByAJqQRRqKQIANwMAIAJBIGpBCGoiCSACQcgCakEMaikCADcDACACIAIpAs\
wCNwMgQeAAEAkiAUUNDCABQQA2AgggAUIANwMAIAEgAikDIDcCDCABQRRqIAkpAwA3AgAgAUEcaiAI\
KQMANwIAIAFBJGogBykDADcCACABQSxqIAYpAwA3AgAgAUE0aiAFKQMANwIAIAFBPGogBCkDADcCAC\
ABQcQAaiADKQMANwIAIAFB1ABqQQApAoibQDcCACABQQApAoCbQDcCTEHUgMAAIQMMHwsgAkGwAWpB\
DGoiAUIANwIAIAJCADcCtAEgAkEQNgKwASACQcgCakEQaiIEIAJBsAFqQRBqIgUoAgA2AgAgAkHIAm\
pBCGoiAyACQbABakEIaiIGKQMANwMAIAJBIGpBCGoiByACQcgCakEMaiIIKQIANwMAIAIgAikDsAE3\
A8gCIAIgAikCzAI3AyAgAUIANwIAIAJCADcCtAEgAkEQNgKwASAEIAUoAgA2AgAgAyAGKQMANwMAIA\
IgAikDsAE3A8gCIAJBEGpBCGoiBCAIKQIANwMAIAIgAikCzAI3AxAgAyAHKQMANwMAIAIgAikDIDcD\
yAJB1AAQCSIBRQ0JIAFBADYCACABIAIpA8gCNwIEIAFCADcCFCABIAIpAxA3AkQgAUEcakIANwIAIA\
FBJGpCADcCACABQSxqQgA3AgAgAUE0akIANwIAIAFBPGpCADcCACABQQxqIAMpAwA3AgAgAUHMAGog\
BCkDADcCAEGEgMAAIQMMHgsgAkGwAWpBDGpCADcCACACQbABakEUakIANwIAIAJBsAFqQRxqQgA3Ag\
AgAkGwAWpBJGpCADcCACACQbABakEsakIANwIAIAJBsAFqQTRqQgA3AgAgAkGwAWpBPGpCADcCACAC\
QgA3ArQBIAJBwAA2ArABIAJByAJqIAJBsAFqQcQAEJcBGiACQdgAaiIDIAJByAJqQTxqKQIANwMAIA\
JB0ABqIgQgAkHIAmpBNGopAgA3AwAgAkHIAGoiBSACQcgCakEsaikCADcDACACQcAAaiIGIAJByAJq\
QSRqKQIANwMAIAJBOGoiByACQcgCakEcaikCADcDACACQTBqIgggAkHIAmpBFGopAgA3AwAgAkEgak\
EIaiIJIAJByAJqQQxqKQIANwMAIAIgAikCzAI3AyBB4AAQCSIBRQ0JIAFBADYCCCABQgA3AwAgASAC\
KQMgNwIMIAFBFGogCSkDADcCACABQRxqIAgpAwA3AgAgAUEkaiAHKQMANwIAIAFBLGogBikDADcCAC\
ABQTRqIAUpAwA3AgAgAUE8aiAEKQMANwIAIAFBxABqIAMpAwA3AgAgAUHUAGpBACkCiJtANwIAIAFB\
ACkCgJtANwJMQayAwAAhAwwdCwJAAkAgAEH4gMAAQQkQjwFFDQAgAEGogcAAQQkQjwFFDQEgAEG8hM\
AAIAEQjwFFDQQgAEHshMAAIAEQjwFFDQUgAEGchcAAIAEQjwFFDQYgAEHMhcAAIAEQjwENCCACQQA2\
ArABIAJBsAFqQQRyQQBByAAQnQEaIAJByAA2ArABIAJByAJqIAJBsAFqQcwAEJcBGiACQSBqIAJByA\
JqQQRyQcgAEJcBGkGYAhAJIgFFDRkgAUEAQcwBEJ0BQcwBaiACQSBqQcgAEJcBGkHYhcAAIQMMHgsg\
AkGwAWpBDGpCADcCACACQbABakEUakIANwIAIAJBsAFqQRxqQgA3AgAgAkGwAWpBJGpCADcCACACQb\
ABakEsakIANwIAIAJBsAFqQTRqQgA3AgAgAkGwAWpBPGpCADcCACACQgA3ArQBIAJBwAA2ArABIAJB\
yAJqIAJBsAFqQcQAEJcBGiACQSBqQThqIgMgAkHIAmpBPGopAgA3AwAgAkEgakEwaiIEIAJByAJqQT\
RqKQIANwMAIAJBIGpBKGoiBSACQcgCakEsaikCADcDACACQcAAaiIGIAJByAJqQSRqKQIANwMAIAJB\
IGpBGGoiByACQcgCakEcaikCADcDACACQSBqQRBqIgggAkHIAmpBFGopAgA3AwAgAkEgakEIaiIJIA\
JByAJqQQxqKQIANwMAIAIgAikCzAI3AyBB4AAQCSIBRQ0LIAFCADcDACABQQA2AhwgASACKQMgNwIg\
IAFBACkDuJtANwMIIAFBEGpBACkDwJtANwMAIAFBGGpBACgCyJtANgIAIAFBKGogCSkDADcCACABQT\
BqIAgpAwA3AgAgAUE4aiAHKQMANwIAIAFBwABqIAYpAwA3AgAgAUHIAGogBSkDADcCACABQdAAaiAE\
KQMANwIAIAFB2ABqIAMpAwA3AgBBhIHAACEDDB0LIAJBsAFqQQxqQgA3AgAgAkGwAWpBFGpCADcCAC\
ACQbABakEcakIANwIAIAJBsAFqQSRqQgA3AgAgAkGwAWpBLGpCADcCACACQbABakE0akIANwIAIAJB\
sAFqQTxqQgA3AgAgAkIANwK0ASACQcAANgKwASACQcgCaiACQbABakHEABCXARogAkHYAGoiAyACQc\
gCakE8aikCADcDACACQdAAaiIEIAJByAJqQTRqKQIANwMAIAJBIGpBKGoiBSACQcgCakEsaikCADcD\
ACACQSBqQSBqIgYgAkHIAmpBJGopAgA3AwAgAkEgakEYaiIHIAJByAJqQRxqKQIANwMAIAJBIGpBEG\
oiCCACQcgCakEUaikCADcDACACQSBqQQhqIgkgAkHIAmpBDGopAgA3AwAgAiACKQLMAjcDIEH4ABAJ\
IgFFDQsgAUIANwMAIAFBADYCMCABIAIpAyA3AjQgAUEAKQOQm0A3AwggAUEQakEAKQOYm0A3AwAgAU\
EYakEAKQOgm0A3AwAgAUEgakEAKQOom0A3AwAgAUEoakEAKQOwm0A3AwAgAUE8aiAJKQMANwIAIAFB\
xABqIAgpAwA3AgAgAUHMAGogBykDADcCACABQdQAaiAGKQMANwIAIAFB3ABqIAUpAwA3AgAgAUHkAG\
ogBCkDADcCACABQewAaiADKQMANwIAQbSBwAAhAwwcCwJAAkACQAJAIABB/IHAAEEGEI8BRQ0AIABB\
qILAAEEGEI8BRQ0BIABB1ILAAEEGEI8BRQ0CIABBgIPAAEEGEI8BRQ0DIABB/IXAAEEGEI8BDQkgAk\
HlAmoiA0EAKQOInEAiCjcAACACQd0CakEAKQOAnEAiCzcAACACQdUCakEAKQP4m0AiDDcAACACQQAp\
A/CbQCINNwDNAkH4DhAJIgFFDRsgAUIANwMAIAEgDTcDCCABQRBqIAw3AwAgAUEYaiALNwMAIAFBIG\
ogCjcDACABQShqQQBBwwAQnQEaIAFBADoA8A4gAUGIAWogAykAADcAACABQYMBaiACQcgCakEYaikA\
ADcAACABQfsAaiACQcgCakEQaikAADcAACABQfMAaiACQdACaikAADcAACABIAIpAMgCNwBrQYSGwA\
AhAwwfCyACQbABakEMakIANwIAIAJBsAFqQRRqQgA3AgAgAkGwAWpBHGpCADcCACACQbABakEkakIA\
NwIAIAJBsAFqQSxqQgA3AgAgAkGwAWpBNGpCADcCACACQbABakE8akIANwIAIAJCADcCtAEgAkHAAD\
YCsAEgAkHIAmogAkGwAWpBxAAQlwEaIAJB2ABqIgMgAkHIAmpBPGopAgA3AwAgAkHQAGoiBCACQcgC\
akE0aikCADcDACACQcgAaiIFIAJByAJqQSxqKQIANwMAIAJBwABqIgYgAkHIAmpBJGopAgA3AwAgAk\
E4aiIHIAJByAJqQRxqKQIANwMAIAJBMGoiCCACQcgCakEUaikCADcDACACQSBqQQhqIgkgAkHIAmpB\
DGopAgA3AwAgAiACKQLMAjcDIEHwABAJIgFFDQ4gASACKQMgNwIMIAFBADYCCCABQgA3AwAgAUEcai\
AIKQMANwIAIAFBFGogCSkDADcCACABQSRqIAcpAwA3AgAgAUEsaiAGKQMANwIAIAFBNGogBSkDADcC\
ACABQTxqIAQpAwA3AgAgAUHEAGogAykDADcCACABQdQAakEAKQLUm0A3AgAgAUEAKQLMm0A3AkwgAU\
HkAGpBACkC5JtANwIAIAFB3ABqQQApAtybQDcCAEGEgsAAIQMMHgsgAkGwAWpBDGpCADcCACACQbAB\
akEUakIANwIAIAJBsAFqQRxqQgA3AgAgAkGwAWpBJGpCADcCACACQbABakEsakIANwIAIAJBsAFqQT\
RqQgA3AgAgAkGwAWpBPGpCADcCACACQgA3ArQBIAJBwAA2ArABIAJByAJqIAJBsAFqQcQAEJcBGiAC\
QdgAaiIDIAJByAJqQTxqKQIANwMAIAJB0ABqIgQgAkHIAmpBNGopAgA3AwAgAkHIAGoiBSACQcgCak\
EsaikCADcDACACQcAAaiIGIAJByAJqQSRqKQIANwMAIAJBOGoiByACQcgCakEcaikCADcDACACQTBq\
IgggAkHIAmpBFGopAgA3AwAgAkEgakEIaiIJIAJByAJqQQxqKQIANwMAIAIgAikCzAI3AyBB8AAQCS\
IBRQ0OIAEgAikDIDcCDCABQQA2AgggAUIANwMAIAFBHGogCCkDADcCACABQRRqIAkpAwA3AgAgAUEk\
aiAHKQMANwIAIAFBLGogBikDADcCACABQTRqIAUpAwA3AgAgAUE8aiAEKQMANwIAIAFBxABqIAMpAw\
A3AgAgAUHUAGpBACkD+JtANwIAIAFBACkD8JtANwJMIAFB5ABqQQApA4icQDcCACABQdwAakEAKQOA\
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\
AkEIQQAoArynQCICQQIgAhsRBAAAC0G4AkEIQQAoArynQCICQQIgAhsRBAAAC0GYAkEIQQAoArynQC\
ICQQIgAhsRBAAAC0HgAkEIQQAoArynQCICQQIgAhsRBAAAC0HYAkEIQQAoArynQCICQQIgAhsRBAAA\
C0G4AkEIQQAoArynQCICQQIgAhsRBAAAC0GYAkEIQQAoArynQCICQQIgAhsRBAAAC0H4DkEIQQAoAr\
ynQCICQQIgAhsRBAAAC0E4QQFBACgCvKdAIgJBAiACGxEEAAALQaSHwABBMyACQcgCakHYh8AAQeiH\
wAAQfwALIAJBsAFqQQxqQgA3AgAgAkGwAWpBFGpCADcCACACQbABakEcakIANwIAIAJBsAFqQSRqQg\
A3AgAgAkGwAWpBLGpCADcCACACQbABakE0akIANwIAIAJBsAFqQTxqQgA3AgAgAkIANwK0ASACQcAA\
NgKwASACQcgCaiACQbABakHEABCXARogAkEgakE4aiIDIAJByAJqQTxqKQIANwMAIAJBIGpBMGoiBC\
ACQcgCakE0aikCADcDACACQSBqQShqIgUgAkHIAmpBLGopAgA3AwAgAkHAAGoiBiACQcgCakEkaikC\
ADcDACACQSBqQRhqIgcgAkHIAmpBHGopAgA3AwAgAkEgakEQaiIIIAJByAJqQRRqKQIANwMAIAJBIG\
pBCGoiCSACQcgCakEMaikCADcDACACIAIpAswCNwMgQeAAEAkiAUUNASABQgA3AwAgAUEANgIcIAEg\
AikDIDcCICABQQApA7ibQDcDCCABQRBqQQApA8CbQDcDACABQRhqQQAoAsibQDYCACABQShqIAkpAw\
A3AgAgAUEwaiAIKQMANwIAIAFBOGogBykDADcCACABQcAAaiAGKQMANwIAIAFByABqIAUpAwA3AgAg\
AUHQAGogBCkDADcCACABQdgAaiADKQMANwIAQdiBwAAhAwsgABAPAkBBDBAJIgANAEEMQQRBACgCvK\
dAIgJBAiACGxEEAAALIAAgAzYCCCAAIAE2AgQgAEEANgIAIAJB4ANqJAAgAA8LQeAAQQhBACgCvKdA\
IgJBAiACGxEEAAALuSQBU38jAEHAAGsiA0E4akIANwMAIANBMGpCADcDACADQShqQgA3AwAgA0Egak\
IANwMAIANBGGpCADcDACADQRBqQgA3AwAgA0EIakIANwMAIANCADcDACAAKAIQIQQgACgCDCEFIAAo\
AgghBiAAKAIEIQcgACgCACEIAkAgAkEGdCICRQ0AIAEgAmohCQNAIAMgASgAACICQRh0IAJBCHRBgI\
D8B3FyIAJBCHZBgP4DcSACQRh2cnI2AgAgAyABQQRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA\
/gNxIAJBGHZycjYCBCADIAFBCGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyNg\
IIIAMgAUEMaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnI2AgwgAyABQRBqKAAA\
IgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZycjYCECADIAFBFGooAAAiAkEYdCACQQh0QY\
CA/AdxciACQQh2QYD+A3EgAkEYdnJyNgIUIAMgAUEcaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZB\
gP4DcSACQRh2cnIiCjYCHCADIAFBIGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdn\
JyIgs2AiAgAyABQRhqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIMNgIYIAMo\
AgAhDSADKAIEIQ4gAygCCCEPIAMoAhAhECADKAIMIREgAygCFCESIAMgAUEkaigAACICQRh0IAJBCH\
RBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiEzYCJCADIAFBKGooAAAiAkEYdCACQQh0QYCA/AdxciAC\
QQh2QYD+A3EgAkEYdnJyIhQ2AiggAyABQTBqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIA\
JBGHZyciIVNgIwIAMgAUEsaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFjYC\
LCADIAFBNGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgI2AjQgAyABQThqKA\
AAIhdBGHQgF0EIdEGAgPwHcXIgF0EIdkGA/gNxIBdBGHZyciIXNgI4IAMgAUE8aigAACIYQRh0IBhB\
CHRBgID8B3FyIBhBCHZBgP4DcSAYQRh2cnIiGDYCPCAIIBMgCnMgGHMgDCAQcyAVcyARIA5zIBNzIB\
dzQQF3IhlzQQF3IhpzQQF3IhsgCiAScyACcyAQIA9zIBRzIBhzQQF3IhxzQQF3Ih1zIBggAnMgHXMg\
FSAUcyAccyAbc0EBdyIec0EBdyIfcyAaIBxzIB5zIBkgGHMgG3MgFyAVcyAacyAWIBNzIBlzIAsgDH\
MgF3MgEiARcyAWcyAPIA1zIAtzIAJzQQF3IiBzQQF3IiFzQQF3IiJzQQF3IiNzQQF3IiRzQQF3IiVz\
QQF3IiZzQQF3IicgHSAhcyACIBZzICFzIBQgC3MgIHMgHXNBAXciKHNBAXciKXMgHCAgcyAocyAfc0\
EBdyIqc0EBdyIrcyAfIClzICtzIB4gKHMgKnMgJ3NBAXciLHNBAXciLXMgJiAqcyAscyAlIB9zICdz\
ICQgHnMgJnMgIyAbcyAlcyAiIBpzICRzICEgGXMgI3MgICAXcyAicyApc0EBdyIuc0EBdyIvc0EBdy\
Iwc0EBdyIxc0EBdyIyc0EBdyIzc0EBdyI0c0EBdyI1ICsgL3MgKSAjcyAvcyAoICJzIC5zICtzQQF3\
IjZzQQF3IjdzICogLnMgNnMgLXNBAXciOHNBAXciOXMgLSA3cyA5cyAsIDZzIDhzIDVzQQF3IjpzQQ\
F3IjtzIDQgOHMgOnMgMyAtcyA1cyAyICxzIDRzIDEgJ3MgM3MgMCAmcyAycyAvICVzIDFzIC4gJHMg\
MHMgN3NBAXciPHNBAXciPXNBAXciPnNBAXciP3NBAXciQHNBAXciQXNBAXciQnNBAXciQyA5ID1zID\
cgMXMgPXMgNiAwcyA8cyA5c0EBdyJEc0EBdyJFcyA4IDxzIERzIDtzQQF3IkZzQQF3IkdzIDsgRXMg\
R3MgOiBEcyBGcyBDc0EBdyJIc0EBdyJJcyBCIEZzIEhzIEEgO3MgQ3MgQCA6cyBCcyA/IDVzIEFzID\
4gNHMgQHMgPSAzcyA/cyA8IDJzID5zIEVzQQF3IkpzQQF3IktzQQF3IkxzQQF3Ik1zQQF3Ik5zQQF3\
Ik9zQQF3IlBzQQF3aiBGIEpzIEQgPnMgSnMgR3NBAXciUXMgSXNBAXciUiBFID9zIEtzIFFzQQF3Il\
MgTCBBIDogOSA8IDEgJiAfICggISAXIBMgECAIQR53IlRqIA4gBSAHQR53IhAgBnMgCHEgBnNqaiAN\
IAQgCEEFd2ogBiAFcyAHcSAFc2pqQZnzidQFaiIOQQV3akGZ84nUBWoiVUEedyIIIA5BHnciDXMgBi\
APaiAOIFQgEHNxIBBzaiBVQQV3akGZ84nUBWoiDnEgDXNqIBAgEWogVSANIFRzcSBUc2ogDkEFd2pB\
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\
IAcoAggiACABNgIMIAEgADYCCAwDCyABIAdBEGogBhshBgNAIAYhCAJAIAAiAUEUaiIGKAIAIgANAC\
ABQRBqIQYgASgCECEACyAADQALIAhBADYCAAwCCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQQAo\
AvymQCIAIAJPDQBBACgCgKdAIgAgAksNBEEAIQEgAkGvgARqIgVBEHZAACIAQX9GIgcNDSAAQRB0Ig\
ZFDQ1BAEEAKAKMp0BBACAFQYCAfHEgBxsiCGoiADYCjKdAQQBBACgCkKdAIgEgACABIABLGzYCkKdA\
QQAoAoinQCIBRQ0BQZSnwAAhAANAIAAoAgAiBSAAKAIEIgdqIAZGDQMgACgCCCIADQAMBAsLQQAoAo\
SnQCEBAkACQCAAIAJrIgVBD0sNAEEAQQA2AoSnQEEAQQA2AvymQCABIABBA3I2AgQgASAAaiIAIAAo\
AgRBAXI2AgQMAQtBACAFNgL8pkBBACABIAJqIgY2AoSnQCAGIAVBAXI2AgQgASAAaiAFNgIAIAEgAk\
EDcjYCBAsgAUEIag8LAkACQEEAKAKop0AiAEUNACAAIAZNDQELQQAgBjYCqKdAC0EAQf8fNgKsp0BB\
ACAINgKYp0BBACAGNgKUp0BBAEH0o8AANgKApEBBAEH8o8AANgKIpEBBAEH0o8AANgL8o0BBAEGEpM\
AANgKQpEBBAEH8o8AANgKEpEBBAEGMpMAANgKYpEBBAEGEpMAANgKMpEBBAEGUpMAANgKgpEBBAEGM\
pMAANgKUpEBBAEGcpMAANgKopEBBAEGUpMAANgKcpEBBAEGkpMAANgKwpEBBAEGcpMAANgKkpEBBAE\
GspMAANgK4pEBBAEGkpMAANgKspEBBAEEANgKgp0BBAEG0pMAANgLApEBBAEGspMAANgK0pEBBAEG0\
pMAANgK8pEBBAEG8pMAANgLIpEBBAEG8pMAANgLEpEBBAEHEpMAANgLQpEBBAEHEpMAANgLMpEBBAE\
HMpMAANgLYpEBBAEHMpMAANgLUpEBBAEHUpMAANgLgpEBBAEHUpMAANgLcpEBBAEHcpMAANgLopEBB\
AEHcpMAANgLkpEBBAEHkpMAANgLwpEBBAEHkpMAANgLspEBBAEHspMAANgL4pEBBAEHspMAANgL0pE\
BBAEH0pMAANgKApUBBAEH8pMAANgKIpUBBAEH0pMAANgL8pEBBAEGEpcAANgKQpUBBAEH8pMAANgKE\
pUBBAEGMpcAANgKYpUBBAEGEpcAANgKMpUBBAEGUpcAANgKgpUBBAEGMpcAANgKUpUBBAEGcpcAANg\
KopUBBAEGUpcAANgKcpUBBAEGkpcAANgKwpUBBAEGcpcAANgKkpUBBAEGspcAANgK4pUBBAEGkpcAA\
NgKspUBBAEG0pcAANgLApUBBAEGspcAANgK0pUBBAEG8pcAANgLIpUBBAEG0pcAANgK8pUBBAEHEpc\
AANgLQpUBBAEG8pcAANgLEpUBBAEHMpcAANgLYpUBBAEHEpcAANgLMpUBBAEHUpcAANgLgpUBBAEHM\
pcAANgLUpUBBAEHcpcAANgLopUBBAEHUpcAANgLcpUBBAEHkpcAANgLwpUBBAEHcpcAANgLkpUBBAE\
HspcAANgL4pUBBAEHkpcAANgLspUBBACAGNgKIp0BBAEHspcAANgL0pUBBACAIQVhqIgA2AoCnQCAG\
IABBAXI2AgQgBiAAakEoNgIEQQBBgICAATYCpKdADAoLIAAoAgwNACAFIAFLDQAgBiABSw0CC0EAQQ\
AoAqinQCIAIAYgACAGSRs2AqinQCAGIAhqIQVBlKfAACEAAkACQAJAA0AgACgCACAFRg0BIAAoAggi\
AA0ADAILCyAAKAIMRQ0BC0GUp8AAIQACQANAAkAgACgCACIFIAFLDQAgBSAAKAIEaiIFIAFLDQILIA\
AoAggiAA0ACwALQQAgBjYCiKdAQQAgCEFYaiIANgKAp0AgBiAAQQFyNgIEIAYgAGpBKDYCBEEAQYCA\
gAE2AqSnQCABIAVBYGpBeHFBeGoiACAAIAFBEGpJGyIHQRs2AgRBACkClKdAIQogB0EQakEAKQKcp0\
A3AgAgByAKNwIIQQAgCDYCmKdAQQAgBjYClKdAQQAgB0EIajYCnKdAQQBBADYCoKdAIAdBHGohAANA\
IABBBzYCACAFIABBBGoiAEsNAAsgByABRg0JIAcgBygCBEF+cTYCBCABIAcgAWsiBkEBcjYCBCAHIA\
Y2AgACQCAGQYACSQ0AQR8hAAJAIAZB////B0sNACAGQQYgBkEIdmciAGtBH3F2QQFxIABBAXRrQT5q\
IQALIAFCADcCECABQRxqIAA2AgAgAEECdEH8pcAAaiEFAkACQAJAAkACQEEAKALwo0AiB0EBIABBH3\
F0IghxRQ0AIAUoAgAiBygCBEF4cSAGRw0BIAchAAwCC0EAIAcgCHI2AvCjQCAFIAE2AgAgAUEYaiAF\
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\
ACADQfgAakE4aiAAQThqKQMANwMAIANB+ABqQcAAaiAAQcAAaikDADcDACADQfgAakHIAGogAEHIAG\
opAwA3AwAgA0H4AGpB0ABqIABB0ABqKQMANwMAIANB+ABqQdgAaiAAQdgAaikDADcDACADQfgAakHg\
AGogAEHgAGopAwA3AwAgAyAAKQMINwOAASADIAApAyg3A6ABIABB6QBqLQAAIQggAC0AaiEJIAMgAC\
0AaCIKOgDgASADIAApAwAiHjcDeCADIAkgCEVyQQJyIgg6AOEBIANB6AFqQRhqIgkgBykCADcDACAD\
QegBakEQaiIHIAYpAgA3AwAgA0HoAWpBCGoiBiAEKQIANwMAIAMgACkCCDcD6AEgA0HoAWogA0H4AG\
pBKGogCiAeIAgQCiAJKAIAIQggBygCACEHIAYoAgAhCSADKAKEAiEKIAMoAvwBIQsgAygC9AEhDCAD\
KALsASENIAMoAugBIQ4gACAAKQMAEBcgAEHwDmoiDy0AACIGQTdPDQIgACAGQQV0aiIEQZABaiAONg\
IAIARBrAFqIAo2AgAgBEGoAWogCDYCACAEQaQBaiALNgIAIARBoAFqIAc2AgAgBEGcAWogDDYCACAE\
QZgBaiAJNgIAIARBlAFqIA02AgAgDyAGQQFqOgAAIABBKGoiBEIANwMAIARBCGpCADcDACAEQRBqQg\
A3AwAgBEEYakIANwMAIARBIGpCADcDACAEQShqQgA3AwAgBEEwakIANwMAIARBOGpCADcDACAAQQA7\
AWggAEEIaiIEIAApA3A3AwAgBEEIaiAAQfgAaikDADcDACAEQRBqIABBgAFqKQMANwMAIARBGGogAE\
GIAWopAwA3AwAgACAAKQMAQgF8NwMAIAEgBWohAQsCQCACQYEISQ0AIABBkAFqIQ4gAEHwAGohByAA\
KQMAIR8gA0EIakEoaiEKIANBCGpBCGohDSADQfgAakEoaiEJIANB+ABqQQhqIQsgAEHwDmohDANAIB\
9CCoYhHkF/IAJBAXZndkEBaiEFA0AgBSIEQQF2IQUgHiAEQX9qrYNCAFINAAsgBEEKdq0hHgJAAkAg\
BEGBCEkNACACIARJDQYgAC0AaiEIIANB+ABqQThqQgA3AwAgA0H4AGpBMGpCADcDACAJQgA3AwAgA0\
H4AGpBIGpCADcDACADQfgAakEYakIANwMAIANB+ABqQRBqQgA3AwAgC0IANwMAIANCADcDeCABIAQg\
ByAfIAggA0H4AGpBwAAQDiEFIANBkAJqQRhqQgA3AwAgA0GQAmpBEGpCADcDACADQZACakEIakIANw\
MAIANCADcDkAICQCAFQQNJDQADQCAFQQV0IgVBwQBPDQkgA0H4AGogBSAHIAggA0GQAmpBIBAhIgVB\
BXQiBkHBAE8NCiAGQSFPDQsgA0H4AGogA0GQAmogBhCXARogBUECSw0ACwsgAygCtAEhECADKAKwAS\
ERIAMoAqwBIRIgAygCqAEhEyADKAKkASEUIAMoAqABIRUgAygCnAEhFiADKAKYASEXIAMoApQBIQgg\
AygCkAEhDyADKAKMASEYIAMoAogBIRkgAygChAEhGiADKAKAASEbIAMoAnwhHCADKAJ4IR0gACAAKQ\
MAEBcgDC0AACIGQTdPDQogDiAGQQV0aiIFIB02AgAgBSAINgIcIAUgDzYCGCAFIBg2AhQgBSAZNgIQ\
IAUgGjYCDCAFIBs2AgggBSAcNgIEIAwgBkEBajoAACAAIAApAwAgHkIBiHwQFyAMLQAAIgZBN08NCy\
AOIAZBBXRqIgUgFzYCACAFIBA2AhwgBSARNgIYIAUgEjYCFCAFIBM2AhAgBSAUNgIMIAUgFTYCCCAF\
IBY2AgQgDCAGQQFqOgAADAELIAlCADcDACAJQQhqIg9CADcDACAJQRBqIhhCADcDACAJQRhqIhlCAD\
cDACAJQSBqIhpCADcDACAJQShqIhtCADcDACAJQTBqIhxCADcDACAJQThqIh1CADcDACALIAcpAwA3\
AwAgC0EIaiIFIAdBCGopAwA3AwAgC0EQaiIGIAdBEGopAwA3AwAgC0EYaiIIIAdBGGopAwA3AwAgA0\
EAOwHgASADIB83A3ggAyAALQBqOgDiASADQfgAaiABIAQQORogDSALKQMANwMAIA1BCGogBSkDADcD\
ACANQRBqIAYpAwA3AwAgDUEYaiAIKQMANwMAIAogCSkDADcDACAKQQhqIA8pAwA3AwAgCkEQaiAYKQ\
MANwMAIApBGGogGSkDADcDACAKQSBqIBopAwA3AwAgCkEoaiAbKQMANwMAIApBMGogHCkDADcDACAK\
QThqIB0pAwA3AwAgAy0A4gEhDyADLQDhASEYIAMgAy0A4AEiGToAcCADIAMpA3giHzcDCCADIA8gGE\
VyQQJyIg86AHEgA0HoAWpBGGoiGCAIKQIANwMAIANB6AFqQRBqIgggBikCADcDACADQegBakEIaiIG\
IAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBkgHyAPEAogGCgCACEPIAgoAgAhCCAGKAIAIRggAy\
gChAIhGSADKAL8ASEaIAMoAvQBIRsgAygC7AEhHCADKALoASEdIAAgACkDABAXIAwtAAAiBkE3Tw0L\
IA4gBkEFdGoiBSAdNgIAIAUgGTYCHCAFIA82AhggBSAaNgIUIAUgCDYCECAFIBs2AgwgBSAYNgIIIA\
UgHDYCBCAMIAZBAWo6AAALIAAgACkDACAefCIfNwMAIAIgBEkNCyABIARqIQEgAiAEayICQYAISw0A\
CwsgAkUNACAAIAEgAhA5GiAAIAApAwAQFwsgA0GwAmokAA8LIANBkAJqQQhqIgQgCTYCACADQZACak\
EQaiIFIAc2AgAgA0GQAmpBGGoiBiAINgIAIAMgDDYCnAIgA0GBAWoiByAEKQIANwAAIAMgCzYCpAIg\
A0GJAWoiBCAFKQIANwAAIAMgCjYCrAIgA0GRAWoiBSAGKQIANwAAIAMgDTYClAIgAyAONgKQAiADIA\
MpApACNwB5IANBCGpBGGogBSkAADcDACADQQhqQRBqIAQpAAA3AwAgA0EIakEIaiAHKQAANwMAIAMg\
AykAeTcDCEGQncAAQSsgA0EIakHMi8AAQfCKwAAQfwALIAQgAkGgisAAEIUBAAsgBUHAAEGMicAAEI\
UBAAsgBkHAAEGcicAAEIUBAAsgBkEgQayJwAAQhQEACyADQZACakEIaiIEIBs2AgAgA0GQAmpBEGoi\
BSAZNgIAIANBkAJqQRhqIgYgDzYCACADIBo2ApwCIANBgQFqIgcgBCkDADcAACADIBg2AqQCIANBiQ\
FqIgQgBSkDADcAACADIAg2AqwCIANBkQFqIgUgBikDADcAACADIBw2ApQCIAMgHTYCkAIgAyADKQOQ\
AjcAeSADQQhqQRhqIAUpAAA3AwAgA0EIakEQaiAEKQAANwMAIANBCGpBCGogBykAADcDACADIAMpAH\
k3AwhBkJ3AAEErIANBCGpBzIvAAEHwisAAEH8ACyADQZACakEIaiIEIBU2AgAgA0GQAmpBEGoiBSAT\
NgIAIANBkAJqQRhqIgYgETYCACADIBQ2ApwCIANBgQFqIgcgBCkDADcAACADIBI2AqQCIANBiQFqIg\
QgBSkDADcAACADIBA2AqwCIANBkQFqIgUgBikDADcAACADIBY2ApQCIAMgFzYCkAIgAyADKQOQAjcA\
eSADQQhqQRhqIAUpAAA3AwAgA0EIakEQaiAEKQAANwMAIANBCGpBCGogBykAADcDACADIAMpAHk3Aw\
hBkJ3AAEErIANBCGpBzIvAAEHwisAAEH8ACyADQZgCaiIEIBg2AgAgA0GgAmoiBSAINgIAIANBqAJq\
IgYgDzYCACADIBs2ApwCIANB8QFqIgcgBCkDADcAACADIBo2AqQCIANB+QFqIgggBSkDADcAACADIB\
k2AqwCIANBgQJqIgAgBikDADcAACADIBw2ApQCIAMgHTYCkAIgAyADKQOQAjcA6QEgBiAAKQAANwMA\
IAUgCCkAADcDACAEIAcpAAA3AwAgAyADKQDpATcDkAJBkJ3AAEErIANBkAJqQcyLwABB8IrAABB/AA\
sgBCACQbCKwAAQhAEAC+oRARh/IwAhAiAAKAIAIQMgACgCCCEEIAAoAgwhBSAAKAIEIQYgAkHAAGsi\
AkEYaiIHQgA3AwAgAkEgaiIIQgA3AwAgAkE4aiIJQgA3AwAgAkEwaiIKQgA3AwAgAkEoaiILQgA3Aw\
AgAkEIaiIMIAEpAAg3AwAgAkEQaiINIAEpABA3AwAgByABKAAYIg42AgAgCCABKAAgIg82AgAgAiAB\
KQAANwMAIAIgASgAHCIQNgIcIAIgASgAJCIRNgIkIAsgASgAKCISNgIAIAIgASgALCILNgIsIAogAS\
gAMCITNgIAIAIgASgANCIKNgI0IAkgASgAOCIUNgIAIAIgASgAPCIJNgI8IAAgAyANKAIAIg0gDyAT\
IAIoAgAiFSARIAogAigCBCIWIAIoAhQiFyAKIBEgFyAWIBMgDyANIAYgFSADIAQgBnFqIAUgBkF/c3\
FqakH4yKq7fWpBB3dqIgFqIAYgAigCDCIYaiAEIAwoAgAiDGogBSAWaiABIAZxaiAEIAFBf3NxakHW\
7p7GfmpBDHcgAWoiAiABcWogBiACQX9zcWpB2+GBoQJqQRF3IAJqIgcgAnFqIAEgB0F/c3FqQe6d94\
18akEWdyAHaiIBIAdxaiACIAFBf3NxakGvn/Crf2pBB3cgAWoiCGogECABaiAOIAdqIBcgAmogCCAB\
cWogByAIQX9zcWpBqoyfvARqQQx3IAhqIgIgCHFqIAEgAkF/c3FqQZOMwcF6akERdyACaiIBIAJxai\
AIIAFBf3NxakGBqppqakEWdyABaiIHIAFxaiACIAdBf3NxakHYsYLMBmpBB3cgB2oiCGogCyAHaiAS\
IAFqIBEgAmogCCAHcWogASAIQX9zcWpBr++T2nhqQQx3IAhqIgIgCHFqIAcgAkF/c3FqQbG3fWpBEX\
cgAmoiASACcWogCCABQX9zcWpBvq/zynhqQRZ3IAFqIgcgAXFqIAIgB0F/c3FqQaKiwNwGakEHdyAH\
aiIIaiAUIAFqIAogAmogCCAHcWogASAIQX9zcWpBk+PhbGpBDHcgCGoiAiAIcWogByACQX9zIhlxak\
GOh+WzempBEXcgAmoiASAZcWogCSAHaiABIAJxaiAIIAFBf3MiGXFqQaGQ0M0EakEWdyABaiIHIAJx\
akHiyviwf2pBBXcgB2oiCGogCyABaiAIIAdBf3NxaiAOIAJqIAcgGXFqIAggAXFqQcDmgoJ8akEJdy\
AIaiICIAdxakHRtPmyAmpBDncgAmoiASACQX9zcWogFSAHaiACIAhBf3NxaiABIAhxakGqj9vNfmpB\
FHcgAWoiByACcWpB3aC8sX1qQQV3IAdqIghqIAkgAWogCCAHQX9zcWogEiACaiAHIAFBf3NxaiAIIA\
FxakHTqJASakEJdyAIaiICIAdxakGBzYfFfWpBDncgAmoiASACQX9zcWogDSAHaiACIAhBf3NxaiAB\
IAhxakHI98++fmpBFHcgAWoiByACcWpB5puHjwJqQQV3IAdqIghqIBggAWogCCAHQX9zcWogFCACai\
AHIAFBf3NxaiAIIAFxakHWj9yZfGpBCXcgCGoiAiAHcWpBh5vUpn9qQQ53IAJqIgEgAkF/c3FqIA8g\
B2ogAiAIQX9zcWogASAIcWpB7anoqgRqQRR3IAFqIgcgAnFqQYXSj896akEFdyAHaiIIaiATIAdqIA\
wgAmogByABQX9zcWogCCABcWpB+Me+Z2pBCXcgCGoiAiAIQX9zcWogECABaiAIIAdBf3NxaiACIAdx\
akHZhby7BmpBDncgAmoiByAIcWpBipmp6XhqQRR3IAdqIgggB3MiGSACc2pBwvJoakEEdyAIaiIBai\
ALIAdqIAEgCHMgDyACaiAZIAFzakGB7ce7eGpBC3cgAWoiAnNqQaLC9ewGakEQdyACaiIHIAJzIBQg\
CGogAiABcyAHc2pBjPCUb2pBF3cgB2oiAXNqQcTU+6V6akEEdyABaiIIaiAQIAdqIAggAXMgDSACai\
ABIAdzIAhzakGpn/veBGpBC3cgCGoiAnNqQeCW7bV/akEQdyACaiIHIAJzIBIgAWogAiAIcyAHc2pB\
8Pj+9XtqQRd3IAdqIgFzakHG/e3EAmpBBHcgAWoiCGogGCAHaiAIIAFzIBUgAmogASAHcyAIc2pB+s\
+E1X5qQQt3IAhqIgJzakGF4bynfWpBEHcgAmoiByACcyAOIAFqIAIgCHMgB3NqQYW6oCRqQRd3IAdq\
IgFzakG5oNPOfWpBBHcgAWoiCGogDCABaiATIAJqIAEgB3MgCHNqQeWz7rZ+akELdyAIaiICIAhzIA\
kgB2ogCCABcyACc2pB+PmJ/QFqQRB3IAJqIgFzakHlrLGlfGpBF3cgAWoiByACQX9zciABc2pBxMSk\
oX9qQQZ3IAdqIghqIBcgB2ogFCABaiAQIAJqIAggAUF/c3IgB3NqQZf/q5kEakEKdyAIaiICIAdBf3\
NyIAhzakGnx9DcempBD3cgAmoiASAIQX9zciACc2pBucDOZGpBFXcgAWoiByACQX9zciABc2pBw7Pt\
qgZqQQZ3IAdqIghqIBYgB2ogEiABaiAYIAJqIAggAUF/c3IgB3NqQZKZs/h4akEKdyAIaiICIAdBf3\
NyIAhzakH96L9/akEPdyACaiIBIAhBf3NyIAJzakHRu5GseGpBFXcgAWoiByACQX9zciABc2pBz/yh\
/QZqQQZ3IAdqIghqIAogB2ogDiABaiAJIAJqIAggAUF/c3IgB3NqQeDNs3FqQQp3IAhqIgIgB0F/c3\
IgCHNqQZSGhZh6akEPdyACaiIBIAhBf3NyIAJzakGho6DwBGpBFXcgAWoiByACQX9zciABc2pBgv3N\
un9qQQZ3IAdqIghqNgIAIAAgBSALIAJqIAggAUF/c3IgB3NqQbXk6+l7akEKdyAIaiICajYCDCAAIA\
QgDCABaiACIAdBf3NyIAhzakG7pd/WAmpBD3cgAmoiAWo2AgggACABIAZqIBEgB2ogASAIQX9zciAC\
c2pBkaeb3H5qQRV3ajYCBAuYEAEFfyAAIAEtAAAiAjoAECAAIAEtAAEiAzoAESAAIAEtAAIiBDoAEi\
AAIAEtAAMiBToAEyAAIAEtAAQiBjoAFCAAIAIgAC0AAHM6ACAgACADIAAtAAFzOgAhIAAgBCAALQAC\
czoAIiAAIAUgAC0AA3M6ACMgACAGIAAtAARzOgAkIAAgAS0ABSICOgAVIAAgAS0ABiIDOgAWIAAgAS\
0AByIEOgAXIAAgAS0ACCIFOgAYIAAgAS0ACSIGOgAZIAAgAiAALQAFczoAJSAAIAMgAC0ABnM6ACYg\
ACAEIAAtAAdzOgAnIAAgBSAALQAIczoAKCAAIAEtAAoiAjoAGiAAIAEtAAsiAzoAGyAAIAEtAAwiBD\
oAHCAAIAEtAA0iBToAHSAAIAYgAC0ACXM6ACkgACACIAAtAApzOgAqIAAgAyAALQALczoAKyAAIAQg\
AC0ADHM6ACwgACAFIAAtAA1zOgAtIAAgAS0ADiICOgAeIAAgAiAALQAOczoALiAAIAEtAA8iAjoAHy\
AAIAIgAC0AD3M6AC9BACECQQAhAwNAIAAgA2oiBCAELQAAIAJB/wFxQZiYwABqLQAAcyICOgAAIANB\
AWoiA0EwRw0AC0EAIQMDQCAAIANqIgQgBC0AACACQf8BcUGYmMAAai0AAHMiAjoAACADQQFqIgNBME\
cNAAsgAkEBaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIAJBAWoiAkEw\
Rw0ACyADQQJqIQNBACECA0AgACACaiIEIAQtAAAgA0H/AXFBmJjAAGotAABzIgM6AAAgAkEBaiICQT\
BHDQALIANBA2ohA0EAIQIDQCAAIAJqIgQgBC0AACADQf8BcUGYmMAAai0AAHMiAzoAACACQQFqIgJB\
MEcNAAsgA0EEaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIAJBAWoiAk\
EwRw0ACyADQQVqIQNBACECA0AgACACaiIEIAQtAAAgA0H/AXFBmJjAAGotAABzIgM6AAAgAkEBaiIC\
QTBHDQALIANBBmohA0EAIQIDQCAAIAJqIgQgBC0AACADQf8BcUGYmMAAai0AAHMiAzoAACACQQFqIg\
JBMEcNAAsgA0EHaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIAJBAWoi\
AkEwRw0ACyADQQhqIQNBACECA0AgACACaiIEIAQtAAAgA0H/AXFBmJjAAGotAABzIgM6AAAgAkEBai\
ICQTBHDQALIANBCWohA0EAIQIDQCAAIAJqIgQgBC0AACADQf8BcUGYmMAAai0AAHMiAzoAACACQQFq\
IgJBMEcNAAsgA0EKaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIAJBAW\
oiAkEwRw0ACyADQQtqIQNBACECA0AgACACaiIEIAQtAAAgA0H/AXFBmJjAAGotAABzIgM6AAAgAkEB\
aiICQTBHDQALIANBDGohA0EAIQIDQCAAIAJqIgQgBC0AACADQf8BcUGYmMAAai0AAHMiAzoAACACQQ\
FqIgJBMEcNAAsgA0ENaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIAJB\
AWoiAkEwRw0ACyADQQ5qIQNBACECA0AgACACaiIEIAQtAAAgA0H/AXFBmJjAAGotAABzIgM6AAAgAk\
EBaiICQTBHDQALIANBD2ohA0EAIQIDQCAAIAJqIgQgBC0AACADQf8BcUGYmMAAai0AAHMiAzoAACAC\
QQFqIgJBMEcNAAsgA0EQaiEDQQAhAgNAIAAgAmoiBCAELQAAIANB/wFxQZiYwABqLQAAcyIDOgAAIA\
JBAWoiAkEwRw0ACyAAIAAtADAgAS0AACAAQT9qIgItAABzQZiYwABqLQAAcyIDOgAwIABBMWoiBCAE\
LQAAIAEtAAEgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBMmoiBCAELQAAIAEtAAIgA3NB/wFxQZiYwA\
BqLQAAcyIDOgAAIABBM2oiBCAELQAAIAEtAAMgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBNGoiBCAE\
LQAAIAEtAAQgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBNWoiBCAELQAAIAEtAAUgA3NB/wFxQZiYwA\
BqLQAAcyIDOgAAIABBNmoiBCAELQAAIAEtAAYgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBN2oiBCAE\
LQAAIAEtAAcgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBOGoiBCAELQAAIAEtAAggA3NB/wFxQZiYwA\
BqLQAAcyIDOgAAIABBOWoiBCAELQAAIAEtAAkgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBOmoiBCAE\
LQAAIAEtAAogA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBO2oiBCAELQAAIAEtAAsgA3NB/wFxQZiYwA\
BqLQAAcyIDOgAAIABBPGoiBCAELQAAIAEtAAwgA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBPWoiBCAE\
LQAAIAEtAA0gA3NB/wFxQZiYwABqLQAAcyIDOgAAIABBPmoiACAALQAAIAEtAA4gA3NB/wFxQZiYwA\
BqLQAAcyIAOgAAIAIgAi0AACABLQAPIABzQf8BcUGYmMAAai0AAHM6AAALyg4CDn8BfiMAQaACayIH\
JAACQAJAAkACQAJAAkACQAJAAkAgAUGBCEkNAEF/IAFBf2pBC3YiCGd2QQp0QYAIakGACCAIGyIIIA\
FLDQMgB0EIakEAQYABEJ0BGiABIAhrIQkgACAIaiEKIAhBCnatIAN8IRUgCEGACEcNASAHQQhqQSBq\
IQtB4AAhASAAQYAIIAIgAyAEIAdBCGpBIBAOIQgMAgsgB0IANwOIAUEAIQsCQCABQYB4cSIMRQ0AQQ\
AgDGshCkEBIQkgACEIA0AgCUEBcUUNBUEBIQsgB0EBOgCMASAHIAg2AogBIAhBgAhqIQhBACEJIApB\
gAhqIgoNAAsLIAFB/wdxIQkCQCAGQQV2IgggDEEARyIKIAogCEsbRQ0AIAcoAogBIQggB0EIakEYai\
IKIAJBGGopAgA3AwAgB0EIakEQaiILIAJBEGopAgA3AwAgB0EIakEIaiIBIAJBCGopAgA3AwAgByAC\
KQIANwMIIAdBCGogCEHAACADIARBAXIQCiAHQQhqIAhBwABqQcAAIAMgBBAKIAdBCGogCEGAAWpBwA\
AgAyAEEAogB0EIaiAIQcABakHAACADIAQQCiAHQQhqIAhBgAJqQcAAIAMgBBAKIAdBCGogCEHAAmpB\
wAAgAyAEEAogB0EIaiAIQYADakHAACADIAQQCiAHQQhqIAhBwANqQcAAIAMgBBAKIAdBCGogCEGABG\
pBwAAgAyAEEAogB0EIaiAIQcAEakHAACADIAQQCiAHQQhqIAhBgAVqQcAAIAMgBBAKIAdBCGogCEHA\
BWpBwAAgAyAEEAogB0EIaiAIQYAGakHAACADIAQQCiAHQQhqIAhBwAZqQcAAIAMgBBAKIAdBCGogCE\
GAB2pBwAAgAyAEEAogB0EIaiAIQcAHakHAACADIARBAnIQCiAFIAopAwA3ABggBSALKQMANwAQIAUg\
ASkDADcACCAFIAcpAwg3AAAgBy0AjAEhCwsgC0H/AXEhCAJAIAkNACAIQQBHIQgMCAsgB0GQAWpBMG\
oiDUIANwMAIAdBkAFqQThqIg5CADcDACAHQZABakHAAGoiD0IANwMAIAdBkAFqQcgAaiIQQgA3AwAg\
B0GQAWpB0ABqIhFCADcDACAHQZABakHYAGoiEkIANwMAIAdBkAFqQeAAaiITQgA3AwAgB0GQAWpBIG\
oiCiACQRhqKQIANwMAIAdBkAFqQRhqIgEgAkEQaikCADcDACAHQZABakEQaiIUIAJBCGopAgA3AwAg\
B0IANwO4ASAHIAQ6APoBIAcgAikCADcDmAEgB0EAOwH4ASAHIAhBAEciCK0gA3w3A5ABIAdBkAFqIA\
AgDGogCRA5GiAHQQhqQRBqIBQpAwA3AwAgB0EIakEYaiABKQMANwMAIAdBCGpBIGogCikDADcDACAH\
QQhqQTBqIA0pAwA3AwAgB0EIakE4aiAOKQMANwMAIAdBCGpBwABqIA8pAwA3AwAgB0EIakHIAGogEC\
kDADcDACAHQQhqQdAAaiARKQMANwMAIAdBCGpB2ABqIBIpAwA3AwAgB0EIakHgAGogEykDADcDACAH\
IAcpA5gBNwMQIAcgBykDuAE3AzAgBy0A+gEhCSAHLQD5ASEEIAcgBy0A+AEiAjoAcCAHIAcpA5ABIg\
M3AwggByAJIARFckECciIJOgBxIAdBgAJqQRhqIgQgCikDADcDACAHQYACakEQaiIKIAEpAwA3AwAg\
B0GAAmpBCGoiASAUKQMANwMAIAcgBykDmAE3A4ACIAdBgAJqIAdBMGogAiADIAkQCiAIQQV0IghBIG\
oiCSAGSw0EIAQoAgAhCSAKKAIAIQogASgCACEEIAcoApQCIQIgBygCjAIhASAHKAKEAiEAIAcoAoAC\
IQYgBSAIaiIIIAcoApwCNgAcIAggCTYAGCAIIAI2ABQgCCAKNgAQIAggATYADCAIIAQ2AAggCCAANg\
AEIAggBjYAAEECQQEgC0H/AXEbIQgMBwtBwAAhASAHQQhqQcAAaiELIAAgCCACIAMgBCAHQQhqQcAA\
EA4hCAsgCiAJIAIgFSAEIAsgARAOIQkCQCAIQQFHDQAgBkE/TQ0EIAUgBykACDcAACAFQThqIAdBCG\
pBOGopAAA3AAAgBUEwaiAHQQhqQTBqKQAANwAAIAVBKGogB0EIakEoaikAADcAACAFQSBqIAdBCGpB\
IGopAAA3AAAgBUEYaiAHQQhqQRhqKQAANwAAIAVBEGogB0EIakEQaikAADcAACAFQQhqIAdBCGpBCG\
opAAA3AABBAiEIDAYLIAkgCGpBBXQiCEGBAU8NBCAHQQhqIAggAiAEIAUgBhAhIQgMBQtBvInAAEEj\
QeCJwAAQlAEACyAHIAg2AghBkJ3AAEErIAdBCGpB3IvAAEHwisAAEH8ACyAJIAZB7IjAABCFAQALQc\
AAIAZB8InAABCFAQALIAhBgAFBgIrAABCFAQALIAdBoAJqJAAgCAvMDgEHfyAAQXhqIgEgAEF8aigC\
ACICQXhxIgBqIQMCQAJAIAJBAXENACACQQNxRQ0BIAEoAgAiAiAAaiEAAkBBACgChKdAIAEgAmsiAU\
cNACADKAIEQQNxQQNHDQFBACAANgL8pkAgAyADKAIEQX5xNgIEIAEgAEEBcjYCBCABIABqIAA2AgAP\
CwJAAkAgAkGAAkkNACABKAIYIQQCQAJAIAEoAgwiBSABRw0AIAFBFEEQIAEoAhQiBRtqKAIAIgINAU\
EAIQUMAwsgASgCCCICIAU2AgwgBSACNgIIDAILIAFBFGogAUEQaiAFGyEGA0AgBiEHAkAgAiIFQRRq\
IgYoAgAiAg0AIAVBEGohBiAFKAIQIQILIAINAAsgB0EANgIADAELAkAgAUEMaigCACIFIAFBCGooAg\
AiBkYNACAGIAU2AgwgBSAGNgIIDAILQQBBACgC7KNAQX4gAkEDdndxNgLso0AMAQsgBEUNAAJAAkAg\
ASgCHEECdEH8pcAAaiICKAIAIAFGDQAgBEEQQRQgBCgCECABRhtqIAU2AgAgBUUNAgwBCyACIAU2Ag\
AgBQ0AQQBBACgC8KNAQX4gASgCHHdxNgLwo0AMAQsgBSAENgIYAkAgASgCECICRQ0AIAUgAjYCECAC\
IAU2AhgLIAEoAhQiAkUNACAFQRRqIAI2AgAgAiAFNgIYCwJAAkAgAygCBCICQQJxRQ0AIAMgAkF+cT\
YCBCABIABBAXI2AgQgASAAaiAANgIADAELAkACQEEAKAKIp0AgA0YNAEEAKAKEp0AgA0cNAUEAIAE2\
AoSnQEEAQQAoAvymQCAAaiIANgL8pkAgASAAQQFyNgIEIAEgAGogADYCAA8LQQAgATYCiKdAQQBBAC\
gCgKdAIABqIgA2AoCnQCABIABBAXI2AgQCQCABQQAoAoSnQEcNAEEAQQA2AvymQEEAQQA2AoSnQAtB\
ACgCpKdAIgIgAE8NAkEAKAKIp0AiAEUNAgJAQQAoAoCnQCIFQSlJDQBBlKfAACEBA0ACQCABKAIAIg\
MgAEsNACADIAEoAgRqIABLDQILIAEoAggiAQ0ACwsCQAJAQQAoApynQCIADQBB/x8hAQwBC0EAIQED\
QCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCrKdAIAUgAk0NAkEAQX82AqSnQA\
8LIAJBeHEiBSAAaiEAAkACQAJAIAVBgAJJDQAgAygCGCEEAkACQCADKAIMIgUgA0cNACADQRRBECAD\
KAIUIgUbaigCACICDQFBACEFDAMLIAMoAggiAiAFNgIMIAUgAjYCCAwCCyADQRRqIANBEGogBRshBg\
NAIAYhBwJAIAIiBUEUaiIGKAIAIgINACAFQRBqIQYgBSgCECECCyACDQALIAdBADYCAAwBCwJAIANB\
DGooAgAiBSADQQhqKAIAIgNGDQAgAyAFNgIMIAUgAzYCCAwCC0EAQQAoAuyjQEF+IAJBA3Z3cTYC7K\
NADAELIARFDQACQAJAIAMoAhxBAnRB/KXAAGoiAigCACADRg0AIARBEEEUIAQoAhAgA0YbaiAFNgIA\
IAVFDQIMAQsgAiAFNgIAIAUNAEEAQQAoAvCjQEF+IAMoAhx3cTYC8KNADAELIAUgBDYCGAJAIAMoAh\
AiAkUNACAFIAI2AhAgAiAFNgIYCyADKAIUIgNFDQAgBUEUaiADNgIAIAMgBTYCGAsgASAAQQFyNgIE\
IAEgAGogADYCACABQQAoAoSnQEcNAEEAIAA2AvymQAwBCwJAAkACQCAAQYACSQ0AQR8hAwJAIABB//\
//B0sNACAAQQYgAEEIdmciA2tBH3F2QQFxIANBAXRrQT5qIQMLIAFCADcCECABQRxqIAM2AgAgA0EC\
dEH8pcAAaiECAkACQAJAAkACQAJAQQAoAvCjQCIFQQEgA0EfcXQiBnFFDQAgAigCACIFKAIEQXhxIA\
BHDQEgBSEDDAILQQAgBSAGcjYC8KNAIAIgATYCACABQRhqIAI2AgAMAwsgAEEAQRkgA0EBdmtBH3Eg\
A0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYoAgAiA0UNAiACQQF0IQIgAyEFIAMoAgRBeHEgAEcNAA\
sLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQA2AgAgASADNgIMIAEgADYCCAwCCyAGIAE2AgAgAUEY\
aiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAoAqynQEF/aiIBNgKsp0AgAQ0DQQAoApynQCIADQFB/x\
8hAQwCCyAAQQN2IgNBA3RB9KPAAGohAAJAAkBBACgC7KNAIgJBASADdCIDcUUNACAAKAIIIQMMAQtB\
ACACIANyNgLso0AgACEDCyAAIAE2AgggAyABNgIMIAEgADYCDCABIAM2AggPC0EAIQEDQCABQQFqIQ\
EgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCrKdADwsLlQwBGH8jACECIAAoAgAhAyAAKAII\
IQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhqIgdCADcDACACQSBqIghCADcDACACQThqIglCADcDAC\
ACQTBqIgpCADcDACACQShqIgtCADcDACACQQhqIgwgASkACDcDACACQRBqIg0gASkAEDcDACAHIAEo\
ABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3AwAgAiABKAAcIhA2AhwgAiABKAAkIhE2AiQgCyABKA\
AoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIhM2AgAgAiABKAA0Igo2AjQgCSABKAA4IhQ2AgAgAiAB\
KAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4gBiAEIAUgBiADIAYgBHFqIAUgBkF/c3FqIAIoAgAiFm\
pBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3ciByABcWogBiAHQX9zcWogDCgCACIMakELdyIIIAdx\
aiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEgAWogByAJQX9zcWogDSgCACINakEDdyIBIAlxIAdqIA\
ggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIaiAJIAJBf3NxampBC3ciByACcSAJaiABIAdBf3NxampB\
E3ciCCAHcSABaiACIAhBf3NxampBA3ciASAIcSACaiAHIAFBf3NxampBB3ciAiABcSAHaiAIIAJBf3\
NxampBC3ciByACcSAIaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAUIAEgCiAB\
IAhxIAJqIAcgAUF/c3FqakEHdyIJcSAHaiAIIAlBf3NxampBC3ciAiAJciAVIAIgCXEiByAIaiABIA\
JBf3NxampBE3ciAXEgB3JqIBZqQZnzidQFakEDdyIHIA8gAiAJIAcgASACcnEgASACcXJqIA1qQZnz\
idQFakEFdyIIIAcgAXJxIAcgAXFyampBmfOJ1AVqQQl3IgIgCHIgEyABIAIgCCAHcnEgCCAHcXJqak\
GZ84nUBWpBDXciAXEgAiAIcXJqIBdqQZnzidQFakEDdyIHIBEgAiAIIAcgASACcnEgASACcXJqIBlq\
QZnzidQFakEFdyIIIAcgAXJxIAcgAXFyampBmfOJ1AVqQQl3IgIgCHIgCiABIAIgCCAHcnEgCCAHcX\
JqakGZ84nUBWpBDXciAXEgAiAIcXJqIAxqQZnzidQFakEDdyIHIBIgAiAOIAggByABIAJycSABIAJx\
cmpqQZnzidQFakEFdyIIIAcgAXJxIAcgAXFyampBmfOJ1AVqQQl3IgIgCHIgFCABIAIgCCAHcnEgCC\
AHcXJqakGZ84nUBWpBDXciAXEgAiAIcXJqIBhqQZnzidQFakEDdyIHIBUgASALIAIgECAIIAcgASAC\
cnEgASACcXJqakGZ84nUBWpBBXciCCAHIAFycSAHIAFxcmpqQZnzidQFakEJdyIJIAggB3JxIAggB3\
FyampBmfOJ1AVqQQ13IgcgCXMiASAIc2ogFmpBodfn9gZqQQN3IgIgEyAHIAIgDyAIIAEgAnNqakGh\
1+f2BmpBCXciAXMgCSANaiACIAdzIAFzakGh1+f2BmpBC3ciCHNqakGh1+f2BmpBD3ciByAIcyIJIA\
FzaiAMakGh1+f2BmpBA3ciAiAUIAcgAiASIAEgCSACc2pqQaHX5/YGakEJdyIBcyAIIA5qIAIgB3Mg\
AXNqQaHX5/YGakELdyIIc2pqQaHX5/YGakEPdyIHIAhzIgkgAXNqIBdqQaHX5/YGakEDdyICIAogBy\
ACIBEgASAJIAJzampBodfn9gZqQQl3IgFzIAggGWogAiAHcyABc2pBodfn9gZqQQt3IghzampBodfn\
9gZqQQ93IgcgCHMiCSABc2ogGGpBodfn9gZqQQN3IgJqNgIAIAAgBSALIAEgCSACc2pqQaHX5/YGak\
EJdyIBajYCDCAAIAQgCCAQaiACIAdzIAFzakGh1+f2BmpBC3ciCGo2AgggACAGIBUgByABIAJzIAhz\
ampBodfn9gZqQQ93ajYCBAumDAEGfyAAIAFqIQICQAJAAkAgACgCBCIDQQFxDQAgA0EDcUUNASAAKA\
IAIgMgAWohAQJAQQAoAoSnQCAAIANrIgBHDQAgAigCBEEDcUEDRw0BQQAgATYC/KZAIAIgAigCBEF+\
cTYCBCAAIAFBAXI2AgQgAiABNgIADwsCQAJAIANBgAJJDQAgACgCGCEEAkACQCAAKAIMIgUgAEcNAC\
AAQRRBECAAKAIUIgUbaigCACIDDQFBACEFDAMLIAAoAggiAyAFNgIMIAUgAzYCCAwCCyAAQRRqIABB\
EGogBRshBgNAIAYhBwJAIAMiBUEUaiIGKAIAIgMNACAFQRBqIQYgBSgCECEDCyADDQALIAdBADYCAA\
wBCwJAIABBDGooAgAiBSAAQQhqKAIAIgZGDQAgBiAFNgIMIAUgBjYCCAwCC0EAQQAoAuyjQEF+IANB\
A3Z3cTYC7KNADAELIARFDQACQAJAIAAoAhxBAnRB/KXAAGoiAygCACAARg0AIARBEEEUIAQoAhAgAE\
YbaiAFNgIAIAVFDQIMAQsgAyAFNgIAIAUNAEEAQQAoAvCjQEF+IAAoAhx3cTYC8KNADAELIAUgBDYC\
GAJAIAAoAhAiA0UNACAFIAM2AhAgAyAFNgIYCyAAKAIUIgNFDQAgBUEUaiADNgIAIAMgBTYCGAsCQC\
ACKAIEIgNBAnFFDQAgAiADQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgAMAgsCQAJAQQAoAoinQCAC\
Rg0AQQAoAoSnQCACRw0BQQAgADYChKdAQQBBACgC/KZAIAFqIgE2AvymQCAAIAFBAXI2AgQgACABai\
ABNgIADwtBACAANgKIp0BBAEEAKAKAp0AgAWoiATYCgKdAIAAgAUEBcjYCBCAAQQAoAoSnQEcNAUEA\
QQA2AvymQEEAQQA2AoSnQA8LIANBeHEiBSABaiEBAkACQAJAIAVBgAJJDQAgAigCGCEEAkACQCACKA\
IMIgUgAkcNACACQRRBECACKAIUIgUbaigCACIDDQFBACEFDAMLIAIoAggiAyAFNgIMIAUgAzYCCAwC\
CyACQRRqIAJBEGogBRshBgNAIAYhBwJAIAMiBUEUaiIGKAIAIgMNACAFQRBqIQYgBSgCECEDCyADDQ\
ALIAdBADYCAAwBCwJAIAJBDGooAgAiBSACQQhqKAIAIgJGDQAgAiAFNgIMIAUgAjYCCAwCC0EAQQAo\
AuyjQEF+IANBA3Z3cTYC7KNADAELIARFDQACQAJAIAIoAhxBAnRB/KXAAGoiAygCACACRg0AIARBEE\
EUIAQoAhAgAkYbaiAFNgIAIAVFDQIMAQsgAyAFNgIAIAUNAEEAQQAoAvCjQEF+IAIoAhx3cTYC8KNA\
DAELIAUgBDYCGAJAIAIoAhAiA0UNACAFIAM2AhAgAyAFNgIYCyACKAIUIgJFDQAgBUEUaiACNgIAIA\
IgBTYCGAsgACABQQFyNgIEIAAgAWogATYCACAAQQAoAoSnQEcNAUEAIAE2AvymQAsPCwJAIAFBgAJJ\
DQBBHyECAkAgAUH///8HSw0AIAFBBiABQQh2ZyICa0EfcXZBAXEgAkEBdGtBPmohAgsgAEIANwIQIA\
BBHGogAjYCACACQQJ0QfylwABqIQMCQAJAAkACQAJAQQAoAvCjQCIFQQEgAkEfcXQiBnFFDQAgAygC\
ACIFKAIEQXhxIAFHDQEgBSECDAILQQAgBSAGcjYC8KNAIAMgADYCACAAQRhqIAM2AgAMAwsgAUEAQR\
kgAkEBdmtBH3EgAkEfRht0IQMDQCAFIANBHXZBBHFqQRBqIgYoAgAiAkUNAiADQQF0IQMgAiEFIAIo\
AgRBeHEgAUcNAAsLIAIoAggiASAANgIMIAIgADYCCCAAQRhqQQA2AgAgACACNgIMIAAgATYCCA8LIA\
YgADYCACAAQRhqIAU2AgALIAAgADYCDCAAIAA2AggPCyABQQN2IgJBA3RB9KPAAGohAQJAAkBBACgC\
7KNAIgNBASACdCICcUUNACABKAIIIQIMAQtBACADIAJyNgLso0AgASECCyABIAA2AgggAiAANgIMIA\
AgATYCDCAAIAI2AggLzwsCEH8EfiMAQeABayICJAACQAJAAkAgAUHwDmotAAAiA0UNACABQZABaiEE\
AkACQAJAAkAgAUHpAGotAAAiBUEGdEEAIAEtAGgiBmtHDQAgA0F+aiEHIANBAU0NBiACQfAAakEQai\
ABQfgAaikDADcDACACQfAAakEYaiABQYABaikDADcDACACQZABaiABQYgBaikDADcDACACQaABaiAE\
IAdBBXRqIgVBCGopAwA3AwAgAkGoAWogBUEQaikDADcDAEHAACEGIAJB8ABqQcAAaiAFQRhqKQMANw\
MAIAIgASkDcDcDeCACIAUpAwA3A5gBIANBBXQgBGpBYGoiBSkDACESIAUpAwghEyAFKQMQIRQgAS0A\
aiEIIAJB0AFqIAUpAxg3AwAgAkHIAWogFDcDACACQcABaiATNwMAIAJBuAFqIBI3AwBCACESIAJCAD\
cDcCACIAhBBHIiCToA2QEgAkHAADoA2AEgB0UNAiACQfAAakEIaiEFIAkhCgwBCyACQfAAakEQaiAB\
QRBqKQMANwMAIAJB8ABqQRhqIAFBGGopAwA3AwAgAkHwAGpBIGogAUEgaikDADcDACACQfAAakEwai\
ABQTBqKQMANwMAIAJB8ABqQThqIAFBOGopAwA3AwAgAkHwAGpBwABqIAFBwABqKQMANwMAIAJB8ABq\
QcgAaiABQcgAaikDADcDACACQfAAakHQAGogAUHQAGopAwA3AwAgAkHwAGpB2ABqIAFB2ABqKQMANw\
MAIAJB8ABqQeAAaiABQeAAaikDADcDACACIAEpAwg3A3ggAiABKQMoNwOYASACIAEtAGoiByAFRXJB\
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\
IA4pAgA3AwAgAiAGKQIANwOQASACQZABaiAAQcAAQgAgCBAKIAQoAgAhCyAMKAIAIQwgDSgCACENIA\
IoAqwBIQ4gAigCpAEhECACKAKcASERIAIoApQBIRIgAigCkAEhEyAPQf8BcSIEQTdPDQMgByAEQQV0\
aiIEIBM2AgAgBCAONgIcIAQgCzYCGCAEIBA2AhQgBCAMNgIQIAQgETYCDCAEIA02AgggBCASNgIEIA\
MgD0EBaiIEOgAAIARB/wFxIAVLDQALCyACQdABaiQADwtBnKLAAEErQZCKwAAQlAEACyACIA42AqwB\
IAIgCzYCqAEgAiAQNgKkASACIAw2AqABIAIgETYCnAEgAiANNgKYASACIBI2ApQBIAIgEzYCkAFBkJ\
3AAEErIAJBkAFqQcyLwABB8IrAABB/AAunBgERfyMAQYABayICJAACQAJAIAEoAgAiA0EQTw0AIAFB\
BGoiBCADakEQIANrIgMgAxCdARogAUEANgIAIAFBFGoiAyAEEA0gAkEQakEIaiIEIAFBzABqIgUpAA\
A3AwAgAiABQcQAaiIGKQAANwMQIAMgAkEQahANIAJBCGoiByABQRxqIggpAgA3AwAgAiABKQIUNwMA\
IAJBEGpBKGoiCUIANwMAIAJBEGpBIGoiCkIANwMAIAJBEGpBGGoiC0IANwMAIAJBEGpBEGoiDEIANw\
MAIARCADcDACACQgA3AxAgAkHQAGpBDGoiDUIANwIAIAJCADcCVCACQRA2AlAgAkHoAGpBEGogAkHQ\
AGpBEGooAgA2AgAgAkHoAGpBCGoiDiACQdAAakEIaiIPKQMANwMAIAIgAikDUDcDaCACQRBqQThqIh\
AgAkHoAGpBDGoiESkCADcDACACQRBqQTBqIhIgAikCbDcDACAFIBApAwA3AAAgBiASKQMANwAAIAFB\
PGogCSkDADcAACABQTRqIAopAwA3AAAgAUEsaiALKQMANwAAIAFBJGogDCkDADcAACAIIAQpAwA3AA\
AgASACKQMQNwAUIAFBADYCAEEQEAkiBUUNASAFIAIpAwA3AAAgBUEIaiAHKQMANwAAIAlCADcDACAK\
QgA3AwAgC0IANwMAIAJBEGpBEGoiBkIANwMAIARCADcDACACQgA3AxAgDUIANwIAIAJCADcCVCACQR\
A2AlAgAkHoAGpBEGogAkHQAGpBEGooAgA2AgAgDiAPKQMANwMAIAIgAikDUDcDaCAQIBEpAgA3AwAg\
EiACKQJsNwMAIANBOGogECkDADcAACADQTBqIBIpAwA3AAAgA0EoaiAJKQMANwAAIANBIGogCikDAD\
cAACADQRhqIAspAwA3AAAgA0EQaiAGKQMANwAAIANBCGogBCkDADcAACADIAIpAxA3AAAgAUEANgIA\
IABBEDYCBCAAIAU2AgAgAkGAAWokAA8LQbqfwABBFyACQRBqQeCawABB8JrAABB/AAtBEEEBQQAoAr\
ynQCICQQIgAhsRBAAAC/YFAgd/CH4jAEGgAWsiAiQAIAJBMGpBLGpCADcCACACQTBqQSRqQgA3AgAg\
AkEwakEcakIANwIAIAJBMGpBFGpCADcCACACQTBqQQxqQgA3AgAgAkIANwI0IAJBMDYCMCACQegAak\
EwaiACQTBqQTBqKAIANgIAIAJB6ABqQShqIAJBMGpBKGopAwA3AwAgAkHoAGpBIGogAkEwakEgaikD\
ADcDACACQegAakEYaiACQTBqQRhqKQMANwMAIAJB6ABqQRBqIAJBMGpBEGopAwA3AwAgAkHoAGpBCG\
ogAkEwakEIaikDADcDACACIAIpAzA3A2ggAkEoaiIDIAJB6ABqQSxqKQIANwMAIAJBIGoiBCACQegA\
akEkaikCADcDACACQRhqIgUgAkHoAGpBHGopAgA3AwAgAkEQaiIGIAJB6ABqQRRqKQIANwMAIAJBCG\
oiByACQegAakEMaikCADcDACACIAIpAmw3AwAgASACEB0gAUIANwMIIAFCADcDACABQQA2AlAgAUEA\
KQOQnEAiCTcDECABQRhqQQApA5icQCIKNwMAIAFBIGpBACkDoJxAIgs3AwAgAUEoakEAKQOonEAiDD\
cDACABQTBqQQApA7CcQCINNwMAIAFBOGpBACkDuJxAIg43AwAgAUHAAGpBACkDwJxAIg83AwAgAUHI\
AGpBACkDyJxAIhA3AwACQEEwEAkiCA0AQTBBAUEAKAK8p0AiAkECIAIbEQQAAAsgCCACKQMANwAAIA\
hBKGogAykDADcAACAIQSBqIAQpAwA3AAAgCEEYaiAFKQMANwAAIAhBEGogBikDADcAACAIQQhqIAcp\
AwA3AAAgAUIANwMIIAFCADcDACABQQA2AlAgAUEQaiIBIAk3AwAgAUEIaiAKNwMAIAFBEGogCzcDAC\
ABQRhqIAw3AwAgAUEgaiANNwMAIAFBKGogDjcDACABQTBqIA83AwAgAUE4aiAQNwMAIABBMDYCBCAA\
IAg2AgAgAkGgAWokAAvhBQIJfwh+IwBB0AFrIgIkACACQcAAakEMakIANwIAIAJBwABqQRRqQgA3Ag\
AgAkHAAGpBHGpCADcCACACQcAAakEkakIANwIAIAJBwABqQSxqQgA3AgAgAkHAAGpBNGpCADcCACAC\
QcAAakE8akIANwIAIAJCADcCRCACQcAANgJAIAJBiAFqIAJBwABqQcQAEJcBGiACQThqIgMgAkGIAW\
pBPGopAgA3AwAgAkEwaiIEIAJBiAFqQTRqKQIANwMAIAJBKGoiBSACQYgBakEsaikCADcDACACQSBq\
IgYgAkGIAWpBJGopAgA3AwAgAkEYaiIHIAJBiAFqQRxqKQIANwMAIAJBEGoiCCACQYgBakEUaikCAD\
cDACACQQhqIgkgAkGIAWpBDGopAgA3AwAgAiACKQKMATcDACABIAIQFiABQgA3AwggAUIANwMAIAFB\
ADYCUCABQQApA9CcQCILNwMQIAFBGGpBACkD2JxAIgw3AwAgAUEgakEAKQPgnEAiDTcDACABQShqQQ\
ApA+icQCIONwMAIAFBMGpBACkD8JxAIg83AwAgAUE4akEAKQP4nEAiEDcDACABQcAAakEAKQOAnUAi\
ETcDACABQcgAakEAKQOInUAiEjcDAAJAQcAAEAkiCg0AQcAAQQFBACgCvKdAIgJBAiACGxEEAAALIA\
ogAikDADcAACAKQThqIAMpAwA3AAAgCkEwaiAEKQMANwAAIApBKGogBSkDADcAACAKQSBqIAYpAwA3\
AAAgCkEYaiAHKQMANwAAIApBEGogCCkDADcAACAKQQhqIAkpAwA3AAAgAUIANwMIIAFCADcDACABQQ\
A2AlAgAUEQaiIBIAs3AwAgAUEIaiAMNwMAIAFBEGogDTcDACABQRhqIA43AwAgAUEgaiAPNwMAIAFB\
KGogEDcDACABQTBqIBE3AwAgAUE4aiASNwMAIABBwAA2AgQgACAKNgIAIAJB0AFqJAALoAUBCn8jAE\
EwayIDJAAgA0EkaiABNgIAIANBAzoAKCADQoCAgICABDcDCCADIAA2AiBBACEAIANBADYCGCADQQA2\
AhACQAJAAkACQCACKAIIIgENACACKAIAIQQgAigCBCIFIAJBFGooAgAiASABIAVLGyIGRQ0BIAIoAh\
AhB0EAIQAgBiEBA0ACQCAEIABqIghBBGooAgAiCUUNACADKAIgIAgoAgAgCSADKAIkKAIMEQcADQQL\
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\
IAtBBXQhDkEAIQsgBiEKA0AgCigCACEHIAZBEGpBGGoiCSACQRhqKQIANwMAIAZBEGpBEGoiASACQR\
BqKQIANwMAIAZBEGpBCGoiAyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAdBwABCACANEAogBCAL\
aiIHQRhqIAkpAwA3AAAgB0EQaiABKQMANwAAIAdBCGogAykDADcAACAHIAYpAxA3AAAgCkEEaiEKIA\
4gC0EgaiILRw0ACyAGLQAIIQcLAkAgDEUNACAHQQV0IgIgBUsNAiAFIAJrIgtBH00NAyAMQSBHDQQg\
BCACaiICIAAgCGoiCykAADcAACACQRhqIAtBGGopAAA3AAAgAkEQaiALQRBqKQAANwAAIAJBCGogC0\
EIaikAADcAACAHQQFqIQcLIAZBMGokACAHDwsgBiALNgIQQZCdwABBKyAGQRBqQeCKwABB8IrAABB/\
AAsgAiAFQfyIwAAQhAEAC0EgIAtB/IjAABCFAQALQSAgDEGMnsAAEIYBAAuoBAEEfyMAQfAAayICJA\
AgAkEgakEcakIANwIAIAJBIGpBFGpCADcCACACQSBqQQxqQgA3AgAgAkIANwIkIAJBIDYCICACQcgA\
akEYaiACQSBqQRhqKQMANwMAIAJByABqQRBqIAJBIGpBEGopAwA3AwAgAkHIAGpBCGogAkEgakEIai\
kDADcDACACQcgAakEgaiACQSBqQSBqKAIANgIAIAIgAikDIDcDSCACQRBqIAJByABqQRRqKQIANwMA\
IAJBCGogAkHIAGpBDGopAgA3AwAgAkEYaiACQcgAakEcaikCADcDACACIAIpAkw3AwAgAiABEBIgAU\
IANwMAIAFBIGogAUGIAWopAwA3AwAgAUEYaiABQYABaikDADcDACABQRBqIAFB+ABqKQMANwMAIAEg\
ASkDcDcDCCABQShqQQBBwgAQnQEhAwJAIAFB8A5qIgQtAABFDQAgBEEAOgAACwJAQSAQCSIEDQBBIE\
EBQQAoArynQCICQQIgAhsRBAAACyAEIAIpAwA3AAAgBEEYaiACQRhqKQMANwAAIARBEGogAkEQaikD\
ADcAACAEQQhqIAJBCGopAwA3AAAgAUIANwMAIAFBCGoiBUEYaiABQfAAaiIBQRhqKQMANwMAIAVBEG\
ogAUEQaikDADcDACAFQQhqIAFBCGopAwA3AwAgBSABKQMANwMAIANBAEHCABCdARogAEEgNgIEIAAg\
BDYCACACQfAAaiQAC4kEAQd/IwBBoANrIgIkACACQegCakEsakIANwIAIAJB6AJqQSRqQgA3AgAgAk\
HoAmpBHGpCADcCACACQegCakEUakIANwIAIAJB6AJqQQxqQgA3AgAgAkIANwLsAiACQTA2AugCIAJB\
MGpBMGogAkHoAmpBMGooAgA2AgAgAkEwakEoaiACQegCakEoaikDADcDACACQTBqQSBqIAJB6AJqQS\
BqKQMANwMAIAJBMGpBGGogAkHoAmpBGGopAwA3AwAgAkEwakEQaiACQegCakEQaikDADcDACACQTBq\
QQhqIAJB6AJqQQhqKQMANwMAIAIgAikD6AI3AzAgAkEoaiIDIAJBMGpBLGopAgA3AwAgAkEgaiIEIA\
JBMGpBJGopAgA3AwAgAkEYaiIFIAJBMGpBHGopAgA3AwAgAkEQaiIGIAJBMGpBFGopAgA3AwAgAkEI\
aiIHIAJBMGpBDGopAgA3AwAgAiACKQI0NwMAIAJBMGogAUG4AhCXARogAkEwaiACEFoCQEEwEAkiCA\
0AQTBBAUEAKAK8p0AiAkECIAIbEQQAAAsgCCACKQMANwAAIAhBKGogAykDADcAACAIQSBqIAQpAwA3\
AAAgCEEYaiAFKQMANwAAIAhBEGogBikDADcAACAIQQhqIAcpAwA3AAAgARAPIABBMDYCBCAAIAg2Ag\
AgAkGgA2okAAuJBAEHfyMAQaADayICJAAgAkHoAmpBLGpCADcCACACQegCakEkakIANwIAIAJB6AJq\
QRxqQgA3AgAgAkHoAmpBFGpCADcCACACQegCakEMakIANwIAIAJCADcC7AIgAkEwNgLoAiACQTBqQT\
BqIAJB6AJqQTBqKAIANgIAIAJBMGpBKGogAkHoAmpBKGopAwA3AwAgAkEwakEgaiACQegCakEgaikD\
ADcDACACQTBqQRhqIAJB6AJqQRhqKQMANwMAIAJBMGpBEGogAkHoAmpBEGopAwA3AwAgAkEwakEIai\
ACQegCakEIaikDADcDACACIAIpA+gCNwMwIAJBKGoiAyACQTBqQSxqKQIANwMAIAJBIGoiBCACQTBq\
QSRqKQIANwMAIAJBGGoiBSACQTBqQRxqKQIANwMAIAJBEGoiBiACQTBqQRRqKQIANwMAIAJBCGoiBy\
ACQTBqQQxqKQIANwMAIAIgAikCNDcDACACQTBqIAFBuAIQlwEaIAJBMGogAhBZAkBBMBAJIggNAEEw\
QQFBACgCvKdAIgJBAiACGxEEAAALIAggAikDADcAACAIQShqIAMpAwA3AAAgCEEgaiAEKQMANwAAIA\
hBGGogBSkDADcAACAIQRBqIAYpAwA3AAAgCEEIaiAHKQMANwAAIAEQDyAAQTA2AgQgACAINgIAIAJB\
oANqJAALiQQBB38jAEHAAmsiAiQAIAJBiAJqQSxqQgA3AgAgAkGIAmpBJGpCADcCACACQYgCakEcak\
IANwIAIAJBiAJqQRRqQgA3AgAgAkGIAmpBDGpCADcCACACQgA3AowCIAJBMDYCiAIgAkEwakEwaiAC\
QYgCakEwaigCADYCACACQTBqQShqIAJBiAJqQShqKQMANwMAIAJBMGpBIGogAkGIAmpBIGopAwA3Aw\
AgAkEwakEYaiACQYgCakEYaikDADcDACACQTBqQRBqIAJBiAJqQRBqKQMANwMAIAJBMGpBCGogAkGI\
AmpBCGopAwA3AwAgAiACKQOIAjcDMCACQShqIgMgAkEwakEsaikCADcDACACQSBqIgQgAkEwakEkai\
kCADcDACACQRhqIgUgAkEwakEcaikCADcDACACQRBqIgYgAkEwakEUaikCADcDACACQQhqIgcgAkEw\
akEMaikCADcDACACIAIpAjQ3AwAgAkEwaiABQdgBEJcBGiACQTBqIAIQHQJAQTAQCSIIDQBBMEEBQQ\
AoArynQCICQQIgAhsRBAAACyAIIAIpAwA3AAAgCEEoaiADKQMANwAAIAhBIGogBCkDADcAACAIQRhq\
IAUpAwA3AAAgCEEQaiAGKQMANwAAIAhBCGogBykDADcAACABEA8gAEEwNgIEIAAgCDYCACACQcACai\
QAC4gEAQd/IwBBoAFrIgIkACACQTBqQSxqQgA3AgAgAkEwakEkakIANwIAIAJBMGpBHGpCADcCACAC\
QTBqQRRqQgA3AgAgAkEwakEMakIANwIAIAJCADcCNCACQTA2AjAgAkHoAGpBMGogAkEwakEwaigCAD\
YCACACQegAakEoaiACQTBqQShqKQMANwMAIAJB6ABqQSBqIAJBMGpBIGopAwA3AwAgAkHoAGpBGGog\
AkEwakEYaikDADcDACACQegAakEQaiACQTBqQRBqKQMANwMAIAJB6ABqQQhqIAJBMGpBCGopAwA3Aw\
AgAiACKQMwNwNoIAJBKGoiAyACQegAakEsaikCADcDACACQSBqIgQgAkHoAGpBJGopAgA3AwAgAkEY\
aiIFIAJB6ABqQRxqKQIANwMAIAJBEGoiBiACQegAakEUaikCADcDACACQQhqIgcgAkHoAGpBDGopAg\
A3AwAgAiACKQJsNwMAIAEgAhBZIAFBAEHMARCdASEIAkBBMBAJIgENAEEwQQFBACgCvKdAIgJBAiAC\
GxEEAAALIAEgAikDADcAACABQShqIAMpAwA3AAAgAUEgaiAEKQMANwAAIAFBGGogBSkDADcAACABQR\
BqIAYpAwA3AAAgAUEIaiAHKQMANwAAIAhBAEHMARCdARogAEEwNgIEIAAgATYCACACQaABaiQAC4gE\
AQd/IwBBoAFrIgIkACACQTBqQSxqQgA3AgAgAkEwakEkakIANwIAIAJBMGpBHGpCADcCACACQTBqQR\
RqQgA3AgAgAkEwakEMakIANwIAIAJCADcCNCACQTA2AjAgAkHoAGpBMGogAkEwakEwaigCADYCACAC\
QegAakEoaiACQTBqQShqKQMANwMAIAJB6ABqQSBqIAJBMGpBIGopAwA3AwAgAkHoAGpBGGogAkEwak\
EYaikDADcDACACQegAakEQaiACQTBqQRBqKQMANwMAIAJB6ABqQQhqIAJBMGpBCGopAwA3AwAgAiAC\
KQMwNwNoIAJBKGoiAyACQegAakEsaikCADcDACACQSBqIgQgAkHoAGpBJGopAgA3AwAgAkEYaiIFIA\
JB6ABqQRxqKQIANwMAIAJBEGoiBiACQegAakEUaikCADcDACACQQhqIgcgAkHoAGpBDGopAgA3AwAg\
AiACKQJsNwMAIAEgAhBaIAFBAEHMARCdASEIAkBBMBAJIgENAEEwQQFBACgCvKdAIgJBAiACGxEEAA\
ALIAEgAikDADcAACABQShqIAMpAwA3AAAgAUEgaiAEKQMANwAAIAFBGGogBSkDADcAACABQRBqIAYp\
AwA3AAAgAUEIaiAHKQMANwAAIAhBAEHMARCdARogAEEwNgIEIAAgATYCACACQaABaiQAC/QDAQl/Iw\
BBoANrIgIkACACQdgCakEMakIANwIAIAJB2AJqQRRqQgA3AgAgAkHYAmpBHGpCADcCACACQdgCakEk\
akIANwIAIAJB2AJqQSxqQgA3AgAgAkHYAmpBNGpCADcCACACQdgCakE8akIANwIAIAJCADcC3AIgAk\
HAADYC2AIgAkHAAGogAkHYAmpBxAAQlwEaIAJBOGoiAyACQcAAakE8aikCADcDACACQTBqIgQgAkHA\
AGpBNGopAgA3AwAgAkEoaiIFIAJBwABqQSxqKQIANwMAIAJBIGoiBiACQcAAakEkaikCADcDACACQR\
hqIgcgAkHAAGpBHGopAgA3AwAgAkEQaiIIIAJBwABqQRRqKQIANwMAIAJBCGoiCSACQcAAakEMaikC\
ADcDACACIAIpAkQ3AwAgAkHAAGogAUGYAhCXARogAkHAAGogAhBLAkBBwAAQCSIKDQBBwABBAUEAKA\
K8p0AiAkECIAIbEQQAAAsgCiACKQMANwAAIApBOGogAykDADcAACAKQTBqIAQpAwA3AAAgCkEoaiAF\
KQMANwAAIApBIGogBikDADcAACAKQRhqIAcpAwA3AAAgCkEQaiAIKQMANwAAIApBCGogCSkDADcAAC\
ABEA8gAEHAADYCBCAAIAo2AgAgAkGgA2okAAv0AwEJfyMAQaADayICJAAgAkHYAmpBDGpCADcCACAC\
QdgCakEUakIANwIAIAJB2AJqQRxqQgA3AgAgAkHYAmpBJGpCADcCACACQdgCakEsakIANwIAIAJB2A\
JqQTRqQgA3AgAgAkHYAmpBPGpCADcCACACQgA3AtwCIAJBwAA2AtgCIAJBwABqIAJB2AJqQcQAEJcB\
GiACQThqIgMgAkHAAGpBPGopAgA3AwAgAkEwaiIEIAJBwABqQTRqKQIANwMAIAJBKGoiBSACQcAAak\
EsaikCADcDACACQSBqIgYgAkHAAGpBJGopAgA3AwAgAkEYaiIHIAJBwABqQRxqKQIANwMAIAJBEGoi\
CCACQcAAakEUaikCADcDACACQQhqIgkgAkHAAGpBDGopAgA3AwAgAiACKQJENwMAIAJBwABqIAFBmA\
IQlwEaIAJBwABqIAIQSgJAQcAAEAkiCg0AQcAAQQFBACgCvKdAIgJBAiACGxEEAAALIAogAikDADcA\
ACAKQThqIAMpAwA3AAAgCkEwaiAEKQMANwAAIApBKGogBSkDADcAACAKQSBqIAYpAwA3AAAgCkEYai\
AHKQMANwAAIApBEGogCCkDADcAACAKQQhqIAkpAwA3AAAgARAPIABBwAA2AgQgACAKNgIAIAJBoANq\
JAAL9AMBCX8jAEHgAmsiAiQAIAJBmAJqQQxqQgA3AgAgAkGYAmpBFGpCADcCACACQZgCakEcakIANw\
IAIAJBmAJqQSRqQgA3AgAgAkGYAmpBLGpCADcCACACQZgCakE0akIANwIAIAJBmAJqQTxqQgA3AgAg\
AkIANwKcAiACQcAANgKYAiACQcAAaiACQZgCakHEABCXARogAkE4aiIDIAJBwABqQTxqKQIANwMAIA\
JBMGoiBCACQcAAakE0aikCADcDACACQShqIgUgAkHAAGpBLGopAgA3AwAgAkEgaiIGIAJBwABqQSRq\
KQIANwMAIAJBGGoiByACQcAAakEcaikCADcDACACQRBqIgggAkHAAGpBFGopAgA3AwAgAkEIaiIJIA\
JBwABqQQxqKQIANwMAIAIgAikCRDcDACACQcAAaiABQdgBEJcBGiACQcAAaiACEBYCQEHAABAJIgoN\
AEHAAEEBQQAoArynQCICQQIgAhsRBAAACyAKIAIpAwA3AAAgCkE4aiADKQMANwAAIApBMGogBCkDAD\
cAACAKQShqIAUpAwA3AAAgCkEgaiAGKQMANwAAIApBGGogBykDADcAACAKQRBqIAgpAwA3AAAgCkEI\
aiAJKQMANwAAIAEQDyAAQcAANgIEIAAgCjYCACACQeACaiQAC/MDAQl/IwBB0AFrIgIkACACQcAAak\
EMakIANwIAIAJBwABqQRRqQgA3AgAgAkHAAGpBHGpCADcCACACQcAAakEkakIANwIAIAJBwABqQSxq\
QgA3AgAgAkHAAGpBNGpCADcCACACQcAAakE8akIANwIAIAJCADcCRCACQcAANgJAIAJBiAFqIAJBwA\
BqQcQAEJcBGiACQThqIgMgAkGIAWpBPGopAgA3AwAgAkEwaiIEIAJBiAFqQTRqKQIANwMAIAJBKGoi\
BSACQYgBakEsaikCADcDACACQSBqIgYgAkGIAWpBJGopAgA3AwAgAkEYaiIHIAJBiAFqQRxqKQIANw\
MAIAJBEGoiCCACQYgBakEUaikCADcDACACQQhqIgkgAkGIAWpBDGopAgA3AwAgAiACKQKMATcDACAB\
IAIQSiABQQBBzAEQnQEhCgJAQcAAEAkiAQ0AQcAAQQFBACgCvKdAIgJBAiACGxEEAAALIAEgAikDAD\
cAACABQThqIAMpAwA3AAAgAUEwaiAEKQMANwAAIAFBKGogBSkDADcAACABQSBqIAYpAwA3AAAgAUEY\
aiAHKQMANwAAIAFBEGogCCkDADcAACABQQhqIAkpAwA3AAAgCkEAQcwBEJ0BGiAAQcAANgIEIAAgAT\
YCACACQdABaiQAC/MDAQl/IwBB0AFrIgIkACACQcAAakEMakIANwIAIAJBwABqQRRqQgA3AgAgAkHA\
AGpBHGpCADcCACACQcAAakEkakIANwIAIAJBwABqQSxqQgA3AgAgAkHAAGpBNGpCADcCACACQcAAak\
E8akIANwIAIAJCADcCRCACQcAANgJAIAJBiAFqIAJBwABqQcQAEJcBGiACQThqIgMgAkGIAWpBPGop\
AgA3AwAgAkEwaiIEIAJBiAFqQTRqKQIANwMAIAJBKGoiBSACQYgBakEsaikCADcDACACQSBqIgYgAk\
GIAWpBJGopAgA3AwAgAkEYaiIHIAJBiAFqQRxqKQIANwMAIAJBEGoiCCACQYgBakEUaikCADcDACAC\
QQhqIgkgAkGIAWpBDGopAgA3AwAgAiACKQKMATcDACABIAIQSyABQQBBzAEQnQEhCgJAQcAAEAkiAQ\
0AQcAAQQFBACgCvKdAIgJBAiACGxEEAAALIAEgAikDADcAACABQThqIAMpAwA3AAAgAUEwaiAEKQMA\
NwAAIAFBKGogBSkDADcAACABQSBqIAYpAwA3AAAgAUEYaiAHKQMANwAAIAFBEGogCCkDADcAACABQQ\
hqIAkpAwA3AAAgCkEAQcwBEJ0BGiAAQcAANgIEIAAgATYCACACQdABaiQAC/ADAgV/BH4jAEHwAGsi\
AiQAIAJBIGpBHGpCADcCACACQSBqQRRqQgA3AgAgAkEgakEMakIANwIAIAJCADcCJCACQSA2AiAgAk\
HIAGpBIGogAkEgakEgaigCADYCACACQcgAakEYaiACQSBqQRhqKQMANwMAIAJByABqQRBqIAJBIGpB\
EGopAwA3AwAgAkHIAGpBCGogAkEgakEIaikDADcDACACIAIpAyA3A0ggAkEYaiIDIAJByABqQRxqKQ\
IANwMAIAJBEGoiBCACQcgAakEUaikCADcDACACQQhqIgUgAkHIAGpBDGopAgA3AwAgAiACKQJMNwMA\
IAEgAhAuIAFBADYCCCABQgA3AwAgAUEAKQPwm0AiBzcCTCABQdQAakEAKQP4m0AiCDcCACABQdwAak\
EAKQOAnEAiCTcCACABQeQAakEAKQOInEAiCjcCAAJAQSAQCSIGDQBBIEEBQQAoArynQCICQQIgAhsR\
BAAACyAGIAIpAwA3AAAgBkEYaiADKQMANwAAIAZBEGogBCkDADcAACAGQQhqIAUpAwA3AAAgAUEANg\
IIIAFCADcDACABQcwAaiIBIAc3AgAgAUEIaiAINwIAIAFBEGogCTcCACABQRhqIAo3AgAgAEEgNgIE\
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\
AWpBHGpCADcCACACQZgBakEUakIANwIAIAJBmAFqQQxqQgA3AgAgAkIANwKcASACQSA2ApgBIAJBKG\
pBIGogAkGYAWpBIGooAgA2AgAgAkEoakEYaiACQZgBakEYaikDADcDACACQShqQRBqIAJBmAFqQRBq\
KQMANwMAIAJBKGpBCGogAkGYAWpBCGopAwA3AwAgAiACKQOYATcDKCACQQhqQRhqIgMgAkEoakEcai\
kCADcDACACQQhqQRBqIgQgAkEoakEUaikCADcDACACQQhqQQhqIgUgAkEoakEMaikCADcDACACIAIp\
Aiw3AwggAkEoaiABQfAAEJcBGiACQShqIAJBCGoQLgJAQSAQCSIGDQBBIEEBQQAoArynQCICQQIgAh\
sRBAAACyAGIAIpAwg3AAAgBkEYaiADKQMANwAAIAZBEGogBCkDADcAACAGQQhqIAUpAwA3AAAgARAP\
IABBIDYCBCAAIAY2AgAgAkHAAWokAAv7AgEFfyMAQaADayICJAAgAkH4AmpBHGpCADcCACACQfgCak\
EUakIANwIAIAJB+AJqQQxqQgA3AgAgAkIANwL8AiACQSA2AvgCIAJBIGpBIGogAkH4AmpBIGooAgA2\
AgAgAkEgakEYaiACQfgCakEYaikDADcDACACQSBqQRBqIAJB+AJqQRBqKQMANwMAIAJBIGpBCGogAk\
H4AmpBCGopAwA3AwAgAiACKQP4AjcDICACQRhqIgMgAkEgakEcaikCADcDACACQRBqIgQgAkEgakEU\
aikCADcDACACQQhqIgUgAkEgakEMaikCADcDACACIAIpAiQ3AwAgAkEgaiABQdgCEJcBGiACQSBqIA\
IQZQJAQSAQCSIGDQBBIEEBQQAoArynQCICQQIgAhsRBAAACyAGIAIpAwA3AAAgBkEYaiADKQMANwAA\
IAZBEGogBCkDADcAACAGQQhqIAUpAwA3AAAgARAPIABBIDYCBCAAIAY2AgAgAkGgA2okAAv7AgEFfy\
MAQaADayICJAAgAkH4AmpBHGpCADcCACACQfgCakEUakIANwIAIAJB+AJqQQxqQgA3AgAgAkIANwL8\
AiACQSA2AvgCIAJBIGpBIGogAkH4AmpBIGooAgA2AgAgAkEgakEYaiACQfgCakEYaikDADcDACACQS\
BqQRBqIAJB+AJqQRBqKQMANwMAIAJBIGpBCGogAkH4AmpBCGopAwA3AwAgAiACKQP4AjcDICACQRhq\
IgMgAkEgakEcaikCADcDACACQRBqIgQgAkEgakEUaikCADcDACACQQhqIgUgAkEgakEMaikCADcDAC\
ACIAIpAiQ3AwAgAkEgaiABQdgCEJcBGiACQSBqIAIQZgJAQSAQCSIGDQBBIEEBQQAoArynQCICQQIg\
AhsRBAAACyAGIAIpAwA3AAAgBkEYaiADKQMANwAAIAZBEGogBCkDADcAACAGQQhqIAUpAwA3AAAgAR\
APIABBIDYCBCAAIAY2AgAgAkGgA2okAAv7AgEFfyMAQcAPayICJAAgAkGYD2pBHGpCADcCACACQZgP\
akEUakIANwIAIAJBmA9qQQxqQgA3AgAgAkIANwKcDyACQSA2ApgPIAJBIGpBIGogAkGYD2pBIGooAg\
A2AgAgAkEgakEYaiACQZgPakEYaikDADcDACACQSBqQRBqIAJBmA9qQRBqKQMANwMAIAJBIGpBCGog\
AkGYD2pBCGopAwA3AwAgAiACKQOYDzcDICACQRhqIgMgAkEgakEcaikCADcDACACQRBqIgQgAkEgak\
EUaikCADcDACACQQhqIgUgAkEgakEMaikCADcDACACIAIpAiQ3AwAgAkEgaiABQfgOEJcBGiACIAJB\
IGoQEgJAQSAQCSIGDQBBIEEBQQAoArynQCICQQIgAhsRBAAACyAGIAIpAwA3AAAgBkEYaiADKQMANw\
AAIAZBEGogBCkDADcAACAGQQhqIAUpAwA3AAAgARAPIABBIDYCBCAAIAY2AgAgAkHAD2okAAv6AgEF\
fyMAQfAAayICJAAgAkEgakEcakIANwIAIAJBIGpBFGpCADcCACACQSBqQQxqQgA3AgAgAkIANwIkIA\
JBIDYCICACQcgAakEgaiACQSBqQSBqKAIANgIAIAJByABqQRhqIAJBIGpBGGopAwA3AwAgAkHIAGpB\
EGogAkEgakEQaikDADcDACACQcgAakEIaiACQSBqQQhqKQMANwMAIAIgAikDIDcDSCACQRhqIgMgAk\
HIAGpBHGopAgA3AwAgAkEQaiIEIAJByABqQRRqKQIANwMAIAJBCGoiBSACQcgAakEMaikCADcDACAC\
IAIpAkw3AwAgASACEGUgAUEAQcwBEJ0BIQYCQEEgEAkiAQ0AQSBBAUEAKAK8p0AiAkECIAIbEQQAAA\
sgASACKQMANwAAIAFBGGogAykDADcAACABQRBqIAQpAwA3AAAgAUEIaiAFKQMANwAAIAZBAEHMARCd\
ARogAEEgNgIEIAAgATYCACACQfAAaiQAC/oCAQV/IwBB8ABrIgIkACACQSBqQRxqQgA3AgAgAkEgak\
EUakIANwIAIAJBIGpBDGpCADcCACACQgA3AiQgAkEgNgIgIAJByABqQSBqIAJBIGpBIGooAgA2AgAg\
AkHIAGpBGGogAkEgakEYaikDADcDACACQcgAakEQaiACQSBqQRBqKQMANwMAIAJByABqQQhqIAJBIG\
pBCGopAwA3AwAgAiACKQMgNwNIIAJBGGoiAyACQcgAakEcaikCADcDACACQRBqIgQgAkHIAGpBFGop\
AgA3AwAgAkEIaiIFIAJByABqQQxqKQIANwMAIAIgAikCTDcDACABIAIQZiABQQBBzAEQnQEhBgJAQS\
AQCSIBDQBBIEEBQQAoArynQCICQQIgAhsRBAAACyABIAIpAwA3AAAgAUEYaiADKQMANwAAIAFBEGog\
BCkDADcAACABQQhqIAUpAwA3AAAgBkEAQcwBEJ0BGiAAQSA2AgQgACABNgIAIAJB8ABqJAALjAMBB3\
8jAEGwAWsiAiQAIAJB2ABqQQRyIAFBBGoQYyACIAEoAgA2AlggAkGYAWoiAyABQTxqKQAANwMAIAJB\
kAFqIgQgAUE0aikAADcDACACQYgBaiIFIAFBLGopAAA3AwAgAkHwAGpBEGoiBiABQSRqKQAANwMAIA\
JB8ABqQQhqIgcgAUEcaikAADcDACACIAEpABQ3A3AgAkGgAWoiCCABQcQAahBjIAJBEGogAkHYAGpB\
EGooAgA2AgAgAkEIaiACQdgAakEIaikDADcDACACQRxqIAcpAwA3AgAgAkEkaiAGKQMANwIAIAJBLG\
ogBSkDADcCACACQTRqIAQpAwA3AgAgAkE8aiADKQMANwIAIAJBxABqIAgpAwA3AgAgAkHMAGogAkGo\
AWopAwA3AgAgAiACKQNYNwMAIAIgAikDcDcCFAJAQdQAEAkiAQ0AQdQAQQRBACgCvKdAIgJBAiACGx\
EEAAALIAEgAkHUABCXASEBIABBlJXAADYCBCAAIAE2AgAgAkGwAWokAAvyAgEDfwJAAkACQAJAAkAg\
AC0AaCIDRQ0AIANBwQBPDQMgACADakEoaiABIAJBwAAgA2siAyADIAJLGyIDEJcBGiAAIAAtAGggA2\
oiBDoAaCABIANqIQECQCACIANrIgINAEEAIQIMAgsgAEEIaiAAQShqIgRBwAAgACkDACAALQBqIABB\
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\
AgEFfwJAAkACQAJAAkACQEGIASAAKALIASIDayIEIAJLDQAgAw0BIAEhBQwCCyADIAJqIgUgA0kNAi\
AFQYgBSw0DIABByAFqIANqQQRqIAEgAhCXARogACAAKALIASACajYCyAEPCyADQYkBTw0DIAIgBGsh\
AiABIARqIQUgACADakHMAWogASAEEJcBGkEAIQMDQCAAIANqIgEgAS0AACABQcwBai0AAHM6AAAgA0\
EBaiIDQYgBRw0ACyAAEBMLIAUgAiACQYgBcCIGayICaiEHAkAgAkGIAUkNAANAIAVBiAFqIQQgAkH4\
fmohAkEAIQMDQCAAIANqIgEgAS0AACAFIANqLQAAczoAACADQQFqIgNBiAFHDQALIAAQEyAEIQUgAk\
GIAU8NAAsLIABBzAFqIAcgBhCXARogACAGNgLIAQ8LIAMgBUG8oMAAEIgBAAsgBUGIAUG8oMAAEIUB\
AAsgA0GIAUHMoMAAEIQBAAvkAgEFfyMAQaADayICJAAgAkGAA2pBHGpBADYCACACQYADakEUakIANw\
IAIAJBgANqQQxqQgA3AgAgAkIANwKEAyACQRw2AoADIAJBIGpBEGogAkGAA2pBEGopAwA3AwAgAkEg\
akEIaiACQYADakEIaikDADcDACACQSBqQRhqIAJBgANqQRhqKQMANwMAIAJBCGoiAyACQSBqQQxqKQ\
IANwMAIAJBEGoiBCACQSBqQRRqKQIANwMAIAJBGGoiBSACQSBqQRxqKAIANgIAIAIgAikDgAM3AyAg\
AiACKQIkNwMAIAJBIGogAUHgAhCXARogAkEgaiACEGcCQEEcEAkiBg0AQRxBAUEAKAK8p0AiAkECIA\
IbEQQAAAsgBiACKQMANwAAIAZBGGogBSgCADYAACAGQRBqIAQpAwA3AAAgBkEIaiADKQMANwAAIAEQ\
DyAAQRw2AgQgACAGNgIAIAJBoANqJAAL5AIBBX8jAEGgA2siAiQAIAJBgANqQRxqQQA2AgAgAkGAA2\
pBFGpCADcCACACQYADakEMakIANwIAIAJCADcChAMgAkEcNgKAAyACQSBqQRBqIAJBgANqQRBqKQMA\
NwMAIAJBIGpBCGogAkGAA2pBCGopAwA3AwAgAkEgakEYaiACQYADakEYaikDADcDACACQQhqIgMgAk\
EgakEMaikCADcDACACQRBqIgQgAkEgakEUaikCADcDACACQRhqIgUgAkEgakEcaigCADYCACACIAIp\
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\
3J3AABCEAQALIAJBwABB7J3AABCHAQALIAJBwABB/J3AABCFAQALywICBH8BfiAAQQhqIQIgACkDAC\
EGAkACQAJAAkAgACgCMCIDQcAARw0AIAIgAEE0ahAFQQAhAyAAQQA2AjAMAQsgA0E/Sw0BCyAAQTRq\
IgQgA2pBgAE6AAAgACAAKAIwIgVBAWoiAzYCMAJAIANBwQBPDQAgAEEwaiADakEEakEAQT8gBWsQnQ\
EaAkBBwAAgACgCMGtBCE8NACACIAQQBSAAKAIwIgNBwQBPDQMgBEEAIAMQnQEaCyAAQewAaiAGQgOG\
NwIAIAIgBBAFIABBADYCMCABIAAoAgg2AAAgASAAQQxqKQIANwAEIAEgAEEUaikCADcADCABIABBHG\
opAgA3ABQgASAAQSRqKQIANwAcIAEgAEEsaigCADYAJA8LIANBwABB3J3AABCEAQALIANBwABB7J3A\
ABCHAQALIANBwABB/J3AABCFAQALuQIBA38jAEEQayICJAACQCAAKALIASIDQccASw0AIAAgA2pBzA\
FqQQY6AAACQCADQQFqIgRByABGDQAgACAEakHMAWpBAEHHACADaxCdARoLQQAhAyAAQQA2AsgBIABB\
kwJqIgQgBC0AAEGAAXI6AAADQCAAIANqIgQgBC0AACAEQcwBai0AAHM6AAAgA0EBaiIDQcgARw0ACy\
AAEBMgASAAKQAANwAAIAFBOGogAEE4aikAADcAACABQTBqIABBMGopAAA3AAAgAUEoaiAAQShqKQAA\
NwAAIAFBIGogAEEgaikAADcAACABQRhqIABBGGopAAA3AAAgAUEQaiAAQRBqKQAANwAAIAFBCGogAE\
EIaikAADcAACACQRBqJAAPC0G6n8AAQRcgAkEIakHUn8AAQYyiwAAQfwALuQIBA38jAEEQayICJAAC\
QCAAKALIASIDQccASw0AIAAgA2pBzAFqQQE6AAACQCADQQFqIgRByABGDQAgACAEakHMAWpBAEHHAC\
ADaxCdARoLQQAhAyAAQQA2AsgBIABBkwJqIgQgBC0AAEGAAXI6AAADQCAAIANqIgQgBC0AACAEQcwB\
ai0AAHM6AAAgA0EBaiIDQcgARw0ACyAAEBMgASAAKQAANwAAIAFBOGogAEE4aikAADcAACABQTBqIA\
BBMGopAAA3AAAgAUEoaiAAQShqKQAANwAAIAFBIGogAEEgaikAADcAACABQRhqIABBGGopAAA3AAAg\
AUEQaiAAQRBqKQAANwAAIAFBCGogAEEIaikAADcAACACQRBqJAAPC0G6n8AAQRcgAkEIakHUn8AAQc\
yhwAAQfwALtQIBBX8jAEGgAWsiAiQAIAJBADYCECACQQhqIAJBEGpBBHIgAkHUAGoQqAEgAigCECED\
AkAgAigCDCACKAIIIgRrIgVBwAAgBUHAAEkbIgZFDQAgBiEFA0AgBCABLQAAOgAAIARBAWohBCABQQ\
FqIQEgBUF/aiIFDQALIAIgAyAGaiIDNgIQCwJAIANBP0sNACADQcAAEIkBAAsgAkHYAGogAkEQakHE\
ABCXARogAEE4aiACQZQBaikCADcAACAAQTBqIAJBjAFqKQIANwAAIABBKGogAkGEAWopAgA3AAAgAE\
EgaiACQfwAaikCADcAACAAQRhqIAJB9ABqKQIANwAAIABBEGogAkHsAGopAgA3AAAgAEEIaiACQeQA\
aikCADcAACAAIAIpAlw3AAAgAkGgAWokAAu2AgEIfyMAQfAAayIBQShqIgJCADcDACABQSBqIgNCAD\
cDACABQRhqIgRCADcDACABQRBqIgVCADcDACABQQhqIgZCADcDACABQgA3AwAgAUHAAGpBDGpCADcC\
ACABQgA3AkQgAUEQNgJAIAFB2ABqQRBqIAFBwABqQRBqKAIANgIAIAFB2ABqQQhqIAFBwABqQQhqKQ\
MANwMAIAEgASkDQDcDWCABQThqIgcgAUHYAGpBDGopAgA3AwAgAUEwaiIIIAEpAlw3AwAgAEHMAGog\
BykDADcAACAAQcQAaiAIKQMANwAAIABBPGogAikDADcAACAAQTRqIAMpAwA3AAAgAEEsaiAEKQMANw\
AAIABBJGogBSkDADcAACAAQRxqIAYpAwA3AAAgACABKQMANwAUIABBADYCAAu3AgIFfwF+IwBBwAFr\
IgIkACACQdAAakEIaiIDIAFBEGopAwA3AwAgAkHQAGpBEGoiBCABQRhqKQMANwMAIAJB0ABqQRhqIg\
UgAUEgaikDADcDACACQdAAakEgaiIGIAFBKGopAwA3AwAgAiABKQMINwNQIAEpAwAhByACQfgAakEE\
ciABQTRqEEwgAiABKAIwNgJ4IAJBCGogAkH4AGpBxAAQlwEaAkBB+AAQCSIBDQBB+ABBCEEAKAK8p0\
AiAkECIAIbEQQAAAsgASAHNwMAIAEgAikDUDcDCCABQRBqIAMpAwA3AwAgAUEYaiAEKQMANwMAIAFB\
IGogBSkDADcDACABQShqIAYpAwA3AwAgAUEwaiACQQhqQcQAEJcBGiAAQfCUwAA2AgQgACABNgIAIA\
JBwAFqJAALowICBH8CfiAAIAApAwAiByACrUIDhnwiCDcDACAAQQhqIgMgAykDACAIIAdUrXw3AwAC\
QAJAQYABIAAoAlAiA2siBCACSw0AIABBEGohBQJAIANFDQAgA0GBAU8NAiAAQdQAaiIGIANqIAEgBB\
CXARogAEEANgJQIAUgBkEBEAMgAiAEayECIAEgBGohAQsgBSABIAJBB3YQAyAAQdQAaiABIAJBgH9x\
aiACQf8AcSICEJcBGiAAIAI2AlAPCwJAAkAgAyACaiIEIANJDQAgBEGAAUsNASAAQdAAaiADakEEai\
ABIAIQlwEaIAAgACgCUCACajYCUA8LIAMgBEG8ncAAEIgBAAsgBEGAAUG8ncAAEIUBAAsgA0GAAUHM\
ncAAEIQBAAueAgEEfyAAIAApAwAgAq18NwMAAkACQEHAACAAKAIIIgNrIgQgAksNACAAQcwAaiEFAk\
AgA0UNACADQcEATw0CIABBDGoiBiADaiABIAQQlwEaIAUgBhAMIAIgBGshAiABIARqIQELIAJBP3Eh\
AyABIAJBQHEiAmohBAJAIAJFDQBBACACayECA0AgBSABEAwgAUHAAGohASACQcAAaiICDQALCyAAQQ\
xqIAQgAxCXARogACADNgIIDwsCQAJAIAMgAmoiBSADSQ0AIAVBwABLDQEgAEEIaiADakEEaiABIAIQ\
lwEaIAAgACgCCCACajYCCA8LIAMgBUG8oMAAEIgBAAsgBUHAAEG8oMAAEIUBAAsgA0HAAEHMoMAAEI\
QBAAueAgEEfyAAIAApAwAgAq18NwMAAkACQEHAACAAKAIIIgNrIgQgAksNACAAQcwAaiEFAkAgA0UN\
ACADQcEATw0CIABBDGoiBiADaiABIAQQlwEaIAUgBhAQIAIgBGshAiABIARqIQELIAJBP3EhAyABIA\
JBQHEiAmohBAJAIAJFDQBBACACayECA0AgBSABEBAgAUHAAGohASACQcAAaiICDQALCyAAQQxqIAQg\
AxCXARogACADNgIIDwsCQAJAIAMgAmoiBSADSQ0AIAVBwABLDQEgAEEIaiADakEEaiABIAIQlwEaIA\
AgACgCCCACajYCCA8LIAMgBUG8oMAAEIgBAAsgBUHAAEG8oMAAEIUBAAsgA0HAAEHMoMAAEIQBAAud\
AgEEfyAAIAApAwAgAq18NwMAAkACQEHAACAAKAIcIgNrIgQgAksNACAAQQhqIQUCQCADRQ0AIANBwQ\
BPDQIgAEEgaiIGIANqIAEgBBCXARogBSAGEAYgAiAEayECIAEgBGohAQsgAkE/cSEDIAEgAkFAcSIC\
aiEEAkAgAkUNAEEAIAJrIQIDQCAFIAEQBiABQcAAaiEBIAJBwABqIgINAAsLIABBIGogBCADEJcBGi\
AAIAM2AhwPCwJAAkAgAyACaiIFIANJDQAgBUHAAEsNASAAQRxqIANqQQRqIAEgAhCXARogACAAKAIc\
IAJqNgIcDwsgAyAFQbygwAAQiAEACyAFQcAAQbygwAAQhQEACyADQcAAQcygwAAQhAEAC50CAQR/IA\
AgACkDACACrXw3AwACQAJAQcAAIAAoAjAiA2siBCACSw0AIABBCGohBQJAIANFDQAgA0HBAE8NAiAA\
QTRqIgYgA2ogASAEEJcBGiAFIAYQBSACIARrIQIgASAEaiEBCyACQT9xIQMgASACQUBxIgJqIQQCQC\
ACRQ0AQQAgAmshAgNAIAUgARAFIAFBwABqIQEgAkHAAGoiAg0ACwsgAEE0aiAEIAMQlwEaIAAgAzYC\
MA8LAkACQCADIAJqIgUgA0kNACAFQcAASw0BIABBMGogA2pBBGogASACEJcBGiAAIAAoAjAgAmo2Aj\
APCyADIAVBvKDAABCIAQALIAVBwABBvKDAABCFAQALIANBwABBzKDAABCEAQALpwICA38CfiMAQcAA\
ayICJAAgAkEQakEMakIANwIAIAJCADcCFCACQRA2AhAgAkEoakEQaiACQRBqQRBqKAIANgIAIAJBKG\
pBCGogAkEQakEIaikDADcDACACQQhqIgMgAkEoakEMaikCADcDACACIAIpAxA3AyggAiACKQIsNwMA\
IAEgAhBfIAFBADYCCCABQgA3AwAgAUHUAGpBACkCiJtAIgU3AgAgAUEAKQKAm0AiBjcCTAJAQRAQCS\
IEDQBBEEEBQQAoArynQCICQQIgAhsRBAAACyAEIAIpAwA3AAAgBEEIaiADKQMANwAAIAFBADYCCCAB\
QgA3AwAgAUHMAGoiAUEIaiAFNwIAIAEgBjcCACAAQRA2AgQgACAENgIAIAJBwABqJAALpwICA38Cfi\
MAQcAAayICJAAgAkEQakEMakIANwIAIAJCADcCFCACQRA2AhAgAkEoakEQaiACQRBqQRBqKAIANgIA\
IAJBKGpBCGogAkEQakEIaikDADcDACACQQhqIgMgAkEoakEMaikCADcDACACIAIpAxA3AyggAiACKQ\
IsNwMAIAEgAhBgIAFBADYCCCABQgA3AwAgAUHUAGpBACkCiJtAIgU3AgAgAUEAKQKAm0AiBjcCTAJA\
QRAQCSIEDQBBEEEBQQAoArynQCICQQIgAhsRBAAACyAEIAIpAwA3AAAgBEEIaiADKQMANwAAIAFBAD\
YCCCABQgA3AwAgAUHMAGoiAUEIaiAFNwIAIAEgBjcCACAAQRA2AgQgACAENgIAIAJBwABqJAALmgIB\
BH8jAEGQAWsiAiQAIAJB+ABqQRRqQQA2AgAgAkH4AGpBDGpCADcCACACQgA3AnwgAkEUNgJ4IAJBGG\
pBEGogAkH4AGpBEGopAwA3AwAgAkEYakEIaiACQfgAakEIaikDADcDACACQQhqIgMgAkEYakEMaikC\
ADcDACACQRBqIgQgAkEYakEUaigCADYCACACIAIpA3g3AxggAiACKQIcNwMAIAJBGGogAUHgABCXAR\
ogAkEYaiACECACQEEUEAkiBQ0AQRRBAUEAKAK8p0AiAkECIAIbEQQAAAsgBSACKQMANwAAIAVBEGog\
BCgCADYAACAFQQhqIAMpAwA3AAAgARAPIABBFDYCBCAAIAU2AgAgAkGQAWokAAuaAgEEfyMAQZABay\
ICJAAgAkH4AGpBFGpBADYCACACQfgAakEMakIANwIAIAJCADcCfCACQRQ2AnggAkEYakEQaiACQfgA\
akEQaikDADcDACACQRhqQQhqIAJB+ABqQQhqKQMANwMAIAJBCGoiAyACQRhqQQxqKQIANwMAIAJBEG\
oiBCACQRhqQRRqKAIANgIAIAIgAikDeDcDGCACIAIpAhw3AwAgAkEYaiABQeAAEJcBGiACQRhqIAIQ\
WAJAQRQQCSIFDQBBFEEBQQAoArynQCICQQIgAhsRBAAACyAFIAIpAwA3AAAgBUEQaiAEKAIANgAAIA\
VBCGogAykDADcAACABEA8gAEEUNgIEIAAgBTYCACACQZABaiQAC6QCAgR/AX4gAEEIaiECIAApAwAh\
BgJAAkACQAJAIAAoAhwiA0HAAEcNACACIABBIGoQBkEAIQMgAEEANgIcDAELIANBP0sNAQsgAEEgai\
IEIANqQYABOgAAIAAgACgCHCIFQQFqIgM2AhwCQCADQcEATw0AIABBHGogA2pBBGpBAEE/IAVrEJ0B\
GgJAQcAAIAAoAhxrQQhPDQAgAiAEEAYgACgCHCIDQcEATw0DIARBACADEJ0BGgsgAEHYAGogBkIDhj\
cDACACIAQQBiAAQQA2AhwgASAAKAIINgAAIAEgAEEMaikCADcABCABIABBFGopAgA3AAwPCyADQcAA\
QdydwAAQhAEACyADQcAAQeydwAAQhwEACyADQcAAQfydwAAQhQEAC5kCAQN/IwBBEGsiAiQAAkAgAC\
gCyAEiA0HnAEsNACAAIANqQcwBakEBOgAAAkAgA0EBaiIEQegARg0AIAAgBGpBzAFqQQBB5wAgA2sQ\
nQEaC0EAIQMgAEEANgLIASAAQbMCaiIEIAQtAABBgAFyOgAAA0AgACADaiIEIAQtAAAgBEHMAWotAA\
BzOgAAIANBAWoiA0HoAEcNAAsgABATIAEgACkAADcAACABQShqIABBKGopAAA3AAAgAUEgaiAAQSBq\
KQAANwAAIAFBGGogAEEYaikAADcAACABQRBqIABBEGopAAA3AAAgAUEIaiAAQQhqKQAANwAAIAJBEG\
okAA8LQbqfwABBFyACQQhqQdSfwABBvKHAABB/AAuZAgEDfyMAQRBrIgIkAAJAIAAoAsgBIgNB5wBL\
DQAgACADakHMAWpBBjoAAAJAIANBAWoiBEHoAEYNACAAIARqQcwBakEAQecAIANrEJ0BGgtBACEDIA\
BBADYCyAEgAEGzAmoiBCAELQAAQYABcjoAAANAIAAgA2oiBCAELQAAIARBzAFqLQAAczoAACADQQFq\
IgNB6ABHDQALIAAQEyABIAApAAA3AAAgAUEoaiAAQShqKQAANwAAIAFBIGogAEEgaikAADcAACABQR\
hqIABBGGopAAA3AAAgAUEQaiAAQRBqKQAANwAAIAFBCGogAEEIaikAADcAACACQRBqJAAPC0G6n8AA\
QRcgAkEIakHUn8AAQfyhwAAQfwALhQIBBH8CQAJAQRAgACgCACIDayIEIAJLDQAgAEEUaiEFAkAgA0\
UNACADQRFPDQIgAEEEaiIGIANqIAEgBBCXARogBSAGEA0gAiAEayECIAEgBGohAQsgAkEPcSEDIAEg\
AkFwcSICaiEEAkAgAkUNAEEAIAJrIQIDQCAFIAEQDSABQRBqIQEgAkEQaiICDQALCyAAQQRqIAQgAx\
CXARogACADNgIADwsCQAJAIAMgAmoiBSADSQ0AIAVBEEsNASAAIANqQQRqIAEgAhCXARogACAAKAIA\
IAJqNgIADwsgAyAFQbygwAAQiAEACyAFQRBBvKDAABCFAQALIANBEEHMoMAAEIQBAAukAgICfwJ+Iw\
BBkAJrIgIkACABQQhqKQMAIQQgASkDACEFIAJBiAFqQQRyIAFB1ABqEG0gAiABKAJQNgKIASACIAJB\
iAFqQYQBEJcBIQMCQEHYARAJIgINAEHYAUEIQQAoArynQCIBQQIgARsRBAAACyACIAU3AwAgAiAENw\
MIIAIgASkDEDcDECACQRhqIAFBGGopAwA3AwAgAkEgaiABQSBqKQMANwMAIAJBKGogAUEoaikDADcD\
ACACQTBqIAFBMGopAwA3AwAgAkE4aiABQThqKQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABqIA\
FByABqKQMANwMAIAJB0ABqIANBhAEQlwEaIABBuJXAADYCBCAAIAI2AgAgA0GQAmokAAukAgICfwJ+\
IwBBkAJrIgIkACABQQhqKQMAIQQgASkDACEFIAJBiAFqQQRyIAFB1ABqEG0gAiABKAJQNgKIASACIA\
JBiAFqQYQBEJcBIQMCQEHYARAJIgINAEHYAUEIQQAoArynQCIBQQIgARsRBAAACyACIAU3AwAgAiAE\
NwMIIAIgASkDEDcDECACQRhqIAFBGGopAwA3AwAgAkEgaiABQSBqKQMANwMAIAJBKGogAUEoaikDAD\
cDACACQTBqIAFBMGopAwA3AwAgAkE4aiABQThqKQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABq\
IAFByABqKQMANwMAIAJB0ABqIANBhAEQlwEaIABB3JXAADYCBCAAIAI2AgAgA0GQAmokAAuDAgEEfy\
AAIAApAwAgAq1CA4Z8NwMAAkACQEHAACAAKAIIIgNrIgQgAksNACAAQcwAaiEFAkAgA0UNACADQcEA\
Tw0CIABBDGoiBiADaiABIAQQlwEaIABBADYCCCAFIAZBARAEIAIgBGshAiABIARqIQELIAUgASACQQ\
Z2EAQgAEEMaiABIAJBQHFqIAJBP3EiAhCXARogACACNgIIDwsCQAJAIAMgAmoiBCADSQ0AIARBwABL\
DQEgAEEIaiADakEEaiABIAIQlwEaIAAgACgCCCACajYCCA8LIAMgBEG8ncAAEIgBAAsgBEHAAEG8nc\
AAEIUBAAsgA0HAAEHMncAAEIQBAAuZAgIEfwF+IABBzABqIQIgACkDACEGAkACQAJAAkAgACgCCCID\
QcAARw0AIAIgAEEMahAMQQAhAyAAQQA2AggMAQsgA0E/Sw0BCyAAQQxqIgQgA2pBgAE6AAAgACAAKA\
IIIgVBAWoiAzYCCAJAIANBwQBPDQAgAEEIaiADakEEakEAQT8gBWsQnQEaAkBBwAAgACgCCGtBCE8N\
ACACIAQQDCAAKAIIIgNBwQBPDQMgBEEAIAMQnQEaCyAAQcQAaiAGQgOGNwIAIAIgBBAMIABBADYCCC\
ABIAApAkw3AAAgASAAQdQAaikCADcACA8LIANBwABB3J3AABCEAQALIANBwABB7J3AABCHAQALIANB\
wABB/J3AABCFAQALmQICBH8BfiAAQcwAaiECIAApAwAhBgJAAkACQAJAIAAoAggiA0HAAEcNACACIA\
BBDGoQEEEAIQMgAEEANgIIDAELIANBP0sNAQsgAEEMaiIEIANqQYABOgAAIAAgACgCCCIFQQFqIgM2\
AggCQCADQcEATw0AIABBCGogA2pBBGpBAEE/IAVrEJ0BGgJAQcAAIAAoAghrQQhPDQAgAiAEEBAgAC\
gCCCIDQcEATw0DIARBACADEJ0BGgsgAEHEAGogBkIDhjcCACACIAQQECAAQQA2AgggASAAKQJMNwAA\
IAEgAEHUAGopAgA3AAgPCyADQcAAQdydwAAQhAEACyADQcAAQeydwAAQhwEACyADQcAAQfydwAAQhQ\
EAC5ECAQN/IwBBgAFrIgIkACACQRhqIAFB1AAQlwEaAkACQCACKAIYIgNBEE8NACACQRhqQQRyIgQg\
A2pBECADayIDIAMQnQEaIAJBADYCGCACQSxqIgMgBBANIAJB8ABqQQhqIAJB5ABqKQIANwMAIAIgAk\
HcAGopAgA3A3AgAyACQfAAahANIAJBCGpBCGoiBCACQTRqKQIANwMAIAIgAikCLDcDCEEQEAkiA0UN\
ASADIAIpAwg3AAAgA0EIaiAEKQMANwAAIAEQDyAAQRA2AgQgACADNgIAIAJBgAFqJAAPC0G6n8AAQR\
cgAkHwAGpB4JrAAEHwmsAAEH8AC0EQQQFBACgCvKdAIgJBAiACGxEEAAAL/wEBBH8gACAAKQMAIAKt\
fDcDAAJAAkBBwAAgACgCHCIDayIEIAJLDQAgAEEIaiEFAkAgA0UNACADQcEATw0CIABBIGoiBiADai\
ABIAQQlwEaIABBADYCHCAFIAZBARAIIAIgBGshAiABIARqIQELIAUgASACQQZ2EAggAEEgaiABIAJB\
QHFqIAJBP3EiAhCXARogACACNgIcDwsCQAJAIAMgAmoiBCADSQ0AIARBwABLDQEgAEEcaiADakEEai\
ABIAIQlwEaIAAgACgCHCACajYCHA8LIAMgBEG8ncAAEIgBAAsgBEHAAEG8ncAAEIUBAAsgA0HAAEHM\
ncAAEIQBAAvuAQEFfyMAQcAAayICJAAgAkEANgIQIAJBCGogAkEQakEEciACQSRqEKgBIAIoAhAhAw\
JAIAIoAgwgAigCCCIEayIFQRAgBUEQSRsiBkUNACAGIQUDQCAEIAEtAAA6AAAgBEEBaiEEIAFBAWoh\
ASAFQX9qIgUNAAsgAiADIAZqIgM2AhALAkAgA0EPSw0AIANBEBCJAQALIAJBKGpBCGogAkEQakEIai\
kDADcDACACQShqQRBqIAJBEGpBEGooAgA2AgAgAiACKQMQNwMoIAAgAikCLDcAACAAQQhqIAJBNGop\
AgA3AAAgAkHAAGokAAv5AQEDfyMAQRBrIgIkAAJAIAAoAsgBIgNBjwFLDQAgACADakHMAWpBAToAAA\
JAIANBAWoiBEGQAUYNACAAIARqQcwBakEAQY8BIANrEJ0BGgtBACEDIABBADYCyAEgAEHbAmoiBCAE\
LQAAQYABcjoAAANAIAAgA2oiBCAELQAAIARBzAFqLQAAczoAACADQQFqIgNBkAFHDQALIAAQEyABIA\
ApAAA3AAAgAUEYaiAAQRhqKAAANgAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgAkEQ\
aiQADwtBup/AAEEXIAJBCGpB1J/AAEHkn8AAEH8AC/kBAQN/IwBBEGsiAiQAAkAgACgCyAEiA0GHAU\
sNACAAIANqQcwBakEBOgAAAkAgA0EBaiIEQYgBRg0AIAAgBGpBzAFqQQBBhwEgA2sQnQEaC0EAIQMg\
AEEANgLIASAAQdMCaiIEIAQtAABBgAFyOgAAA0AgACADaiIEIAQtAAAgBEHMAWotAABzOgAAIANBAW\
oiA0GIAUcNAAsgABATIAEgACkAADcAACABQRhqIABBGGopAAA3AAAgAUEQaiAAQRBqKQAANwAAIAFB\
CGogAEEIaikAADcAACACQRBqJAAPC0G6n8AAQRcgAkEIakHUn8AAQayhwAAQfwAL+QEBA38jAEEQay\
ICJAACQCAAKALIASIDQYcBSw0AIAAgA2pBzAFqQQY6AAACQCADQQFqIgRBiAFGDQAgACAEakHMAWpB\
AEGHASADaxCdARoLQQAhAyAAQQA2AsgBIABB0wJqIgQgBC0AAEGAAXI6AAADQCAAIANqIgQgBC0AAC\
AEQcwBai0AAHM6AAAgA0EBaiIDQYgBRw0ACyAAEBMgASAAKQAANwAAIAFBGGogAEEYaikAADcAACAB\
QRBqIABBEGopAAA3AAAgAUEIaiAAQQhqKQAANwAAIAJBEGokAA8LQbqfwABBFyACQQhqQdSfwABB7K\
HAABB/AAv5AQEDfyMAQRBrIgIkAAJAIAAoAsgBIgNBjwFLDQAgACADakHMAWpBBjoAAAJAIANBAWoi\
BEGQAUYNACAAIARqQcwBakEAQY8BIANrEJ0BGgtBACEDIABBADYCyAEgAEHbAmoiBCAELQAAQYABcj\
oAAANAIAAgA2oiBCAELQAAIARBzAFqLQAAczoAACADQQFqIgNBkAFHDQALIAAQEyABIAApAAA3AAAg\
AUEYaiAAQRhqKAAANgAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgAkEQaiQADwtBup\
/AAEEXIAJBCGpB1J/AAEHcocAAEH8AC/ABAQN/IwBBkAFrIgIkACACQfgAakEMakIANwIAIAJCADcC\
fCACQRA2AnggAkEYakEQaiACQfgAakEQaigCADYCACACQRhqQQhqIAJB+ABqQQhqKQMANwMAIAJBCG\
pBCGoiAyACQRhqQQxqKQIANwMAIAIgAikDeDcDGCACIAIpAhw3AwggAkEYaiABQeAAEJcBGiACQRhq\
IAJBCGoQXwJAQRAQCSIEDQBBEEEBQQAoArynQCICQQIgAhsRBAAACyAEIAIpAwg3AAAgBEEIaiADKQ\
MANwAAIAEQDyAAQRA2AgQgACAENgIAIAJBkAFqJAAL8AEBA38jAEGQAWsiAiQAIAJB+ABqQQxqQgA3\
AgAgAkIANwJ8IAJBEDYCeCACQRhqQRBqIAJB+ABqQRBqKAIANgIAIAJBGGpBCGogAkH4AGpBCGopAw\
A3AwAgAkEIakEIaiIDIAJBGGpBDGopAgA3AwAgAiACKQN4NwMYIAIgAikCHDcDCCACQRhqIAFB4AAQ\
lwEaIAJBGGogAkEIahBgAkBBEBAJIgQNAEEQQQFBACgCvKdAIgJBAiACGxEEAAALIAQgAikDCDcAAC\
AEQQhqIAMpAwA3AAAgARAPIABBEDYCBCAAIAQ2AgAgAkGQAWokAAvxAQIDfwF+IwBBsAFrIgIkACAC\
QdAAakEIaiIDIAFBEGopAwA3AwAgAkHQAGpBEGoiBCABQRhqKAIANgIAIAIgASkDCDcDUCABKQMAIQ\
UgAkHoAGpBBHIgAUEgahBMIAIgASgCHDYCaCACQQhqIAJB6ABqQcQAEJcBGgJAQeAAEAkiAQ0AQeAA\
QQhBACgCvKdAIgJBAiACGxEEAAALIAEgBTcDACABIAIpA1A3AwggAUEQaiADKQMANwMAIAFBGGogBC\
gCADYCACABQRxqIAJBCGpBxAAQlwEaIABBqJTAADYCBCAAIAE2AgAgAkGwAWokAAvxAQIDfwF+IwBB\
sAFrIgIkACACQdAAakEIaiIDIAFBEGopAwA3AwAgAkHQAGpBEGoiBCABQRhqKAIANgIAIAIgASkDCD\
cDUCABKQMAIQUgAkHoAGpBBHIgAUEgahBMIAIgASgCHDYCaCACQQhqIAJB6ABqQcQAEJcBGgJAQeAA\
EAkiAQ0AQeAAQQhBACgCvKdAIgJBAiACGxEEAAALIAEgBTcDACABIAIpA1A3AwggAUEQaiADKQMANw\
MAIAFBGGogBCgCADYCACABQRxqIAJBCGpBxAAQlwEaIABBzJTAADYCBCAAIAE2AgAgAkGwAWokAAvF\
AQECfyMAQSBrIgMkAAJAIAEgAmoiAiABSQ0AIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEIIAJBCE\
sbIQICQAJAIAFFDQAgA0EQakEIakEBNgIAIAMgATYCFCADIAAoAgA2AhAMAQsgA0EANgIQCyADIAIg\
A0EQahB2AkAgAygCAEEBRw0AIANBCGooAgAiAEUNASADKAIEIABBACgCvKdAIgNBAiADGxEEAAALIA\
AgAykCBDcCACADQSBqJAAPCxCqAQALxwEBBX8jAEGgAmsiAiQAIAJBADYCECACQQhqIAJBEGpBBHIg\
AkGUAWoQqAEgAigCECEDAkAgAigCDCACKAIIIgRrIgVBgAEgBUGAAUkbIgZFDQAgBiEFA0AgBCABLQ\
AAOgAAIARBAWohBCABQQFqIQEgBUF/aiIFDQALIAIgAyAGaiIDNgIQCwJAIANB/wBLDQAgA0GAARCJ\
AQALIAJBmAFqIAJBEGpBhAEQlwEaIAAgAkGYAWpBBHJBgAEQlwEaIAJBoAJqJAALxwEBBX8jAEGwAW\
siAiQAIAJBADYCECACQQhqIAJBEGpBBHIgAkHcAGoQqAEgAigCECEDAkAgAigCDCACKAIIIgRrIgVB\
yAAgBUHIAEkbIgZFDQAgBiEFA0AgBCABLQAAOgAAIARBAWohBCABQQFqIQEgBUF/aiIFDQALIAIgAy\
AGaiIDNgIQCwJAIANBxwBLDQAgA0HIABCJAQALIAJB4ABqIAJBEGpBzAAQlwEaIAAgAkHgAGpBBHJB\
yAAQlwEaIAJBsAFqJAALxwEBBX8jAEGwAmsiAiQAIAJBADYCECACQQhqIAJBEGpBBHIgAkGcAWoQqA\
EgAigCECEDAkAgAigCDCACKAIIIgRrIgVBiAEgBUGIAUkbIgZFDQAgBiEFA0AgBCABLQAAOgAAIARB\
AWohBCABQQFqIQEgBUF/aiIFDQALIAIgAyAGaiIDNgIQCwJAIANBhwFLDQAgA0GIARCJAQALIAJBoA\
FqIAJBEGpBjAEQlwEaIAAgAkGgAWpBBHJBiAEQlwEaIAJBsAJqJAALxwEBBX8jAEHAAmsiAiQAIAJB\
ADYCECACQQhqIAJBEGpBBHIgAkGkAWoQqAEgAigCECEDAkAgAigCDCACKAIIIgRrIgVBkAEgBUGQAU\
kbIgZFDQAgBiEFA0AgBCABLQAAOgAAIARBAWohBCABQQFqIQEgBUF/aiIFDQALIAIgAyAGaiIDNgIQ\
CwJAIANBjwFLDQAgA0GQARCJAQALIAJBqAFqIAJBEGpBlAEQlwEaIAAgAkGoAWpBBHJBkAEQlwEaIA\
JBwAJqJAALxwEBBX8jAEHwAWsiAiQAIAJBADYCECACQQhqIAJBEGpBBHIgAkH8AGoQqAEgAigCECED\
AkAgAigCDCACKAIIIgRrIgVB6AAgBUHoAEkbIgZFDQAgBiEFA0AgBCABLQAAOgAAIARBAWohBCABQQ\
FqIQEgBUF/aiIFDQALIAIgAyAGaiIDNgIQCwJAIANB5wBLDQAgA0HoABCJAQALIAJBgAFqIAJBEGpB\
7AAQlwEaIAAgAkGAAWpBBHJB6AAQlwEaIAJB8AFqJAAL0gECAn8BfiMAQZABayICJAAgASkDACEEIA\
JByABqQQRyIAFBDGoQTCACIAEoAgg2AkggAiACQcgAakHEABCXASEDAkBB8AAQCSICDQBB8ABBCEEA\
KAK8p0AiAUECIAEbEQQAAAsgAiAENwMAIAJBCGogA0HEABCXARogAkHkAGogAUHkAGopAgA3AgAgAk\
HcAGogAUHcAGopAgA3AgAgAkHUAGogAUHUAGopAgA3AgAgAiABKQJMNwJMIABB9JLAADYCBCAAIAI2\
AgAgA0GQAWokAAvSAQICfwF+IwBBkAFrIgIkACABKQMAIQQgAkHIAGpBBHIgAUEMahBMIAIgASgCCD\
YCSCACIAJByABqQcQAEJcBIQMCQEHwABAJIgINAEHwAEEIQQAoArynQCIBQQIgARsRBAAACyACIAQ3\
AwAgAkEIaiADQcQAEJcBGiACQeQAaiABQeQAaikCADcCACACQdwAaiABQdwAaikCADcCACACQdQAai\
ABQdQAaikCADcCACACIAEpAkw3AkwgAEGYk8AANgIEIAAgAjYCACADQZABaiQAC64BAgJ/AX4jAEGQ\
AWsiAiQAIAEpAwAhBCACQcgAakEEciABQQxqEEwgAiABKAIINgJIIAIgAkHIAGpBxAAQlwEhAwJAQe\
AAEAkiAg0AQeAAQQhBACgCvKdAIgFBAiABGxEEAAALIAIgBDcDACACQQhqIANBxAAQlwEaIAJB1ABq\
IAFB1ABqKQIANwIAIAIgASkCTDcCTCAAQbyTwAA2AgQgACACNgIAIANBkAFqJAALrgECAn8BfiMAQZ\
ABayICJAAgASkDACEEIAJByABqQQRyIAFBDGoQTCACIAEoAgg2AkggAiACQcgAakHEABCXASEDAkBB\
4AAQCSICDQBB4ABBCEEAKAK8p0AiAUECIAEbEQQAAAsgAiAENwMAIAJBCGogA0HEABCXARogAkHUAG\
ogAUHUAGopAgA3AgAgAiABKQJMNwJMIABBhJTAADYCBCAAIAI2AgAgA0GQAWokAAuYAQEBf0EAIQMC\
QAJAIAFBAEgNAAJAAkACQAJAAkAgAigCACIDRQ0AAkAgAigCBA0AIAENAgwECyADIAEQFSECDAILIA\
FFDQILIAEQCSECCwJAIAJFDQAgASEDDAILIAAgATYCBEEBIQMMAgtBASECQQAhAwsgACACNgIEQQAh\
AQwBC0EBIQELIAAgATYCACAAQQhqIAM2AgALmgEBAX8jAEGwA2siAiQAIAJBCGogAUHIARCXARogAk\
HAAmpBBHIgAUHMAWoQcSACIAEoAsgBNgLAAiACQQhqQcgBaiACQcACakHsABCXARoCQEG4AhAJIgEN\
AEG4AkEIQQAoArynQCICQQIgAhsRBAAACyABIAJBCGpBuAIQlwEhASAAQdSQwAA2AgQgACABNgIAIA\
JBsANqJAALmgEBAX8jAEHwA2siAiQAIAJBCGogAUHIARCXARogAkHgAmpBBHIgAUHMAWoQbyACIAEo\
AsgBNgLgAiACQQhqQcgBaiACQeACakGMARCXARoCQEHYAhAJIgENAEHYAkEIQQAoArynQCICQQIgAh\
sRBAAACyABIAJBCGpB2AIQlwEhASAAQfiQwAA2AgQgACABNgIAIAJB8ANqJAALmgEBAX8jAEHwAmsi\
AiQAIAJBCGogAUHIARCXARogAkGgAmpBBHIgAUHMAWoQbiACIAEoAsgBNgKgAiACQQhqQcgBaiACQa\
ACakHMABCXARoCQEGYAhAJIgENAEGYAkEIQQAoArynQCICQQIgAhsRBAAACyABIAJBCGpBmAIQlwEh\
ASAAQZyRwAA2AgQgACABNgIAIAJB8AJqJAALmgEBAX8jAEGABGsiAiQAIAJBCGogAUHIARCXARogAk\
HoAmpBBHIgAUHMAWoQcCACIAEoAsgBNgLoAiACQQhqQcgBaiACQegCakGUARCXARoCQEHgAhAJIgEN\
AEHgAkEIQQAoArynQCICQQIgAhsRBAAACyABIAJBCGpB4AIQlwEhASAAQcCRwAA2AgQgACABNgIAIA\
JBgARqJAALmgEBAX8jAEGwA2siAiQAIAJBCGogAUHIARCXARogAkHAAmpBBHIgAUHMAWoQcSACIAEo\
AsgBNgLAAiACQQhqQcgBaiACQcACakHsABCXARoCQEG4AhAJIgENAEG4AkEIQQAoArynQCICQQIgAh\
sRBAAACyABIAJBCGpBuAIQlwEhASAAQeSRwAA2AgQgACABNgIAIAJBsANqJAALmgEBAX8jAEGABGsi\
AiQAIAJBCGogAUHIARCXARogAkHoAmpBBHIgAUHMAWoQcCACIAEoAsgBNgLoAiACQQhqQcgBaiACQe\
gCakGUARCXARoCQEHgAhAJIgENAEHgAkEIQQAoArynQCICQQIgAhsRBAAACyABIAJBCGpB4AIQlwEh\
ASAAQYiSwAA2AgQgACABNgIAIAJBgARqJAALmgEBAX8jAEHwA2siAiQAIAJBCGogAUHIARCXARogAk\
HgAmpBBHIgAUHMAWoQbyACIAEoAsgBNgLgAiACQQhqQcgBaiACQeACakGMARCXARoCQEHYAhAJIgEN\
AEHYAkEIQQAoArynQCICQQIgAhsRBAAACyABIAJBCGpB2AIQlwEhASAAQaySwAA2AgQgACABNgIAIA\
JB8ANqJAALmgEBAX8jAEHwAmsiAiQAIAJBCGogAUHIARCXARogAkGgAmpBBHIgAUHMAWoQbiACIAEo\
AsgBNgKgAiACQQhqQcgBaiACQaACakHMABCXARoCQEGYAhAJIgENAEGYAkEIQQAoArynQCICQQIgAh\
sRBAAACyABIAJBCGpBmAIQlwEhASAAQdCSwAA2AgQgACABNgIAIAJB8AJqJAALfwEBfyMAQcAAayIF\
JAAgBSABNgIMIAUgADYCCCAFIAM2AhQgBSACNgIQIAVBLGpBAjYCACAFQTxqQQQ2AgAgBUICNwIcIA\
VB4I/AADYCGCAFQQE2AjQgBSAFQTBqNgIoIAUgBUEQajYCOCAFIAVBCGo2AjAgBUEYaiAEEJsBAAt+\
AQJ/IwBBMGsiAiQAIAJBFGpBATYCACACQfSLwAA2AhAgAkEBNgIMIAJB7IvAADYCCCABQRxqKAIAIQ\
MgASgCGCEBIAJBLGpBAjYCACACQgI3AhwgAkHgj8AANgIYIAIgAkEIajYCKCABIAMgAkEYahAbIQEg\
AkEwaiQAIAELfgECfyMAQTBrIgIkACACQRRqQQE2AgAgAkH0i8AANgIQIAJBATYCDCACQeyLwAA2Ag\
ggAUEcaigCACEDIAEoAhghASACQSxqQQI2AgAgAkICNwIcIAJB4I/AADYCGCACIAJBCGo2AiggASAD\
IAJBGGoQGyEBIAJBMGokACABC44BACAAQgA3AwggAEIANwMAIABBADYCUCAAQQApA9CcQDcDECAAQR\
hqQQApA9icQDcDACAAQSBqQQApA+CcQDcDACAAQShqQQApA+icQDcDACAAQTBqQQApA/CcQDcDACAA\
QThqQQApA/icQDcDACAAQcAAakEAKQOAnUA3AwAgAEHIAGpBACkDiJ1ANwMAC44BACAAQgA3AwggAE\
IANwMAIABBADYCUCAAQQApA5CcQDcDECAAQRhqQQApA5icQDcDACAAQSBqQQApA6CcQDcDACAAQShq\
QQApA6icQDcDACAAQTBqQQApA7CcQDcDACAAQThqQQApA7icQDcDACAAQcAAakEAKQPAnEA3AwAgAE\
HIAGpBACkDyJxANwMAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEF\
NgIAIANCAjcCDCADQYiPwAA2AgggA0EFNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCG\
ogAhCbAQALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQU2AgAgA0IC\
NwIMIANBxI7AADYCCCADQQU2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEJsBAA\
ttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBBTYCACADQgM3AgwgA0H0\
j8AANgIIIANBBTYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQmwEAC20BAX8jAE\
EwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEFNgIAIANCAjcCDCADQaiMwAA2Aggg\
A0EFNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhCbAQALbQEBfyMAQTBrIgMkAC\
ADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQU2AgAgA0ICNwIMIANBrI/AADYCCCADQQU2AiQg\
AyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEJsBAAtwAQF/IwBBMGsiAiQAIAIgATYCBC\
ACIAA2AgAgAkEcakECNgIAIAJBLGpBBTYCACACQgI3AgwgAkGAlsAANgIIIAJBBTYCJCACIAJBIGo2\
AhggAiACQQRqNgIoIAIgAjYCICACQQhqQZCWwAAQmwEAC2wAIABCADcDACAAIAApA3A3AwggAEEgai\
AAQYgBaikDADcDACAAQRhqIABBgAFqKQMANwMAIABBEGogAEH4AGopAwA3AwAgAEEoakEAQcIAEJ0B\
GgJAIABB8A5qIgAtAABFDQAgAEEAOgAACwt2AQJ/QQEhAEEAQQAoAuijQCIBQQFqNgLoo0ACQAJAQQ\
AoArCnQEEBRw0AQQAoArSnQEEBaiEADAELQQBBATYCsKdAC0EAIAA2ArSnQAJAIAFBAEgNACAAQQJL\
DQBBACgCuKdAQX9MDQAgAEEBSw0AEMQBAAsAC2MBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBCGpBEG\
ogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBjIfAACACQQhqEBsh\
ASACQSBqJAAgAQtlAgF/AX4jAEEQayICJAACQAJAIAFFDQAgASgCAA0BIAFBfzYCACACQQhqIAEoAg\
QgAUEIaigCACgCEBEEACACKQMIIQMgAUEANgIAIAAgAzcDACACQRBqJAAPCxCxAQALELIBAAtRAQJ/\
AkAgACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACTw0AIAMgACACEGwgBCgCACEACyADKAIAIABqIA\
EgAhCXARogBCAAIAJqNgIAQQALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABB\
AWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLUQECfwJAAkAgAEUNACAAKAIADQEgAE\
EANgIAIAAoAgQhASAAKAIIIQIgABAPIAEgAigCABEBAAJAIAIoAgRFDQAgARAPCw8LELEBAAsQsgEA\
C04AAkACQCAARQ0AIAAoAgANASAAQX82AgAgACgCBCABIAIgAEEIaigCACgCDBEGAAJAIAJFDQAgAR\
APCyAAQQA2AgAPCxCxAQALELIBAAtUAQF/AkACQAJAIAFBgIDEAEYNAEEBIQQgACgCGCABIABBHGoo\
AgAoAhARBQANAQsgAg0BQQAhBAsgBA8LIAAoAhggAiADIABBHGooAgAoAgwRBwALWAAgAEIANwMAIA\
BBADYCMCAAQQApA5CbQDcDCCAAQRBqQQApA5ibQDcDACAAQRhqQQApA6CbQDcDACAAQSBqQQApA6ib\
QDcDACAAQShqQQApA7CbQDcDAAtIAQF/IwBBIGsiAyQAIANBFGpBADYCACADQZyiwAA2AhAgA0IBNw\
IEIAMgATYCHCADIAA2AhggAyADQRhqNgIAIAMgAhCbAQALTAAgAEEANgIIIABCADcDACAAQQApA/Cb\
QDcCTCAAQdQAakEAKQP4m0A3AgAgAEHcAGpBACkDgJxANwIAIABB5ABqQQApA4icQDcCAAtMACAAQQ\
A2AgggAEIANwMAIABBACkCzJtANwJMIABB1ABqQQApAtSbQDcCACAAQdwAakEAKQLcm0A3AgAgAEHk\
AGpBACkC5JtANwIACzYBAX8CQCACRQ0AIAAhAwNAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIAJBf2\
oiAg0ACwsgAAs5AQN/IwBBEGsiASQAIAAoAgwhAiAAKAIIEKUBIQMgASACNgIIIAEgADYCBCABIAM2\
AgAgARCcAQALOgAgAEEANgIcIABCADcDACAAQRhqQQAoAsibQDYCACAAQRBqQQApA8CbQDcDACAAQQ\
ApA7ibQDcDCAs6ACAAQgA3AwAgAEEANgIcIABBACkDuJtANwMIIABBEGpBACkDwJtANwMAIABBGGpB\
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\
aWIucnMAAAAgBBAASQAAAAsCAAAKAAAAIAQQAEkAAAA5AgAACQAAACAEEABJAAAArgIAABkAAAAgBB\
AASQAAALACAAAJAAAAIAQQAEkAAACwAgAAOAAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxm\
LmxlbigpABwPEABNAAAA4wUAAAkAAAAgBBAASQAAAIMCAAAJAAAAIAQQAEkAAACKAgAACgAAACAEEA\
BJAAAAmgMAADIAAAAgBBAASQAAAFUEAAAWAAAAIAQQAEkAAABnBAAAFgAAACAEEABJAAAAmAQAABIA\
AAAgBBAASQAAAKIEAAASAAAABgAAAAQAAAAEAAAAbQAAAIAFEABLAAAAzQAAACAAAAB+Ly5jYXJnby\
9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2FycmF5dmVjLTAuNS4yL3Ny\
Yy9saWIucnMABgAAACAAAAABAAAAbgAAAAYAAAAEAAAABAAAAG0AAAARBhAADQAAAPwFEAAVAAAAaW\
5zdWZmaWNpZW50IGNhcGFjaXR5Q2FwYWNpdHlFcnJvclBhZEVycm9yAABIBhAAIAAAAGgGEAASAAAA\
BgAAAAAAAAABAAAAbwAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW\
5kZXggaXMgMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQy\
NTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNT\
Q1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4Mjgz\
ODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAFQHEAAQAAAAZAcQACIAAAByYW5nZSBlbm\
QgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIAAAmAcQABIAAABkBxAAIgAA\
AHJhbmdlIHN0YXJ0IGluZGV4IAAAvAcQABYAAADSBxAADQAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdC\
AgYnV0IGVuZHMgYXQgABwREAAAAAAA8AcQAAIAAAA6ICkADAgQABUAAAAhCBAAKwAAAPIHEAABAAAA\
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\
L3NsaWNlL21vZC5yc34vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZW\
M4MjMvZ2VuZXJpYy1hcnJheS0wLjE0LjQvc3JjL2xpYi5yc3dlIG5ldmVyIHVzZSBpbnB1dF9sYXp5\
AAAABgAAAAAAAAABAAAAcAAAAPQPEABHAAAAQQAAAAEAAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2\
l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NoYTMtMC45LjEvc3JjL2xpYi5ycwBcEBAATwAAABsA\
AAANAAAAXBAQAE8AAAAiAAAADQAAAH4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2\
M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuOS4wL3NyYy9saWIucnMA9A8QAEcAAABIAAAAAQAA\
APQPEABHAAAATwAAAAEAAAD0DxAARwAAAFYAAAABAAAA9A8QAEcAAABmAAAAAQAAAPQPEABHAAAAbQ\
AAAAEAAAD0DxAARwAAAHQAAAABAAAA9A8QAEcAAAB7AAAAAQAAAGNhbGxlZCBgT3B0aW9uOjp1bndy\
YXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAWBEQABwAAAACAgAAHgAAAGxpYnJhcnkvc3RkL3NyYy9wYW\
5pY2tpbmcucnMEAAAAAAAAAG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ug\
b2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIG\
luIHJ1c3QAp+WAgAAEbmFtZQGc5YCAAMcBADZ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fc3RyaW5n\
X25ldzo6aDk1MTJkZTNiOWQ2NWIxNTgBMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aD\
FhNWVkZDZmZGYyMDYzNTkCM3dhc21fYmluZGdlbjo6X193YmluZGdlbl9yZXRocm93OjpoNTlmYWI0\
ZjY4MTEwNzZjMAMvc2hhMjo6c2hhNTEyOjpzb2Z0Ojpjb21wcmVzczo6aDUzOWRiOTRlNDcyMjc2NW\
MEL3NoYTI6OnNoYTI1Njo6c29mdDo6Y29tcHJlc3M6OmgwNWRhNDk4NTljYjY4Mzk4BTZyaXBlbWQz\
MjA6OmJsb2NrOjpwcm9jZXNzX21zZ19ibG9jazo6aGZmOWRjNjlmZmVmNzc0OGYGNnJpcGVtZDE2MD\
o6YmxvY2s6OnByb2Nlc3NfbXNnX2Jsb2NrOjpoZTc3ZDhjNTkzYWQ2YzBhNQcLY3JlYXRlX2hhc2gI\
K3NoYTE6OmNvbXByZXNzOjpjb21wcmVzczo6aGRhOWE5ZTQ5MzA4YzVhYzMJOmRsbWFsbG9jOjpkbG\
1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aDQ3Nzk3YTUxNjJmOWYwNjcKNmJsYWtlMzo6cG9y\
dGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoNjM1OTAzMGE5YjcxZGU0Ngs/PEQgYXMgZGlnZXN0Oj\
pkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6OmgyMGQ2ZGRkNjI1ZTU1OGM4DCdtZDU6OnV0\
aWxzOjpjb21wcmVzczo6aDhkMTI1ZDk1OWI3MTU5OTkNL21kMjo6TWQyU3RhdGU6OnByb2Nlc3NfYm\
xvY2s6OmhkODQxNTk3NWZjODg2MzNlDjBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aGJl\
MmRlNjg2ZmFhNWI2MDcPOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhlMW\
IwZmJjYTNmZmQ0YjExEC9tZDQ6Ok1kNFN0YXRlOjpwcm9jZXNzX2Jsb2NrOjpoY2ViZGM4YjA0ODA0\
OGI3YhFBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZGlzcG9zZV9jaHVuazo6aGI0OD\
hiZGM5ZTE0MDNiNWQSK2JsYWtlMzo6SGFzaGVyOjpmaW5hbGl6ZTo6aDU2NGRjYTRkYmIzODkzNTET\
IGtlY2Nhazo6ZjE2MDA6Omg0NzcxYjVhZGMxODA0YmFkFCxjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cG\
FkOjpoOTdkZjJiY2Y2YzIzNDBiMBUOX19ydXN0X3JlYWxsb2MWYTxzaGEyOjpzaGE1MTI6OlNoYTUx\
MiBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eT\
o6aGYwOTMwYzY2MDQ0NjFlZGMXMWJsYWtlMzo6SGFzaGVyOjptZXJnZV9jdl9zdGFjazo6aDU0YjNm\
ZDJjNTcyZTdmN2MYRzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpem\
VfcmVzZXQ6OmgwMTA1YzMyNjNkMDkyYWY3GUc8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRp\
Z2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoZWUxMDdiMDYwZmVmZGE3MhpHPEQgYXMgZGlnZXN0OjpkeW\
5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aDdhNTBiZDZhMzEzZWJmNDkbI2Nv\
cmU6OmZtdDo6d3JpdGU6OmhlNGIyY2QxOWQxMjFhMzk5HDVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cG\
FkX2ludGVncmFsOjpoOTNkNDQxMTdlMGQwMzU3Mh1hPHNoYTI6OnNoYTUxMjo6U2hhMzg0IGFzIGRp\
Z2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoMTU0Mj\
lmNDMwYzYwMmZlNx5CPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xv\
bmU6OmhhZjU4YTZlZDY5ZjA5MmUwH0c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD\
46OmZpbmFsaXplX3Jlc2V0OjpoY2VjYjI0YWIzMjUwYzU5MCBXPHNoYTE6OlNoYTEgYXMgZGlnZXN0\
OjpmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6OmhiOGU4NzczNj\
A0NjljMDQ3ITRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFyYWxsZWw6Omg4NDQ3MzE4NWFkN2M4\
Zjk2Ikc8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0Oj\
poYzhiNjVhZmRjOTE3ZWE2MCNBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpm\
aW5hbGl6ZTo6aGFmZWZiYTJmMjQzOWY5YjQkQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRG\
lnZXN0Pjo6ZmluYWxpemU6OmhiOGI4ZDAwMjRiYzk1NzFmJUE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdl\
c3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoMWU4YzgwNTI5ZmQ3YzM1MiZHPEQgYXMgZGlnZXN0Oj\
pkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aDU3MzYyZWEwODNkYTlkNjIn\
RzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6OmhmY2\
FlMzNmNWU3MWJhNGI2KEE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFs\
aXplOjpoNjk0MDY5N2ViMWU4NWM0NSlBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3\
Q+OjpmaW5hbGl6ZTo6aGZiMWY1ZjIwMGE3YmEwOGUqQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6\
RHluRGlnZXN0Pjo6ZmluYWxpemU6OmgyN2NhYWI3NGE2NzZlNzUzK0c8RCBhcyBkaWdlc3Q6OmR5bl\
9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoMjc3ZWVlYmQ3OWQwMjkzZSxHPEQg\
YXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aGEwZmMwMW\
Q5Zjc0OTNkYjEtRzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVf\
cmVzZXQ6OmgzM2Y3ODMxYjgzOTc4MTdkLmE8c2hhMjo6c2hhMjU2OjpTaGEyNTYgYXMgZGlnZXN0Oj\
pmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6OmhkZDIxZjc3MjM0\
ODk1NmI4L0c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2\
V0OjpoMzhlM2Y5NzU3N2Q3NTQzZjBBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+\
OjpmaW5hbGl6ZTo6aDc3MTE3ODRjNjNmODhlODUxMnNoYTI6OnNoYTUxMjo6RW5naW5lNTEyOjpmaW\
5pc2g6Omg3MWIwMTI3Y2NmYmJkMDY0MkE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2Vz\
dD46OmZpbmFsaXplOjpoYjkwZDlmYTgwZjBmMTkxMzNBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0Oj\
pEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aGI0N2FjMDIyNjRjNGU5MTQ0QTxEIGFzIGRpZ2VzdDo6ZHlu\
X2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmhmZDZiNDRhZGRiN2VmMGE1NUE8RCBhcyBkaW\
dlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoNWFkOTUzYTFmOGFlMGNmNjZH\
PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aGI0MT\
g5NmY5NzA5YTVmNGY3RzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxp\
emVfcmVzZXQ6OmhiNzgxOGI0NDM0OWJkNzRkOEI8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bk\
RpZ2VzdD46OmJveF9jbG9uZTo6aGU4OGZiY2Q3MmU2YjZiY2Q5LWJsYWtlMzo6Q2h1bmtTdGF0ZTo6\
dXBkYXRlOjpoZmE4NjhkYjJhNzg0YmE1ZDo7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3\
JpdGVfY2hhcjo6aDE2NjQzMWY5ZGM3OTAzNDY7RzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHlu\
RGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6OmhhM2M4MmVmMWRlNzlkOTIzPEc8RCBhcyBkaWdlc3Q6Om\
R5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoZGRjNjI1NzI2YzY0Nzg2OT1h\
PHNoYTI6OnNoYTI1Njo6U2hhMjI0IGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+Oj\
pmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoNDljYmQ1ODA2NDhjMGRiMT4/PEQgYXMgZGlnZXN0OjpkeW5f\
ZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6OmgwMDMxNWM4OTE4OThmZTRlPz88RCBhcyBkaWdlc3\
Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aDA1ZmJkMzM0YTJlNzhmZTlAPzxEIGFz\
IGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6dXBkYXRlOjpoNTg0NDRkN2I5YzMzYjIzYk\
E/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6Omg3Yzg4MmU2MzM2\
ZDc2OWUyQkE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoYj\
VlN2MxODVhZTQ4NmM5MENBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5h\
bGl6ZTo6aGY2MTlhNzljODJkODAyMDREQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZX\
N0Pjo6ZmluYWxpemU6Omg0OGRhMzkwMjY5ZWRmYWU4RUc8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6\
OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoNWFmZjIyMTc4MmU1NTY1NUZHPEQgYXMgZGlnZX\
N0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aGM5ZDhkZTc1MjVmODMy\
YmVHL2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6Omg3MWU2MjRjMmQzOWI3NzFlSDJzaGEyOj\
pzaGEyNTY6OkVuZ2luZTI1Njo6ZmluaXNoOjpoZGI4ZGU2N2Q2MmExZmQzN0lhPHJpcGVtZDMyMDo6\
UmlwZW1kMzIwIGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbn\
RvX2RpcnR5OjpoYWEzM2ZiNTE5NGIwNmJkNUpbPHNoYTM6OlNoYTNfNTEyIGFzIGRpZ2VzdDo6Zml4\
ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoMjEzODY2NmM4Y2UzZD\
IyZktcPHNoYTM6OktlY2NhazUxMiBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6\
ZmluYWxpemVfaW50b19kaXJ0eTo6aGZmNDc3MWJhY2I4ZWRhNTJMbmdlbmVyaWNfYXJyYXk6OmltcG\
xzOjo8aW1wbCBjb3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6OkdlbmVyaWNBcnJh\
eTxULE4+Pjo6Y2xvbmU6OmhiY2MzNzAzOGUyMDU0ZTZjTT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3\
Q6OkR5bkRpZ2VzdD46OnJlc2V0OjpoZjlmNWVkZGIyOTQzOGRiOU5CPEQgYXMgZGlnZXN0OjpkeW5f\
ZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6Omg5ZDY5YzBkMTZhZjE2ODk0Tz88RCBhcyBkaW\
dlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aDZjNzQ3MDQ3ZTBiOTlhZTRQPzxE\
IGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6dXBkYXRlOjpoYzc0NWM2OGZiMjUzZm\
M3NVE/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6OmgwYWVmYjE2\
NGE0OGFhYjkzUj88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aD\
hhNzU4MTA3YTE1YTY5ODhTPzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6dXBk\
YXRlOjpoZTZjYTA1YjBlMDIzMmFmMVRHPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3\
Q+OjpmaW5hbGl6ZV9yZXNldDo6aGU0NDA4NTFjOThmY2M1MGVVRzxEIGFzIGRpZ2VzdDo6ZHluX2Rp\
Z2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6Omg0YzM2MDA0ZmI2NmU0MDhiVkE8RCBhcy\
BkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoNDdiYzc5NzYwZDQxYTlh\
N1dBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aDRhOTAzNj\
YwYTliYWFjMzJYYTxyaXBlbWQxNjA6OlJpcGVtZDE2MCBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91\
dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aDVjYzU1ZjUzZDJiMjEzZThZXDxzaGEzOj\
pLZWNjYWszODQgYXMgZGlnZXN0OjpmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2lu\
dG9fZGlydHk6Omg4N2JkZWM5MTM2MmJhY2QxWls8c2hhMzo6U2hhM18zODQgYXMgZGlnZXN0OjpmaX\
hlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6Omg3ZDIxZjkwMzRlZmI5\
OGUwWz88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aDhiM2RkYj\
AyYTI2ZjU0OTZcQjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25l\
OjpoM2Q4Zjk4NjQ5MWE5MjM3Zl1CPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Oj\
pib3hfY2xvbmU6OmhkZmQ4MDFlYTc1NzU5M2VlXj88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5\
bkRpZ2VzdD46OnVwZGF0ZTo6aDE0YWFiMjYyYmU3NGM3ZTFfVTxtZDU6Ok1kNSBhcyBkaWdlc3Q6Om\
ZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aGY5MTE3ZDBmZDdm\
YTU4MGRgVTxtZDQ6Ok1kNCBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6ZmluYW\
xpemVfaW50b19kaXJ0eTo6aGQ0YmE5ZDg3ZTU0NGIxZjFhQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2Vz\
dDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmgzNGFiMTMzODRjNzExOTg1Yj88RCBhcyBkaWdlc3Q6Om\
R5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aDY0YTk2NWM0ODQ5NzJmODdjbmdlbmVyaWNf\
YXJyYXk6OmltcGxzOjo8aW1wbCBjb3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6Ok\
dlbmVyaWNBcnJheTxULE4+Pjo6Y2xvbmU6OmhlZDc4NGMxZGEyZDI3MmRkZFw8c2hhMzo6S2VjY2Fr\
MjI0IGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2Rpcn\
R5OjpoZGVhNjQ2N2NhY2FlYTRhOGVcPHNoYTM6OktlY2NhazI1NiBhcyBkaWdlc3Q6OmZpeGVkOjpG\
aXhlZE91dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aDg0OGMwM2QxMTMwMzk5YTFmWz\
xzaGEzOjpTaGEzXzI1NiBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6ZmluYWxp\
emVfaW50b19kaXJ0eTo6aGNjYTRlZWM0Y2ZhZjJjYzlnWzxzaGEzOjpTaGEzXzIyNCBhcyBkaWdlc3\
Q6OmZpeGVkOjpGaXhlZE91dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aDNmM2FkZGY5\
YWMzYjU5ZTVoQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6Om\
hmZjE0ZDM4OThhYjY3NWUwaUE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZp\
bmFsaXplOjpoODM5YWQzNDA5YzMxNTM3N2pCPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaW\
dlc3Q+Ojpib3hfY2xvbmU6Omg2MjMyOTlhNjZmZDk5N2Ywa0I8RCBhcyBkaWdlc3Q6OmR5bl9kaWdl\
c3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDQ4ZDg3NWU4NTc4MTkzMmFsTmFsbG9jOjpyYXdfdm\
VjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOGUwMzQxOTEz\
OWYxOWFlY21uZ2VuZXJpY19hcnJheTo6aW1wbHM6OjxpbXBsIGNvcmU6OmNsb25lOjpDbG9uZSBmb3\
IgZ2VuZXJpY19hcnJheTo6R2VuZXJpY0FycmF5PFQsTj4+OjpjbG9uZTo6aDE2OGZhMDUxYWU1Nzgy\
MWVubmdlbmVyaWNfYXJyYXk6OmltcGxzOjo8aW1wbCBjb3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbm\
VyaWNfYXJyYXk6OkdlbmVyaWNBcnJheTxULE4+Pjo6Y2xvbmU6Omg2MjUyYWFkYTRjZmZhNzRkb25n\
ZW5lcmljX2FycmF5OjppbXBsczo6PGltcGwgY29yZTo6Y2xvbmU6OkNsb25lIGZvciBnZW5lcmljX2\
FycmF5OjpHZW5lcmljQXJyYXk8VCxOPj46OmNsb25lOjpoN2U1NDJiNDc1YWYwMTQxNXBuZ2VuZXJp\
Y19hcnJheTo6aW1wbHM6OjxpbXBsIGNvcmU6OmNsb25lOjpDbG9uZSBmb3IgZ2VuZXJpY19hcnJheT\
o6R2VuZXJpY0FycmF5PFQsTj4+OjpjbG9uZTo6aGFhNDRjZDZiYTc1MmMyZmFxbmdlbmVyaWNfYXJy\
YXk6OmltcGxzOjo8aW1wbCBjb3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6Okdlbm\
VyaWNBcnJheTxULE4+Pjo6Y2xvbmU6OmhkYzYzOGNkNDllYjFjNjQ5ckI8RCBhcyBkaWdlc3Q6OmR5\
bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDRhMjcwZTFlODQxOTdiMjJzQjxEIGFzIG\
RpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpoYjZjNjY3ZjVkZTc0Yjll\
N3RCPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6OmhhMWFmYj\
AzNmMxOTllYTc1dUI8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9u\
ZTo6aDRmZDk3ODU5MGViZmM1NjV2LmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aDEzMTVlOD\
YxMzZkOTc3Yjh3QjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25l\
OjpoMWE3MTExMzkwMDg2OGNkMXhCPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Oj\
pib3hfY2xvbmU6OmgyMTczMzdhYWE0MmFjZTk3eUI8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5\
bkRpZ2VzdD46OmJveF9jbG9uZTo6aDI3M2RjYWUwMjJhYzZhMTl6QjxEIGFzIGRpZ2VzdDo6ZHluX2\
RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpoOWQ4OGQyODQyNWQyMWFiZXtCPEQgYXMgZGln\
ZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6OmhiZjc1ZTczNDUwZmNmMDNmfE\
I8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aGMyY2NlMTRi\
ODQ2MTRiYzh9QjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOj\
poYzU2Yjg3MWU5NzFiYmFkMH5CPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpi\
b3hfY2xvbmU6OmhjNzRjMmFjNDhlMWE1OWFify5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6Om\
hlODdjNGRhNDg3NDZlODk2gAFQPGFycmF5dmVjOjplcnJvcnM6OkNhcGFjaXR5RXJyb3I8VD4gYXMg\
Y29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDg2N2MxM2QzM2EzYzg5ZDOBAVA8YXJyYXl2ZWM6OmVycm\
9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZmFkZjA2MzY2\
NDc1Y2Q3M4IBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6OmgxYj\
dkMjMxNzFlYWM2YjE3gwE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpyZXNl\
dDo6aDUzZGFjNDVkNTRlMWZhMGGEAUFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZG\
V4X2xlbl9mYWlsOjpoNzA4NjA1YmI4ZmViZDJmNIUBP2NvcmU6OnNsaWNlOjppbmRleDo6c2xpY2Vf\
ZW5kX2luZGV4X2xlbl9mYWlsOjpoN2VmYjBmMDBmYmNjOTI4YoYBTmNvcmU6OnNsaWNlOjo8aW1wbC\
BbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoYzFkMThmZTFkNTg1YzNl\
MYcBNmNvcmU6OnBhbmlja2luZzo6cGFuaWNfYm91bmRzX2NoZWNrOjpoYWFlYzg4OWJhMThkZDY4NY\
gBPWNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfaW5kZXhfb3JkZXJfZmFpbDo6aDk5OGU2MDViNGFm\
OTRiN2KJATdnZW5lcmljX2FycmF5Ojpmcm9tX2l0ZXJfbGVuZ3RoX2ZhaWw6Omg0MjliY2M1ZDVkZm\
FjNDhhigE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpyZXNldDo6aGJkZmZj\
NjJjMjcwNjhiZjWLATdzdGQ6OnBhbmlja2luZzo6cnVzdF9wYW5pY193aXRoX2hvb2s6OmgyZDkwNz\
k0MjdhMmQ5OTZhjAE6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoMWE2\
YjAxMTg4NzJlMGRiYo0BC2RpZ2VzdF9oYXNojgE6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPj\
o6d3JpdGVfc3RyOjpoZWEyOGQzYjg3Njk1ZDMwZo8BBm1lbWNtcJABE19fd2JnX2Rlbm9oYXNoX2Zy\
ZWWRAQt1cGRhdGVfaGFzaJIBQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OndyaX\
RlX3ByZWZpeDo6aDQ3ZmE5MWE3YWZmOTRmNWKTAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5\
bkRpZ2VzdD46OnJlc2V0OjpoMGFkOGM4NDA2Mzk4OGJiOZQBKWNvcmU6OnBhbmlja2luZzo6cGFuaW\
M6OmgzOGNhYzcxMGI1MDQ4Y2EwlQE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+\
OjpyZXNldDo6aDNlMWUwYzRmNjQwNDc1OTGWAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bk\
RpZ2VzdD46OnJlc2V0OjpoYzMyYzYwNzZkOGZkMGQ2OZcBBm1lbWNweZgBEXJ1c3RfYmVnaW5fdW53\
aW5kmQE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpyZXNldDo6aDU3YWUyNm\
IwMzcxNzg1YzeaAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnJlc2V0Ojpo\
YjgxZmYyMzJhMDZjM2JjMZsBLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoMWZlYTYyMzc1NW\
ZmZmVkN5wBSXN0ZDo6c3lzX2NvbW1vbjo6YmFja3RyYWNlOjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0\
cmFjZTo6aDkxZTcxMTYwN2Q5MWJlNTKdAQZtZW1zZXSeARFfX3diaW5kZ2VuX21hbGxvY58BPjxEIG\
FzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6OmhhODA3YTcxYjdkMTY1MGQ0\
oAFDc3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6Ont7Y2xvc3VyZX19OjpoNGU0OW\
YzNTBkOWY0ZGUzNqEBEl9fd2JpbmRnZW5fcmVhbGxvY6IBO2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFj\
ZTxibGFrZTM6Okhhc2hlcj46OmhmY2Q1OGMwZDU3Mjc0YjBiowFFPGJsb2NrX3BhZGRpbmc6OlBhZE\
Vycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg2MjE0NGM2NGE1Y2MzOThlpAE+PGNvcmU6\
OmZtdDo6RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDliOTQ0ODY4ZWM2ZjFjNWOlAT\
Jjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNTg4NDZlYTljYjc2NjZmMaYBMDwmVCBh\
cyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZDYwY2EzZmU0ODAwZTNjZacBMjwmVCBhcyBjb3JlOj\
pmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhhYjhjZDIyOWI5ZTIwMmM4qAFOPEkgYXMgY29yZTo6aXRlcjo6\
dHJhaXRzOjpjb2xsZWN0OjpJbnRvSXRlcmF0b3I+OjppbnRvX2l0ZXI6Omg1Y2YxYjdmMDliYWExNz\
cxqQEPX193YmluZGdlbl9mcmVlqgE0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93Ojpo\
ZDYxMmU3ZWZhMTJjMzdkZqsBOWNvcmU6Om9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNlOj\
poZGRlOTUzNDE1ODJlOGEyYawBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6\
cmVzZXQ6OmgwODNlNjNiYzBjNTQ3NTBhrQE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaW\
dlc3Q+OjpyZXNldDo6aDNjZjc1ZTA0MTNmZDBkMTOuAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6\
OkR5bkRpZ2VzdD46OnJlc2V0OjpoNDI2NmVjMDdiNjkyMTUxMa8BPjxEIGFzIGRpZ2VzdDo6ZHluX2\
RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6OmhjODJjZGE3ZDVlNDZlNWM4sAEfX193YmluZGdlbl9h\
ZGRfdG9fc3RhY2tfcG9pbnRlcrEBMXdhc21fYmluZGdlbjo6X19ydDo6dGhyb3dfbnVsbDo6aDUwY2\
EyNjg0N2U4NGVlNmGyATJ3YXNtX2JpbmRnZW46Ol9fcnQ6OmJvcnJvd19mYWlsOjpoOGJhMWFmZDdl\
OTcyZGRkObMBTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3\
IgdTMyPjo6Zm10OjpoZGM0MTczNmM1M2ZjNzk3NLQBKndhc21fYmluZGdlbjo6dGhyb3dfc3RyOjpo\
NzZiMTdjYTcxNDY1NjQ3OLUBKndhc21fYmluZGdlbjo6dGhyb3dfdmFsOjpoMmVkMWZiNGI0YTBhNz\
Q3ZrYBMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aDJkNDcxYjk2YmM0Y2JjZmO3AUQ8\
RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoMDU4Y2E3OT\
M1NWJlM2E5MbgBRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3V0cHV0X3Np\
emU6Omg0NDQzMjc2ZmU0ODk5ZTk4uQFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3\
Q+OjpvdXRwdXRfc2l6ZTo6aDUzZWQwMzk5YTIyOTNhYze6AUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdl\
c3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoOTAyNzVhZWVmMGQwZDAyZbsBRDxEIGFzIGRpZ2\
VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3V0cHV0X3NpemU6OmhkZTBlZTFkNTZiYTM0NThm\
vAFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpvdXRwdXRfc2l6ZTo6aGYwMG\
ZmN2RiODliNGFmMDK9AUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1\
dF9zaXplOjpoNTM5M2JmZDg1NDI4Nzk3NL4BRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRG\
lnZXN0Pjo6b3V0cHV0X3NpemU6Omg1NTU5MjkxNGRjNjE3M2VmvwFEPEQgYXMgZGlnZXN0OjpkeW5f\
ZGlnZXN0OjpEeW5EaWdlc3Q+OjpvdXRwdXRfc2l6ZTo6aDY4ZDhmMjBhNGExYTJmZGPAAUQ8RCBhcy\
BkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoMjRmNGQ1ZDg3ODY3\
OGViMMEBRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3V0cHV0X3NpemU6Om\
hmYWIxZjQxMmNmODRmZjYzwgFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpv\
dXRwdXRfc2l6ZTo6aDdjYjRmYzIwMDk2MjU1MjjDAUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6Ok\
R5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoOTFjYTk4NDFjYzMyZGU2NsQBCnJ1c3RfcGFuaWPFATdz\
dGQ6OmFsbG9jOjpkZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6OmgwZWNjZGFjMjRmZGEzNzhmxgFvY2\
9yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waWVkOjpDb3Bp\
ZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46OmhmN2JkMDQzN2MzZTg4NjM5AO+AgIAACX\
Byb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS41NC4wIChhMTc4\
ZDAzMjIgMjAyMS0wNy0yNikGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4GMC4yLjc0"));
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
const wasm = wasmInstance.exports;
const hexTable = new TextEncoder().encode("0123456789abcdef");
function encode1(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 15];
    }
    return dst;
}
class Hash {
    #hash;
    #digested;
    constructor(algorithm){
        this.#hash = create_hash(algorithm);
        this.#digested = false;
    }
    update(message) {
        let view;
        if (message instanceof Uint8Array) {
            view = message;
        } else if (typeof message === "string") {
            view = new TextEncoder().encode(message);
        } else if (ArrayBuffer.isView(message)) {
            view = new Uint8Array(message.buffer, message.byteOffset, message.byteLength);
        } else if (message instanceof ArrayBuffer) {
            view = new Uint8Array(message);
        } else {
            throw new Error("hash: `data` is invalid type");
        }
        const chunkSize = 65536;
        for(let offset = 0; offset < view.byteLength; offset += chunkSize){
            update_hash(this.#hash, new Uint8Array(view.buffer, view.byteOffset + offset, Math.min(65536, view.byteLength - offset)));
        }
        return this;
    }
    digest() {
        if (this.#digested) throw new Error("hash: already digested");
        this.#digested = true;
        return digest_hash(this.#hash);
    }
    toString(format = "hex") {
        const finalized = new Uint8Array(this.digest());
        switch(format){
            case "hex":
                return new TextDecoder().decode(encode1(finalized));
            case "base64":
                return encode(finalized);
            default:
                throw new Error("hash: invalid format");
        }
    }
}
function createHash(algorithm) {
    return new Hash(algorithm);
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
     #tryGrowByReslice(n) {
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    }
     #reslice(len) {
        assert(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    readSync(p) {
        if (this.empty()) {
            this.reset();
            if (p.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy(this.#buf.subarray(this.#off), p);
        this.#off += nread;
        return nread;
    }
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = this.#grow(p.byteLength);
        return copy(p, this.#buf, m);
    }
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
     #grow(n) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n <= Math.floor(c / 2) - m) {
            copy(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
            copy(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n, MAX_SIZE));
        return m;
    }
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
}
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {
}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i = 0; i < Math.min(A.length, B.length); i += 1){
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        } else {
            return common;
        }
    }
    return common;
}
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [
        B,
        A
    ] : [
        A,
        B
    ];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })
            ),
            ...A.map((a)=>({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a
                })
            ),
            ...suffixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })
            ), 
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = new Array(size).fill({
        y: -1
    });
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type) break;
            const prev = j;
            if (type === 1) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b]
                });
                b -= 1;
            } else if (type === 3) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType.common,
                    value: A[a]
                });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev = down.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k, M);
        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp[delta + offset].y < N){
        p = p + 1;
        for(let k = -p; k < delta; ++k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for(let k1 = delta + p; k1 > delta; --k1){
            fp[k1 + offset] = snake(k1, fp[k1 - 1 + offset], fp[k1 + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })
        ),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })
        ), 
    ];
}
function diffstr(A, B) {
    function tokenize(string, { wordDiff =false  } = {
    }) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i = 0; i < tokens.length - 1; i++){
                if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
                    tokens[i] += tokens[i + 2];
                    tokens.splice(i + 1, 2);
                    i--;
                }
            }
            return tokens.filter((token)=>token
            );
        } else {
            const tokens = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i = 0; i < lines.length; i++){
                if (i % 2) {
                    tokens[tokens.length - 1] += lines[i];
                } else {
                    tokens.push(lines[i]);
                }
            }
            return tokens;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type  })=>type === line.type || type === DiffType.common
        ).map((result, i, t)=>{
            if (result.type === DiffType.common && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
                result.type = t[i - 1].type;
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${A}\n`), tokenize(`${B}\n`));
    const added = [], removed = [];
    for (const result of diffResult){
        if (result.type === DiffType.added) {
            added.push(result);
        }
        if (result.type === DiffType.removed) {
            removed.push(result);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines){
        let tokens = [], b;
        while(bLines.length){
            b = bLines.shift();
            tokens = diff(tokenize(a.value, {
                wordDiff: true
            }), tokenize(b?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type , value  })=>type === DiffType.common && value.trim().length
            )) {
                break;
            }
        }
        a.details = createDetails(a, tokens);
        if (b) {
            b.details = createDetails(b, tokens);
        }
    }
    return diffResult;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message1){
        super(message1);
    }
}
function _format(v) {
    const { Deno  } = globalThis;
    return typeof Deno?.inspect === "function" ? Deno.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
function createColor(diffType, { background =false  } = {
}) {
    switch(diffType){
        case DiffType.added:
            return (s)=>background ? bgGreen(white(s)) : green(bold(s))
            ;
        case DiffType.removed:
            return (s)=>background ? bgRed(white(s)) : red(bold(s))
            ;
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {
}) {
    const messages = [], diffMessages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value
        ).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages.push("");
    return messages;
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k)=>k in x
    );
}
function equal(c, d) {
    const seen = new Map();
    return (function compare(a, b) {
        if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return a.getTime() === b.getTime();
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (a && b && !constructorsEqual(a, b)) {
                return false;
            }
            if (a instanceof WeakMap || b instanceof WeakMap) {
                if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b instanceof WeakSet) {
                if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {
            }).length !== Object.keys(b || {
            }).length) {
                return false;
            }
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b.entries()){
                        if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
                            unmatchedEntries--;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged), 
            ]){
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
                if (key in a && !(key in b) || key in b && !(key in a)) {
                    return false;
                }
            }
            seen.set(a, b);
            if (a instanceof WeakRef || b instanceof WeakRef) {
                if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;
                return compare(a.deref(), b.deref());
            }
            return true;
        }
        return false;
    })(c, d);
}
function constructorsEqual(a, b) {
    return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
function assertNotEquals(actual, expected, msg) {
    if (!equal(actual, expected)) {
        return;
    }
    let actualString;
    let expectedString;
    try {
        actualString = String(actual);
    } catch  {
        actualString = "[Cannot display]";
    }
    try {
        expectedString = String(expected);
    } catch  {
        expectedString = "[Cannot display]";
    }
    if (!msg) {
        msg = `actual: ${actualString} expected: ${expectedString}`;
    }
    throw new AssertionError(msg);
}
function assertStrictEquals(actual, expected, msg) {
    if (actual === expected) {
        return;
    }
    let message;
    if (msg) {
        message = msg;
    } else {
        const actualString = _format(actual);
        const expectedString = _format(expected);
        if (actualString === expectedString) {
            const withOffset = actualString.split("\n").map((l)=>`    ${l}`
            ).join("\n");
            message = `Values have the same structure but are not reference-equal:\n\n${red(withOffset)}\n`;
        } else {
            try {
                const stringDiff = typeof actual === "string" && typeof expected === "string";
                const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
                const diffMsg = buildMessage(diffResult, {
                    stringDiff
                }).join("\n");
                message = `Values are not strictly equal:\n${diffMsg}`;
            } catch  {
                message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
            }
        }
    }
    throw new AssertionError(message);
}
const DEFAULT_BUFFER_SIZE = 32 * 1024;
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
async function copy1(src, dst, options) {
    let n = 0;
    const bufSize = options?.bufSize ?? DEFAULT_BUFFER_SIZE;
    const b = new Uint8Array(bufSize);
    let gotEOF = false;
    while(gotEOF === false){
        const result = await src.read(b);
        if (result === null) {
            gotEOF = true;
        } else {
            let nwritten = 0;
            while(nwritten < result){
                nwritten += await dst.write(b.subarray(nwritten, result));
            }
            n += nwritten;
        }
    }
    return n;
}
const DEFAULT_BUF_SIZE = 4096;
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial1){
        super("Buffer full");
        this.partial = partial1;
    }
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    buf;
    rd;
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd1, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this._reset(new Uint8Array(size), rd1);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr = await this.rd.read(p);
                const nread = rr ?? 0;
                assert(nread >= 0, "negative read");
                return rr;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copy(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            if (!this.eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.buf.subarray(this.r, this.r + i + 1);
                this.r += i + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.buf.subarray(this.r, this.w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.buf.subarray(this.r, this.w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer1, size1 = 4096){
        super();
        this.writer = writer1;
        if (size1 <= 0) {
            size1 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size1);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer2, size2 = 4096){
        super();
        this.writer = writer2;
        if (size2 <= 0) {
            size2 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size2);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class StringReader extends Buffer {
    constructor(s){
        super(new TextEncoder().encode(s).buffer);
    }
}
class MultiReader {
    readers;
    currentIndex = 0;
    constructor(...readers1){
        this.readers = readers1;
    }
    async read(p) {
        const r = this.readers[this.currentIndex];
        if (!r) return null;
        const result = await r.read(p);
        if (result === null) {
            this.currentIndex++;
            return 0;
        }
        return result;
    }
}
class LimitedReader {
    reader;
    limit;
    constructor(reader1, limit1){
        this.reader = reader1;
        this.limit = limit1;
    }
    async read(p) {
        if (this.limit <= 0) {
            return null;
        }
        if (p.length > this.limit) {
            p = p.subarray(0, this.limit);
        }
        const n = await this.reader.read(p);
        if (n == null) {
            return null;
        }
        this.limit -= n;
        return n;
    }
}
function readerFromStreamReader(streamReader) {
    const buffer = new Buffer();
    return {
        async read (p) {
            if (buffer.empty()) {
                const res = await streamReader.read();
                if (res.done) {
                    return null;
                }
                await writeAll(buffer, res.value);
            }
            return buffer.read(p);
        }
    };
}
const decoder = new TextDecoder();
class StringWriter {
    base;
    chunks = [];
    byteLength = 0;
    cache;
    constructor(base1 = ""){
        this.base = base1;
        const c = new TextEncoder().encode(base1);
        this.chunks.push(c);
        this.byteLength += c.byteLength;
    }
    write(p) {
        return Promise.resolve(this.writeSync(p));
    }
    writeSync(p) {
        this.chunks.push(p);
        this.byteLength += p.byteLength;
        this.cache = undefined;
        return p.byteLength;
    }
    toString() {
        if (this.cache) {
            return this.cache;
        }
        const buf = new Uint8Array(this.byteLength);
        let offs = 0;
        for (const chunk of this.chunks){
            buf.set(chunk, offs);
            offs += chunk.byteLength;
        }
        this.cache = decoder.decode(buf);
        return this.cache;
    }
}
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = function() {
    return {
        sep: sep,
        delimiter: delimiter,
        resolve: resolve,
        normalize: normalize,
        isAbsolute: isAbsolute,
        join: join,
        relative: relative,
        toNamespacedPath: toNamespacedPath,
        dirname: dirname,
        basename: basename,
        extname: extname,
        format: format4,
        parse: parse,
        fromFileUrl: fromFileUrl,
        toFileUrl: toFileUrl
    };
}();
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = function() {
    return {
        sep: sep1,
        delimiter: delimiter1,
        resolve: resolve1,
        normalize: normalize1,
        isAbsolute: isAbsolute1,
        join: join1,
        relative: relative1,
        toNamespacedPath: toNamespacedPath1,
        dirname: dirname1,
        basename: basename1,
        extname: extname1,
        format: format1,
        parse: parse1,
        fromFileUrl: fromFileUrl1,
        toFileUrl: toFileUrl1
    };
}();
const path = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join2 , normalize: normalize2 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path;
const consoleLogger = {
    type: 'logger',
    log (args) {
        this.output('log', args);
    },
    warn (args) {
        this.output('warn', args);
    },
    error (args) {
        this.output('error', args);
    },
    output (type, args) {
        if (console && console[type]) console[type].apply(console, args);
    }
};
class Logger {
    constructor(concreteLogger, options2 = {
    }){
        this.init(concreteLogger, options2);
    }
    init(concreteLogger, options = {
    }) {
        this.prefix = options.prefix || 'i18next:';
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
    }
    setDebug(bool) {
        this.debug = bool;
    }
    log(...args) {
        return this.forward(args, 'log', '', true);
    }
    warn(...args) {
        return this.forward(args, 'warn', '', true);
    }
    error(...args) {
        return this.forward(args, 'error', '');
    }
    deprecate(...args) {
        return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
    forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (typeof args[0] === 'string') args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
    }
    create(moduleName) {
        return new Logger(this.logger, {
            ...{
                prefix: `${this.prefix}:${moduleName}:`
            },
            ...this.options
        });
    }
}
const __default = new Logger();
class EventEmitter {
    constructor(){
        this.observers = {
        };
    }
    on(events, listener) {
        events.split(' ').forEach((event)=>{
            this.observers[event] = this.observers[event] || [];
            this.observers[event].push(listener);
        });
        return this;
    }
    off(event, listener) {
        if (!this.observers[event]) return;
        if (!listener) {
            delete this.observers[event];
            return;
        }
        this.observers[event] = this.observers[event].filter((l)=>l !== listener
        );
    }
    emit(event, ...args) {
        if (this.observers[event]) {
            const cloned = [].concat(this.observers[event]);
            cloned.forEach((observer)=>{
                observer(...args);
            });
        }
        if (this.observers['*']) {
            const cloned = [].concat(this.observers['*']);
            cloned.forEach((observer)=>{
                observer.apply(observer, [
                    event,
                    ...args
                ]);
            });
        }
    }
}
function defer() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject)=>{
        res = resolve;
        rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
}
function makeString(object) {
    if (object == null) return '';
    return '' + object;
}
function copy2(a, s, t) {
    a.forEach((m)=>{
        if (s[m]) t[m] = s[m];
    });
}
function getLastOfPath(object, path, Empty) {
    function cleanKey(key) {
        return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
    }
    function canNotTraverseDeeper() {
        return !object || typeof object === 'string';
    }
    const stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
    while(stack.length > 1){
        if (canNotTraverseDeeper()) return {
        };
        const key = cleanKey(stack.shift());
        if (!object[key] && Empty) object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
            object = object[key];
        } else {
            object = {
            };
        }
    }
    if (canNotTraverseDeeper()) return {
    };
    return {
        obj: object,
        k: cleanKey(stack.shift())
    };
}
function setPath(object, path, newValue) {
    const { obj , k  } = getLastOfPath(object, path, Object);
    obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
    const { obj , k  } = getLastOfPath(object, path, Object);
    obj[k] = obj[k] || [];
    if (concat) obj[k] = obj[k].concat(newValue);
    if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
    const { obj , k  } = getLastOfPath(object, path);
    if (!obj) return undefined;
    return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
    const value = getPath(data, key);
    if (value !== undefined) {
        return value;
    }
    return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
    for(const prop in source){
        if (prop !== '__proto__' && prop !== 'constructor') {
            if (prop in target) {
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                    if (overwrite) target[prop] = source[prop];
                } else {
                    deepExtend(target[prop], source[prop], overwrite);
                }
            } else {
                target[prop] = source[prop];
            }
        }
    }
    return target;
}
function regexEscape(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var _entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
};
function escape(data) {
    if (typeof data === 'string') {
        return data.replace(/[&<>"'\/]/g, (s)=>_entityMap[s]
        );
    }
    return data;
}
const isIE10 = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
const chars = [
    ' ',
    ',',
    '?',
    '!',
    ';'
];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
    nsSeparator = nsSeparator || '';
    keySeparator = keySeparator || '';
    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0
    );
    if (possibleChars.length === 0) return true;
    const r = new RegExp(`(${possibleChars.map((c)=>c === '?' ? '\\?' : c
    ).join('|')})`);
    let matched = !r.test(key);
    if (!matched) {
        const ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
            matched = true;
        }
    }
    return matched;
}
function deepFind(obj, path, keySeparator = '.') {
    if (!obj) return undefined;
    if (obj[path]) return obj[path];
    const paths = path.split(keySeparator);
    let current = obj;
    for(let i = 0; i < paths.length; ++i){
        if (!current) return undefined;
        if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
            return undefined;
        }
        if (current[paths[i]] === undefined) {
            let j = 2;
            let p = paths.slice(i, i + j).join(keySeparator);
            let mix = current[p];
            while(mix === undefined && paths.length > i + j){
                j++;
                p = paths.slice(i, i + j).join(keySeparator);
                mix = current[p];
            }
            if (mix === undefined) return undefined;
            if (typeof mix === 'string') return mix;
            if (p && typeof mix[p] === 'string') return mix[p];
            const joinedPath = paths.slice(i + j).join(keySeparator);
            if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
            return undefined;
        }
        current = current[paths[i]];
    }
    return current;
}
class ResourceStore extends EventEmitter {
    constructor(data, options1 = {
        ns: [
            'translation'
        ],
        defaultNS: 'translation'
    }){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.data = data || {
        };
        this.options = options1;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        if (this.options.ignoreJSONStructure === undefined) {
            this.options.ignoreJSONStructure = true;
        }
    }
    addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
        }
    }
    removeNamespaces(ns) {
        const index = this.options.ns.indexOf(ns);
        if (index > -1) {
            this.options.ns.splice(index, 1);
        }
    }
    getResource(lng, ns, key, options = {
    }) {
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path = [
            lng,
            ns
        ];
        if (key && typeof key !== 'string') path = path.concat(key);
        if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
        }
        const result = getPath(this.data, path);
        if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
    addResource(lng, ns, key, value, options = {
        silent: false
    }) {
        let keySeparator = this.options.keySeparator;
        if (keySeparator === undefined) keySeparator = '.';
        let path = [
            lng,
            ns
        ];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            value = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options.silent) this.emit('added', lng, ns, key, value);
    }
    addResources(lng, ns, resources, options = {
        silent: false
    }) {
        for(const m in resources){
            if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
                silent: true
            });
        }
        if (!options.silent) this.emit('added', lng, ns, resources);
    }
    addResourceBundle(lng, ns, resources, deep, overwrite, options = {
        silent: false
    }) {
        let path = [
            lng,
            ns
        ];
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            deep = resources;
            resources = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path) || {
        };
        if (deep) {
            deepExtend(pack, resources, overwrite);
        } else {
            pack = {
                ...pack,
                ...resources
            };
        }
        setPath(this.data, path, pack);
        if (!options.silent) this.emit('added', lng, ns, resources);
    }
    removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit('removed', lng, ns);
    }
    hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== undefined;
    }
    getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS;
        if (this.options.compatibilityAPI === 'v1') return {
            ...{
            },
            ...this.getResource(lng, ns)
        };
        return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
        return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n = data && Object.keys(data) || [];
        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0
        );
    }
    toJSON() {
        return this.data;
    }
}
const __default1 = {
    processors: {
    },
    addPostProcessor (module) {
        this.processors[module.name] = module;
    },
    handle (processors, value, key, options, translator) {
        processors.forEach((processor)=>{
            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
        });
        return value;
    }
};
const checkedLoadedFor = {
};
class Translator extends EventEmitter {
    constructor(services, options3 = {
    }){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        copy2([
            'resourceStore',
            'languageUtils',
            'pluralResolver',
            'interpolator',
            'backendConnector',
            'i18nFormat',
            'utils', 
        ], services, this);
        this.options = options3;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        this.logger = __default.create('translator');
    }
    changeLanguage(lng) {
        if (lng) this.language = lng;
    }
    exists(key, options = {
        interpolation: {
        }
    }) {
        if (key === undefined || key === null) {
            return false;
        }
        const resolved = this.resolve(key, options);
        return resolved && resolved.res !== undefined;
    }
    extractFromKey(key, options) {
        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === undefined) nsSeparator = ':';
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        let namespaces = options.ns || this.options.defaultNS;
        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            const m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
                return {
                    key,
                    namespaces
                };
            }
            const parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
            key = parts.join(keySeparator);
        }
        if (typeof namespaces === 'string') namespaces = [
            namespaces
        ];
        return {
            key,
            namespaces
        };
    }
    translate(keys, options, lastKey) {
        if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
            options = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (!options) options = {
        };
        if (keys === undefined || keys === null) return '';
        if (!Array.isArray(keys)) keys = [
            String(keys)
        ];
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        const { key , namespaces  } = this.extractFromKey(keys[keys.length - 1], options);
        const namespace = namespaces[namespaces.length - 1];
        const lng = options.lng || this.language;
        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng && lng.toLowerCase() === 'cimode') {
            if (appendNamespaceToCIMode) {
                const nsSeparator = options.nsSeparator || this.options.nsSeparator;
                return namespace + nsSeparator + key;
            }
            return key;
        }
        const resolved = this.resolve(keys, options);
        let res = resolved && resolved.res;
        const resUsedKey = resolved && resolved.usedKey || key;
        const resExactUsedKey = resolved && resolved.exactUsedKey || key;
        const resType = Object.prototype.toString.apply(res);
        const noObject = [
            '[object Number]',
            '[object Function]',
            '[object RegExp]'
        ];
        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
            if (!options.returnObjects && !this.options.returnObjects) {
                if (!this.options.returnedObjectHandler) {
                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                }
                return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
                    ...options,
                    ns: namespaces
                }) : `key '${key} (${this.language})' returned an object instead of string.`;
            }
            if (keySeparator) {
                const resTypeIsArray = resType === '[object Array]';
                const copy = resTypeIsArray ? [] : {
                };
                let newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                for(const m in res){
                    if (Object.prototype.hasOwnProperty.call(res, m)) {
                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                        copy[m] = this.translate(deepKey, {
                            ...options,
                            ...{
                                joinArrays: false,
                                ns: namespaces
                            }
                        });
                        if (copy[m] === deepKey) copy[m] = res[m];
                    }
                }
                res = copy;
            }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
            res = res.join(joinArrays);
            if (res) res = this.extendTranslation(res, keys, options, lastKey);
        } else {
            let usedDefault = false;
            let usedKey = false;
            const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            const hasDefaultValue = Translator.hasDefaultValue(options);
            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
            const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options.defaultValue;
            if (!this.isValidLookup(res) && hasDefaultValue) {
                usedDefault = true;
                res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
                usedKey = true;
                res = key;
            }
            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
                this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                if (keySeparator) {
                    const fk = this.resolve(key, {
                        ...options,
                        keySeparator: false
                    });
                    if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                }
                let lngs = [];
                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                    for(let i = 0; i < fallbackLngs.length; i++){
                        lngs.push(fallbackLngs[i]);
                    }
                } else if (this.options.saveMissingTo === 'all') {
                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                } else {
                    lngs.push(options.lng || this.language);
                }
                const send = (l, k, fallbackValue)=>{
                    if (this.options.missingKeyHandler) {
                        this.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : resForMissing, updateMissing, options);
                    } else if (this.backendConnector && this.backendConnector.saveMissing) {
                        this.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : resForMissing, updateMissing, options);
                    }
                    this.emit('missingKey', l, namespace, k, res);
                };
                if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                        lngs.forEach((language)=>{
                            this.pluralResolver.getSuffixes(language).forEach((suffix)=>{
                                send([
                                    language
                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
                            });
                        });
                    } else {
                        send(lngs, key, defaultValue);
                    }
                }
            }
            res = this.extendTranslation(res, keys, options, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        }
        return res;
    }
    extendTranslation(res, key, options, resolved, lastKey) {
        if (this.i18nFormat && this.i18nFormat.parse) {
            res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                resolved
            });
        } else if (!options.skipInterpolation) {
            if (options.interpolation) this.interpolator.init({
                ...options,
                ...{
                    interpolation: {
                        ...this.options.interpolation,
                        ...options.interpolation
                    }
                }
            });
            const skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
            let nestBef;
            if (skipOnVariables) {
                const nb = res.match(this.interpolator.nestingRegexp);
                nestBef = nb && nb.length;
            }
            let data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
            if (this.options.interpolation.defaultVariables) data = {
                ...this.options.interpolation.defaultVariables,
                ...data
            };
            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
            if (skipOnVariables) {
                const na = res.match(this.interpolator.nestingRegexp);
                const nestAft = na && na.length;
                if (nestBef < nestAft) options.nest = false;
            }
            if (options.nest !== false) res = this.interpolator.nest(res, (...args)=>{
                if (lastKey && lastKey[0] === args[0] && !options.context) {
                    this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
                    return null;
                }
                return this.translate(...args, key);
            }, options);
            if (options.interpolation) this.interpolator.reset();
        }
        const postProcess = options.postProcess || this.options.postProcess;
        const postProcessorNames = typeof postProcess === 'string' ? [
            postProcess
        ] : postProcess;
        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
            res = __default1.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
                i18nResolved: resolved,
                ...options
            } : options, this);
        }
        return res;
    }
    resolve(keys, options = {
    }) {
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (typeof keys === 'string') keys = [
            keys
        ];
        keys.forEach((k)=>{
            if (this.isValidLookup(found)) return;
            const extracted = this.extractFromKey(k, options);
            const key = extracted.key;
            usedKey = key;
            let namespaces = extracted.namespaces;
            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
            const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            const needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
            namespaces.forEach((ns)=>{
                if (this.isValidLookup(found)) return;
                usedNS = ns;
                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;
                    this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                }
                codes.forEach((code)=>{
                    if (this.isValidLookup(found)) return;
                    usedLng = code;
                    let finalKey = key;
                    const finalKeys = [
                        finalKey
                    ];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                    } else {
                        let pluralSuffix;
                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
                        if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
                        if (needsContextHandling) finalKeys.push(finalKey += `${this.options.contextSeparator}${options.context}`);
                        if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
                    }
                    let possibleKey;
                    while(possibleKey = finalKeys.pop()){
                        if (!this.isValidLookup(found)) {
                            exactUsedKey = possibleKey;
                            found = this.getResource(code, ns, possibleKey, options);
                        }
                    }
                });
            });
        });
        return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
        };
    }
    isValidLookup(res) {
        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
    getResource(code, ns, key, options = {
    }) {
        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
        return this.resourceStore.getResource(code, ns, key, options);
    }
    static hasDefaultValue(options) {
        const prefix = 'defaultValue';
        for(const option in options){
            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
                return true;
            }
        }
        return false;
    }
}
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
class LanguageUtil {
    constructor(options4){
        this.options = options4;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = __default.create('languageUtils');
    }
    getScriptPartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return null;
        const p = code.split('-');
        if (p.length === 2) return null;
        p.pop();
        if (p[p.length - 1].toLowerCase() === 'x') return null;
        return this.formatLanguageCode(p.join('-'));
    }
    getLanguagePartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return code;
        const p = code.split('-');
        return this.formatLanguageCode(p[0]);
    }
    formatLanguageCode(code) {
        if (typeof code === 'string' && code.indexOf('-') > -1) {
            const specialCases = [
                'hans',
                'hant',
                'latn',
                'cyrl',
                'cans',
                'mong',
                'arab'
            ];
            let p = code.split('-');
            if (this.options.lowerCaseLng) {
                p = p.map((part)=>part.toLowerCase()
                );
            } else if (p.length === 2) {
                p[0] = p[0].toLowerCase();
                p[1] = p[1].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
            } else if (p.length === 3) {
                p[0] = p[0].toLowerCase();
                if (p[1].length === 2) p[1] = p[1].toUpperCase();
                if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
            }
            return p.join('-');
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
    isSupportedCode(code) {
        if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
    getBestMatchFromCodes(codes) {
        if (!codes) return null;
        let found;
        codes.forEach((code)=>{
            if (found) return;
            let cleanedLng = this.formatLanguageCode(code);
            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
            codes.forEach((code)=>{
                if (found) return;
                let lngOnly = this.getLanguagePartFromCode(code);
                if (this.isSupportedCode(lngOnly)) return found = lngOnly;
                found = this.options.supportedLngs.find((supportedLng)=>{
                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
                });
            });
        }
        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
    }
    getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
        if (typeof fallbacks === 'string') fallbacks = [
            fallbacks
        ];
        if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
        if (!code) return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found) found = fallbacks.default;
        return found || [];
    }
    toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c)=>{
            if (!c) return;
            if (this.isSupportedCode(c)) {
                codes.push(c);
            } else {
                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
            }
        };
        if (typeof code === 'string' && code.indexOf('-') > -1) {
            if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
            if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === 'string') {
            addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc)=>{
            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
        });
        return codes;
    }
}
let sets = [
    {
        lngs: [
            'ach',
            'ak',
            'am',
            'arn',
            'br',
            'fil',
            'gun',
            'ln',
            'mfe',
            'mg',
            'mi',
            'oc',
            'pt',
            'pt-BR',
            'tg',
            'tl',
            'ti',
            'tr',
            'uz',
            'wa'
        ],
        nr: [
            1,
            2
        ],
        fc: 1
    },
    {
        lngs: [
            'af',
            'an',
            'ast',
            'az',
            'bg',
            'bn',
            'ca',
            'da',
            'de',
            'dev',
            'el',
            'en',
            'eo',
            'es',
            'et',
            'eu',
            'fi',
            'fo',
            'fur',
            'fy',
            'gl',
            'gu',
            'ha',
            'hi',
            'hu',
            'hy',
            'ia',
            'it',
            'kk',
            'kn',
            'ku',
            'lb',
            'mai',
            'ml',
            'mn',
            'mr',
            'nah',
            'nap',
            'nb',
            'ne',
            'nl',
            'nn',
            'no',
            'nso',
            'pa',
            'pap',
            'pms',
            'ps',
            'pt-PT',
            'rm',
            'sco',
            'se',
            'si',
            'so',
            'son',
            'sq',
            'sv',
            'sw',
            'ta',
            'te',
            'tk',
            'ur',
            'yo'
        ],
        nr: [
            1,
            2
        ],
        fc: 2
    },
    {
        lngs: [
            'ay',
            'bo',
            'cgg',
            'fa',
            'ht',
            'id',
            'ja',
            'jbo',
            'ka',
            'km',
            'ko',
            'ky',
            'lo',
            'ms',
            'sah',
            'su',
            'th',
            'tt',
            'ug',
            'vi',
            'wo',
            'zh'
        ],
        nr: [
            1
        ],
        fc: 3
    },
    {
        lngs: [
            'be',
            'bs',
            'cnr',
            'dz',
            'hr',
            'ru',
            'sr',
            'uk'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 4
    },
    {
        lngs: [
            'ar'
        ],
        nr: [
            0,
            1,
            2,
            3,
            11,
            100
        ],
        fc: 5
    },
    {
        lngs: [
            'cs',
            'sk'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 6
    },
    {
        lngs: [
            'csb',
            'pl'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 7
    },
    {
        lngs: [
            'cy'
        ],
        nr: [
            1,
            2,
            3,
            8
        ],
        fc: 8
    },
    {
        lngs: [
            'fr'
        ],
        nr: [
            1,
            2
        ],
        fc: 9
    },
    {
        lngs: [
            'ga'
        ],
        nr: [
            1,
            2,
            3,
            7,
            11
        ],
        fc: 10
    },
    {
        lngs: [
            'gd'
        ],
        nr: [
            1,
            2,
            3,
            20
        ],
        fc: 11
    },
    {
        lngs: [
            'is'
        ],
        nr: [
            1,
            2
        ],
        fc: 12
    },
    {
        lngs: [
            'jv'
        ],
        nr: [
            0,
            1
        ],
        fc: 13
    },
    {
        lngs: [
            'kw'
        ],
        nr: [
            1,
            2,
            3,
            4
        ],
        fc: 14
    },
    {
        lngs: [
            'lt'
        ],
        nr: [
            1,
            2,
            10
        ],
        fc: 15
    },
    {
        lngs: [
            'lv'
        ],
        nr: [
            1,
            2,
            0
        ],
        fc: 16
    },
    {
        lngs: [
            'mk'
        ],
        nr: [
            1,
            2
        ],
        fc: 17
    },
    {
        lngs: [
            'mnk'
        ],
        nr: [
            0,
            1,
            2
        ],
        fc: 18
    },
    {
        lngs: [
            'mt'
        ],
        nr: [
            1,
            2,
            11,
            20
        ],
        fc: 19
    },
    {
        lngs: [
            'or'
        ],
        nr: [
            2,
            1
        ],
        fc: 2
    },
    {
        lngs: [
            'ro'
        ],
        nr: [
            1,
            2,
            20
        ],
        fc: 20
    },
    {
        lngs: [
            'sl'
        ],
        nr: [
            5,
            1,
            2,
            3
        ],
        fc: 21
    },
    {
        lngs: [
            'he',
            'iw'
        ],
        nr: [
            1,
            2,
            20,
            21
        ],
        fc: 22
    }
];
let _rulesPluralsTypes = {
    1: function(n) {
        return Number(n > 1);
    },
    2: function(n) {
        return Number(n != 1);
    },
    3: function(n) {
        return 0;
    },
    4: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    5: function(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
    },
    6: function(n) {
        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
    },
    7: function(n) {
        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    8: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
    },
    9: function(n) {
        return Number(n >= 2);
    },
    10: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
    },
    11: function(n) {
        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
    },
    12: function(n) {
        return Number(n % 10 != 1 || n % 100 == 11);
    },
    13: function(n) {
        return Number(n !== 0);
    },
    14: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
    },
    15: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    16: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
    },
    17: function(n) {
        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
    },
    18: function(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
    },
    19: function(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
    },
    20: function(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
    },
    21: function(n) {
        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
    },
    22: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
    }
};
const deprecatedJsonVersions = [
    'v1',
    'v2',
    'v3'
];
const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
};
function createRules() {
    const rules = {
    };
    sets.forEach((set)=>{
        set.lngs.forEach((l)=>{
            rules[l] = {
                numbers: set.nr,
                plurals: _rulesPluralsTypes[set.fc]
            };
        });
    });
    return rules;
}
class PluralResolver {
    constructor(languageUtils, options5 = {
    }){
        this.languageUtils = languageUtils;
        this.options = options5;
        this.logger = __default.create('pluralResolver');
        if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
            this.options.compatibilityJSON = 'v3';
            this.logger.error('Your environment seems not to be Inlt API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
        }
        this.rules = createRules();
    }
    addRule(lng, obj) {
        this.rules[lng] = obj;
    }
    getRule(code, options = {
    }) {
        if (this.shouldUseIntlApi()) {
            try {
                return new Intl.PluralRules(code, {
                    type: options.ordinal ? 'ordinal' : 'cardinal'
                });
            } catch  {
                return;
            }
        }
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
    needsPlural(code, options = {
    }) {
        const rule = this.getRule(code, options);
        if (this.shouldUseIntlApi()) {
            return rule && rule.resolvedOptions().pluralCategories.length > 1;
        }
        return rule && rule.numbers.length > 1;
    }
    getPluralFormsOfKey(code, key, options = {
    }) {
        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`
        );
    }
    getSuffixes(code, options = {
    }) {
        const rule = this.getRule(code, options);
        if (!rule) {
            return [];
        }
        if (this.shouldUseIntlApi()) {
            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]
            ).map((pluralCategory)=>`${this.options.prepend}${pluralCategory}`
            );
        }
        return rule.numbers.map((number)=>this.getSuffix(code, number, options)
        );
    }
    getSuffix(code, count, options = {
    }) {
        const rule = this.getRule(code, options);
        if (rule) {
            if (this.shouldUseIntlApi()) {
                return `${this.options.prepend}${rule.select(count)}`;
            }
            return this.getSuffixRetroCompatible(rule, count);
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return '';
    }
    getSuffixRetroCompatible(rule, count) {
        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        let suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
                suffix = 'plural';
            } else if (suffix === 1) {
                suffix = '';
            }
        }
        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString()
        ;
        if (this.options.compatibilityJSON === 'v1') {
            if (suffix === 1) return '';
            if (typeof suffix === 'number') return `_plural_${suffix.toString()}`;
            return returnSuffix();
        } else if (this.options.compatibilityJSON === 'v2') {
            return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
    shouldUseIntlApi() {
        return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
}
class Interpolator {
    constructor(options6 = {
    }){
        this.logger = __default.create('interpolator');
        this.options = options6;
        this.format = options6.interpolation && options6.interpolation.format || ((value)=>value
        );
        this.init(options6);
    }
    init(options = {
    }) {
        if (!options.interpolation) options.interpolation = {
            escapeValue: true
        };
        const iOpts = options.interpolation;
        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
        this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
        this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
        this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
        this.resetRegExp();
    }
    reset() {
        if (this.options) this.init(this.options);
    }
    resetRegExp() {
        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
        this.regexp = new RegExp(regexpStr, 'g');
        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
        this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
        this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
    interpolate(str, data, lng, options) {
        let match;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {
        };
        function regexSafe(val) {
            return val.replace(/\$/g, '$$$$');
        }
        const handleFormat = (key)=>{
            if (key.indexOf(this.formatSeparator) < 0) {
                const path = getPathWithDefaults(data, defaultData, key);
                return this.alwaysFormat ? this.format(path, undefined, lng, {
                    ...options,
                    ...data,
                    interpolationkey: key
                }) : path;
            }
            const p = key.split(this.formatSeparator);
            const k = p.shift().trim();
            const f = p.join(this.formatSeparator).trim();
            return this.format(getPathWithDefaults(data, defaultData, k), f, lng, {
                ...options,
                ...data,
                interpolationkey: k
            });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        const todos = [
            {
                regex: this.regexpUnescape,
                safeValue: (val)=>regexSafe(val)
            },
            {
                regex: this.regexp,
                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
            }, 
        ];
        todos.forEach((todo)=>{
            replaces = 0;
            while(match = todo.regex.exec(str)){
                value = handleFormat(match[1].trim());
                if (value === undefined) {
                    if (typeof missingInterpolationHandler === 'function') {
                        const temp = missingInterpolationHandler(str, match, options);
                        value = typeof temp === 'string' ? temp : '';
                    } else if (skipOnVariables) {
                        value = match[0];
                        continue;
                    } else {
                        this.logger.warn(`missed to pass in variable ${match[1]} for interpolating ${str}`);
                        value = '';
                    }
                } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
                    value = makeString(value);
                }
                const safeValue = todo.safeValue(value);
                str = str.replace(match[0], safeValue);
                if (skipOnVariables) {
                    todo.regex.lastIndex += safeValue.length;
                    todo.regex.lastIndex -= match[0].length;
                } else {
                    todo.regex.lastIndex = 0;
                }
                replaces++;
                if (replaces >= this.maxReplaces) {
                    break;
                }
            }
        });
        return str;
    }
    nest(str, fc, options = {
    }) {
        let match;
        let value;
        let clonedOptions = {
            ...options
        };
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        function handleHasOptions(key, inheritedOptions) {
            const sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0) return key;
            const c = key.split(new RegExp(`${sep}[ ]*{`));
            let optionsString = `{${c[1]}`;
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            optionsString = optionsString.replace(/'/g, '"');
            try {
                clonedOptions = JSON.parse(optionsString);
                if (inheritedOptions) clonedOptions = {
                    ...inheritedOptions,
                    ...clonedOptions
                };
            } catch (e) {
                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
                return `${key}${sep}${optionsString}`;
            }
            delete clonedOptions.defaultValue;
            return key;
        }
        while(match = this.nestingRegexp.exec(str)){
            let formatters = [];
            let doReduce = false;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim()
                );
                match[1] = r.shift();
                formatters = r;
                doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && typeof value !== 'string') return value;
            if (typeof value !== 'string') value = makeString(value);
            if (!value) {
                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
                value = '';
            }
            if (doReduce) {
                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {
                        ...options,
                        interpolationkey: match[1].trim()
                    })
                , value.trim());
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
        }
        return str;
    }
}
function remove(arr, what) {
    let found = arr.indexOf(what);
    while(found !== -1){
        arr.splice(found, 1);
        found = arr.indexOf(what);
    }
}
class Connector extends EventEmitter {
    constructor(backend, store, services1, options7 = {
    }){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.backend = backend;
        this.store = store;
        this.services = services1;
        this.languageUtils = services1.languageUtils;
        this.options = options7;
        this.logger = __default.create('backendConnector');
        this.state = {
        };
        this.queue = [];
        if (this.backend && this.backend.init) {
            this.backend.init(services1, options7.backend, options7);
        }
    }
    queueLoad(languages, namespaces, options, callback) {
        const toLoad = [];
        const pending = [];
        const toLoadLanguages = [];
        const toLoadNamespaces = [];
        languages.forEach((lng)=>{
            let hasAllNamespaces = true;
            namespaces.forEach((ns)=>{
                const name = `${lng}|${ns}`;
                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
                    this.state[name] = 2;
                } else if (this.state[name] < 0) {
                } else if (this.state[name] === 1) {
                    if (pending.indexOf(name) < 0) pending.push(name);
                } else {
                    this.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending.indexOf(name) < 0) pending.push(name);
                    if (toLoad.indexOf(name) < 0) toLoad.push(name);
                    if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
                }
            });
            if (!hasAllNamespaces) toLoadLanguages.push(lng);
        });
        if (toLoad.length || pending.length) {
            this.queue.push({
                pending,
                loaded: {
                },
                errors: [],
                callback
            });
        }
        return {
            toLoad,
            pending,
            toLoadLanguages,
            toLoadNamespaces
        };
    }
    loaded(name, err, data) {
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        if (err) this.emit('failedLoading', lng, ns, err);
        if (data) {
            this.store.addResourceBundle(lng, ns, data);
        }
        this.state[name] = err ? -1 : 2;
        const loaded = {
        };
        this.queue.forEach((q)=>{
            pushPath(q.loaded, [
                lng
            ], ns);
            remove(q.pending, name);
            if (err) q.errors.push(err);
            if (q.pending.length === 0 && !q.done) {
                Object.keys(q.loaded).forEach((l)=>{
                    if (!loaded[l]) loaded[l] = [];
                    if (q.loaded[l].length) {
                        q.loaded[l].forEach((ns)=>{
                            if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
                        });
                    }
                });
                q.done = true;
                if (q.errors.length) {
                    q.callback(q.errors);
                } else {
                    q.callback();
                }
            }
        });
        this.emit('loaded', loaded);
        this.queue = this.queue.filter((q)=>!q.done
        );
    }
    read(lng, ns, fcName, tried = 0, wait = 350, callback) {
        if (!lng.length) return callback(null, {
        });
        return this.backend[fcName](lng, ns, (err, data)=>{
            if (err && data && tried < 5) {
                setTimeout(()=>{
                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
                }, wait);
                return;
            }
            callback(err, data);
        });
    }
    prepareLoading(languages, namespaces, options = {
    }, callback) {
        if (!this.backend) {
            this.logger.warn('No backend was added via i18next.use. Will not load resources.');
            return callback && callback();
        }
        if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === 'string') namespaces = [
            namespaces
        ];
        const toLoad = this.queueLoad(languages, namespaces, options, callback);
        if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length) callback();
            return null;
        }
        toLoad.toLoad.forEach((name)=>{
            this.loadOne(name);
        });
    }
    load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
        }, callback);
    }
    reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
            reload: true
        }, callback);
    }
    loadOne(name, prefix = '') {
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        this.read(lng, ns, 'read', undefined, undefined, (err, data)=>{
            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
            this.loaded(name, err, data);
        });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {
    }) {
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
            return;
        }
        if (key === undefined || key === null || key === '') return;
        if (this.backend && this.backend.create) {
            this.backend.create(languages, namespace, key, fallbackValue, null, {
                ...options,
                isUpdate
            });
        }
        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
}
function get() {
    return {
        debug: false,
        initImmediate: true,
        ns: [
            'translation'
        ],
        defaultNS: [
            'translation'
        ],
        fallbackLng: [
            'dev'
        ],
        fallbackNS: false,
        supportedLngs: false,
        nonExplicitSupportedLngs: false,
        load: 'all',
        preload: false,
        simplifyPluralSuffix: true,
        keySeparator: '.',
        nsSeparator: ':',
        pluralSeparator: '_',
        contextSeparator: '_',
        partialBundledLanguages: false,
        saveMissing: false,
        updateMissing: false,
        saveMissingTo: 'fallback',
        saveMissingPlurals: true,
        missingKeyHandler: false,
        missingInterpolationHandler: false,
        postProcess: false,
        postProcessPassResolved: false,
        returnNull: true,
        returnEmptyString: true,
        returnObjects: false,
        joinArrays: false,
        returnedObjectHandler: false,
        parseMissingKeyHandler: false,
        appendNamespaceToMissingKey: false,
        appendNamespaceToCIMode: false,
        overloadTranslationOptionHandler: function handle(args) {
            var ret = {
            };
            if (typeof args[1] === 'object') ret = args[1];
            if (typeof args[1] === 'string') ret.defaultValue = args[1];
            if (typeof args[2] === 'string') ret.tDescription = args[2];
            if (typeof args[2] === 'object' || typeof args[3] === 'object') {
                var options = args[3] || args[2];
                Object.keys(options).forEach(function(key) {
                    ret[key] = options[key];
                });
            }
            return ret;
        },
        interpolation: {
            escapeValue: true,
            format: (value, format, lng, options)=>value
            ,
            prefix: '{{',
            suffix: '}}',
            formatSeparator: ',',
            unescapePrefix: '-',
            nestingPrefix: '$t(',
            nestingSuffix: ')',
            nestingOptionsSeparator: ',',
            maxReplaces: 1000,
            skipOnVariables: true
        }
    };
}
function transformOptions(options) {
    if (typeof options.ns === 'string') options.ns = [
        options.ns
    ];
    if (typeof options.fallbackLng === 'string') options.fallbackLng = [
        options.fallbackLng
    ];
    if (typeof options.fallbackNS === 'string') options.fallbackNS = [
        options.fallbackNS
    ];
    if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
        options.supportedLngs = options.supportedLngs.concat([
            'cimode'
        ]);
    }
    return options;
}
function noop() {
}
class I18n extends EventEmitter {
    constructor(options8 = {
    }, callback){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.options = transformOptions(options8);
        this.services = {
        };
        this.logger = __default;
        this.modules = {
            external: []
        };
        if (callback && !this.isInitialized && !options8.isClone) {
            if (!this.options.initImmediate) {
                this.init(options8, callback);
                return this;
            }
            setTimeout(()=>{
                this.init(options8, callback);
            }, 0);
        }
    }
    init(options = {
    }, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {
            };
        }
        if (!options.defaultNS && options.ns) {
            if (typeof options.ns === 'string') {
                options.defaultNS = options.ns;
            } else if (options.ns.indexOf('translation') < 0) {
                options.defaultNS = options.ns[0];
            }
        }
        this.options = {
            ...get(),
            ...this.options,
            ...transformOptions(options)
        };
        if (options.keySeparator !== undefined) {
            this.options.userDefinedKeySeparator = options.keySeparator;
        }
        this.format = this.options.interpolation.format;
        if (!callback) callback = noop;
        function createClassOnDemand(ClassOrObject) {
            if (!ClassOrObject) return null;
            if (typeof ClassOrObject === 'function') return new ClassOrObject();
            return ClassOrObject;
        }
        if (!this.options.isClone) {
            if (this.modules.logger) {
                __default.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
                __default.init(null, this.options);
            }
            const lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            const s = this.services;
            s.logger = __default;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            s.interpolator = new Interpolator(this.options);
            s.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on('*', (event, ...args)=>{
                this.emit(event, ...args);
            });
            if (this.modules.languageDetector) {
                s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                if (s.i18nFormat.init) s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on('*', (event, ...args)=>{
                this.emit(event, ...args);
            });
            this.modules.external.forEach((m)=>{
                if (m.init) m.init(this);
            });
        }
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn('init: no languageDetector is used and no lng is defined');
        }
        const storeApi = [
            'getResource',
            'hasResourceBundle',
            'getResourceBundle',
            'getDataByLanguage', 
        ];
        storeApi.forEach((fcName)=>{
            this[fcName] = (...args)=>this.store[fcName](...args)
            ;
        });
        const storeApiChained = [
            'addResource',
            'addResources',
            'addResourceBundle',
            'removeResourceBundle', 
        ];
        storeApiChained.forEach((fcName)=>{
            this[fcName] = (...args)=>{
                this.store[fcName](...args);
                return this;
            };
        });
        const deferred = defer();
        const load = ()=>{
            const finish = (err, t)=>{
                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
                this.isInitialized = true;
                if (!this.options.isClone) this.logger.log('initialized', this.options);
                this.emit('initialized', this.options);
                deferred.resolve(t);
                callback(err, t);
            };
            if (this.languages && this.options.compatibilityAPI !== 'v1' && !this.isInitialized) return finish(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initImmediate) {
            load();
        } else {
            setTimeout(load, 0);
        }
        return deferred;
    }
    loadResources(language, callback = noop) {
        let usedCallback = callback;
        let usedLng = typeof language === 'string' ? language : this.language;
        if (typeof language === 'function') usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
            const toLoad = [];
            const append = (lng)=>{
                if (!lng) return;
                const lngs = this.services.languageUtils.toResolveHierarchy(lng);
                lngs.forEach((l)=>{
                    if (toLoad.indexOf(l) < 0) toLoad.push(l);
                });
            };
            if (!usedLng) {
                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                fallbacks.forEach((l)=>append(l)
                );
            } else {
                append(usedLng);
            }
            if (this.options.preload) {
                this.options.preload.forEach((l)=>append(l)
                );
            }
            this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
        } else {
            usedCallback(null);
        }
    }
    reloadResources(lngs, ns, callback) {
        const deferred = defer();
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback) callback = noop;
        this.services.backendConnector.reload(lngs, ns, (err)=>{
            deferred.resolve();
            callback(err);
        });
        return deferred;
    }
    use(module) {
        if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
        if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
        if (module.type === 'backend') {
            this.modules.backend = module;
        }
        if (module.type === 'logger' || module.log && module.warn && module.error) {
            this.modules.logger = module;
        }
        if (module.type === 'languageDetector') {
            this.modules.languageDetector = module;
        }
        if (module.type === 'i18nFormat') {
            this.modules.i18nFormat = module;
        }
        if (module.type === 'postProcessor') {
            __default1.addPostProcessor(module);
        }
        if (module.type === '3rdParty') {
            this.modules.external.push(module);
        }
        return this;
    }
    changeLanguage(lng, callback) {
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit('languageChanging', lng);
        const setLngProps = (l)=>{
            this.language = l;
            this.languages = this.services.languageUtils.toResolveHierarchy(l);
            this.resolvedLanguage = undefined;
            if ([
                'cimode',
                'dev'
            ].indexOf(l) > -1) return;
            for(let li = 0; li < this.languages.length; li++){
                const lngInLngs = this.languages[li];
                if ([
                    'cimode',
                    'dev'
                ].indexOf(lngInLngs) > -1) continue;
                if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                    this.resolvedLanguage = lngInLngs;
                    break;
                }
            }
        };
        const done = (err, l)=>{
            if (l) {
                setLngProps(l);
                this.translator.changeLanguage(l);
                this.isLanguageChangingTo = undefined;
                this.emit('languageChanged', l);
                this.logger.log('languageChanged', l);
            } else {
                this.isLanguageChangingTo = undefined;
            }
            deferred.resolve((...args)=>this.t(...args)
            );
            if (callback) callback(err, (...args)=>this.t(...args)
            );
        };
        const setLng = (lngs)=>{
            if (!lng && !lngs && this.services.languageDetector) lngs = [];
            const l = typeof lngs === 'string' ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
            if (l) {
                if (!this.language) {
                    setLngProps(l);
                }
                if (!this.translator.language) this.translator.changeLanguage(l);
                if (this.services.languageDetector) this.services.languageDetector.cacheUserLanguage(l);
            }
            this.loadResources(l, (err)=>{
                done(err, l);
            });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            this.services.languageDetector.detect(setLng);
        } else {
            setLng(lng);
        }
        return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
        const fixedT = (key, opts, ...rest)=>{
            let options;
            if (typeof opts !== 'object') {
                options = this.options.overloadTranslationOptionHandler([
                    key,
                    opts
                ].concat(rest));
            } else {
                options = {
                    ...opts
                };
            }
            options.lng = options.lng || fixedT.lng;
            options.lngs = options.lngs || fixedT.lngs;
            options.ns = options.ns || fixedT.ns;
            const keySeparator = this.options.keySeparator || '.';
            const resultKey = keyPrefix ? `${keyPrefix}${keySeparator}${key}` : key;
            return this.t(resultKey, options);
        };
        if (typeof lng === 'string') {
            fixedT.lng = lng;
        } else {
            fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
    }
    t(...args) {
        return this.translator && this.translator.translate(...args);
    }
    exists(...args) {
        return this.translator && this.translator.exists(...args);
    }
    setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns, options = {
    }) {
        if (!this.isInitialized) {
            this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
            return false;
        }
        if (!this.languages || !this.languages.length) {
            this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
            return false;
        }
        const lng = this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === 'cimode') return true;
        const loadNotPending = (l, n)=>{
            const loadState = this.services.backendConnector.state[`${l}|${n}`];
            return loadState === -1 || loadState === 2;
        };
        if (options.precheck) {
            const preResult = options.precheck(this, loadNotPending);
            if (preResult !== undefined) return preResult;
        }
        if (this.hasResourceBundle(lng, ns)) return true;
        if (!this.services.backendConnector.backend) return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
        return false;
    }
    loadNamespaces(ns, callback) {
        const deferred = defer();
        if (!this.options.ns) {
            callback && callback();
            return Promise.resolve();
        }
        if (typeof ns === 'string') ns = [
            ns
        ];
        ns.forEach((n)=>{
            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
        });
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    loadLanguages(lngs, callback) {
        const deferred = defer();
        if (typeof lngs === 'string') lngs = [
            lngs
        ];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0
        );
        if (!newLngs.length) {
            if (callback) callback();
            return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    dir(lng) {
        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
        if (!lng) return 'rtl';
        const rtlLngs = [
            'ar',
            'shu',
            'sqr',
            'ssh',
            'xaa',
            'yhd',
            'yud',
            'aao',
            'abh',
            'abv',
            'acm',
            'acq',
            'acw',
            'acx',
            'acy',
            'adf',
            'ads',
            'aeb',
            'aec',
            'afb',
            'ajp',
            'apc',
            'apd',
            'arb',
            'arq',
            'ars',
            'ary',
            'arz',
            'auz',
            'avl',
            'ayh',
            'ayl',
            'ayn',
            'ayp',
            'bbz',
            'pga',
            'he',
            'iw',
            'ps',
            'pbt',
            'pbu',
            'pst',
            'prp',
            'prd',
            'ug',
            'ur',
            'ydd',
            'yds',
            'yih',
            'ji',
            'yi',
            'hbo',
            'men',
            'xmn',
            'fa',
            'jpr',
            'peo',
            'pes',
            'prs',
            'dv',
            'sam',
            'ckb'
        ];
        return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
    }
    createInstance(options = {
    }, callback) {
        return new I18n(options, callback);
    }
    cloneInstance(options = {
    }, callback = noop) {
        const mergedOptions = {
            ...this.options,
            ...options,
            ...{
                isClone: true
            }
        };
        const clone = new I18n(mergedOptions);
        const membersToCopy = [
            'store',
            'services',
            'language'
        ];
        membersToCopy.forEach((m)=>{
            clone[m] = this[m];
        });
        clone.services = {
            ...this.services
        };
        clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        clone.translator = new Translator(clone.services, clone.options);
        clone.translator.on('*', (event, ...args)=>{
            clone.emit(event, ...args);
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = clone.options;
        clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        return clone;
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        };
    }
}
const __default2 = new I18n();
const COMMENTS = /<!--[\s\S]*?-->/g;
const DECLARATION_OPEN = /^<[?]xml /;
const DECLARATION_CLOSE = /^[?]>/;
const DOCTYPE_OPEN = /^<!DOCTYPE /;
const DOCTYPE_ATTRIBUTES = /^(?<quote>["'])(?<value>[\s\S]+?)\k<quote>/;
const DOCTYPE_ATTRIBUTES_UNQUOTED = /^(?<value>[\w-:.]+)/;
const DOCTYPE_CLOSE = /^>/;
const DOCTYPE_ELEMENTS_OPEN = /^\[/;
const DOCTYPE_ELEMENT = /^<!ELEMENT (?<element>[\w-:.]+) (?<attributes>[^<]*?)>/;
const DOCTYPE_ELEMENTS_CLOSE = /^\]/;
const CDATA = /^<!\[CDATA\[(?<content>[\s\S]*?)]]>/m;
const TAG_OPEN = /^<(?<tag>[\w-:.]+)/;
const TAG_SELFCLOSE = /^(?<selfclosed>\/?)>/;
const TAG_CLOSE = (tag)=>new RegExp(`^<\/\\s*${tag}\\s*>`)
;
const TAG_ATTRIBUTES = /^(?<name>[\w:-]+)\s*=\s*(?<quote>["'])(?<value>[\s\S]+?)\k<quote>/;
const TAG_CONTENT = /^(?<content>[^<]*?)(?=<)/;
const ENTITIES = {
    "&lt;": "<",
    "&gt;": ">",
    "&apos;": "'",
    "&quot;": '"',
    "&amp;": "&"
};
const ENTITIES_DEC = /&#(?<code>\d+);/g;
const ENTITIES_HEX = /&#x(?<code>\d+);/g;
function parse3(xml, options = {
}) {
    return format3({
        xml: parseXML({
            xml
        }, options)
    }, options).xml;
}
function parseXML(document, { includeDeclaration =false , includeDoctype =false  }) {
    const parsed = {
    };
    document.xml = document.xml.trim().replace(COMMENTS, "");
    if (peek(document, DECLARATION_OPEN)) {
        consume(document, DECLARATION_OPEN);
        while(peek(document, TAG_ATTRIBUTES)){
            const { name , value  } = consume(document, TAG_ATTRIBUTES);
            if (includeDeclaration) {
                parsed[`@${name}`] = value;
            }
        }
        consume(document, DECLARATION_CLOSE);
    }
    if (peek(document, DOCTYPE_OPEN)) {
        consume(document, DOCTYPE_OPEN);
        if (includeDoctype) {
            parsed.$doctype = {
            };
        }
        while(peek(document, DOCTYPE_ATTRIBUTES) || peek(document, DOCTYPE_ATTRIBUTES_UNQUOTED)){
            const { value  } = peek(document, DOCTYPE_ATTRIBUTES) ? consume(document, DOCTYPE_ATTRIBUTES) : consume(document, DOCTYPE_ATTRIBUTES_UNQUOTED);
            if (includeDoctype) {
                parsed.$doctype[`@${value}`] = true;
            }
        }
        if (peek(document, DOCTYPE_ELEMENTS_OPEN)) {
            consume(document, DOCTYPE_ELEMENTS_OPEN);
            while(peek(document, DOCTYPE_ELEMENT)){
                const { element , attributes  } = consume(document, DOCTYPE_ELEMENT);
                if (includeDoctype) {
                    parsed.$doctype[element] = attributes;
                }
            }
            consume(document, DOCTYPE_ELEMENTS_CLOSE);
        }
        consume(document, DOCTYPE_CLOSE);
    }
    const { $tag: tag , ...properties } = parseNode(document);
    parsed[tag] = properties;
    if (peek(document, TAG_OPEN)) {
        throw new Error(`Failed to parse XML, multiple root nodes are not supported`);
    }
    return parsed;
}
function parseNode(document) {
    if (!peek(document, TAG_OPEN)) {
        return null;
    }
    const node = {
        $tag: consume(document, TAG_OPEN).tag,
        $: ""
    };
    while(peek(document, TAG_ATTRIBUTES)){
        const { name , value  } = consume(document, TAG_ATTRIBUTES);
        node[`@${name}`] = value;
    }
    if (consume(document, TAG_SELFCLOSE).selfclosed) {
        return node;
    }
    node.$ = parseText(document);
    if (!peek(document, TAG_CLOSE(node.$tag))) {
        while(true){
            parseText(document);
            const child = parseNode(document);
            if (!child) {
                break;
            }
            const { $tag: tag , ...properties } = child;
            node[tag] ??= [];
            node[tag].push(properties);
        }
    }
    consume(document, TAG_CLOSE(node.$tag));
    return node;
}
function parseText(document) {
    let content = "";
    while(true){
        content += consume(document, TAG_CONTENT).content;
        if (peek(document, CDATA)) {
            content += consume(document, CDATA).content;
            continue;
        }
        break;
    }
    return content.trim();
}
function peek(document, regex) {
    return regex.test(document.xml);
}
function consume(document, regex) {
    const matched = document.xml.match(regex);
    if (!matched) {
        throw new Error(`Failed to parse XML, expected token: ${regex.source} (got: ${document.xml.substring(0, 6)}...)`);
    }
    document.xml = document.xml.replace(regex, "").trimStart();
    return matched.groups ?? {
    };
}
function format3(result, options) {
    for (let [key, value] of Object.entries(result)){
        if (Array.isArray(value) && value.length === 1) {
            result[key] = value = value.shift();
        }
        if (typeof value === "object") {
            const node = value;
            const keys = Object.keys(node);
            if (keys.length === 1 && keys[0] === "$") {
                result[key] = revive(node.$, options);
                continue;
            }
            if (keys.filter((k)=>k.charAt(0) !== "@"
            ).length > 1) {
                delete value.$;
            }
            result[key] = format3(value, options);
        } else {
            result[key] = revive(value, options);
        }
    }
    return result;
}
function revive(value, { reviveBooleans =true , reviveNumbers =true , emptyToNull =true  }) {
    switch(true){
        case emptyToNull && /^\s*$/.test(value):
            return null;
        case reviveBooleans && /^(?:true|false)$/i.test(value):
            return /^true$/i.test(value);
        case reviveNumbers && Number.isFinite(Number(value)):
            return Number.parseFloat(value);
        default:
            value = value.replace(ENTITIES_DEC, (_, code)=>String.fromCharCode(parseInt(code, 10))
            ).replace(ENTITIES_HEX, (_, code)=>String.fromCharCode(parseInt(code, 16))
            );
            for(const entity in ENTITIES){
                value = value.replaceAll(entity, ENTITIES[entity]);
            }
            return value;
    }
}
const align = {
    right: alignRight,
    center: alignCenter
};
const right = 1;
const left = 3;
class UI {
    constructor(opts){
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg)=>{
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' && /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map((row)=>row.split('\t')
        );
        let leftColumnWidth = 0;
        rows.forEach((columns)=>{
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        rows.forEach((columns)=>{
            this.div(...columns.map((r, i)=>{
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [
            0,
            noAnsi.match(/\s*$/)[0].length,
            0,
            noAnsi.match(/^\s*/)[0].length
        ];
    }
    toString() {
        const lines = [];
        this.rows.forEach((row)=>{
            this.rowToString(row, lines);
        });
        return lines.filter((line)=>!line.hidden
        ).map((line)=>line.text
        ).join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r)=>{
            let str = '';
            rrow.forEach((col, c)=>{
                const { width  } = row[c];
                const wrapWidth = this.negatePadding(row[c]);
                let ts = col;
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                    }
                }
                const padding = row[c].padding || [
                    0,
                    0,
                    0,
                    0
                ];
                if (padding[3]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[1]) {
                    str += ' '.repeat(padding[right]);
                }
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c)=>{
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), {
                    hard: true
                }).split('\n');
            } else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[0] || 0).fill(''));
                wrapped.push(...new Array(col.padding[2] || 0).fill(''));
            }
            wrapped.forEach((str, r)=>{
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for(let i = 0; i < c; i++){
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map((col)=>{
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col)=>{
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i)=>{
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[3] || 0) + (padding[1] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat(width - strWidth >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}
const ansi = new RegExp('\x1b(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|' + '\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)', 'g');
function stripAnsi(str) {
    return str.replace(ansi, '');
}
function wrap(str, width) {
    const [start, end] = str.match(ansi) || [
        '',
        ''
    ];
    str = stripAnsi(str);
    let wrapped = '';
    for(let i = 0; i < str.length; i++){
        if (i !== 0 && i % width === 0) {
            wrapped += '\n';
        }
        wrapped += str.charAt(i);
    }
    if (start && end) {
        wrapped = `${start}${wrapped}${end}`;
    }
    return wrapped;
}
function ui(opts) {
    return cliui(opts, {
        stringWidth: (str)=>{
            return [
                ...str
            ].length;
        },
        stripAnsi,
        wrap
    });
}
function toItems(dir) {
    let list = [];
    for (let tmp of Deno.readDirSync(dir)){
        list.push(tmp.name);
    }
    return list;
}
function __default3(start, callback) {
    let dir = resolve2('.', start);
    let stats = Deno.statSync(dir);
    if (!stats.isDirectory) {
        dir = dirname2(dir);
    }
    while(true){
        let tmp = callback(dir, toItems(dir));
        if (tmp) return resolve2(dir, tmp);
        dir = dirname2(tmp = dir);
        if (tmp === dir) break;
    }
}
function camelCase(str) {
    str = str.toLocaleLowerCase();
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    } else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for(let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++){
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toLocaleUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
                continue;
            } else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLocaleLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for(let i = 0; i < str.length; i++){
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined) return false;
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    if (x.length > 1 && x[0] === '0') return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map((e)=>typeof e !== 'string' ? e + '' : e
        );
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for(let ii = 0; ii < argString.length; ii++){
        prevC = c;
        c = argString.charAt(ii);
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        if (c === opening) {
            opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i]) args[i] = '';
        args[i] += c;
    }
    return args;
}
let mixin1;
class YargsParser {
    constructor(_mixin){
        mixin1 = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        const args = tokenizeArgString(argsInput);
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin1.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            const assignment = Object.keys(opt).map(function(key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value])=>{
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value])=>{
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function(key) {
                    flags.configs[key] = true;
                });
            } else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value])=>{
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
            (flags.aliases[key] || []).forEach(function(alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), {
            _: []
        });
        const argvReturn = {
        };
        for(let i = 0; i < args.length; i++){
            const arg = args[i];
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            if (arg !== '--' && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
            } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        i = eatNargs(i, m[1], args, m[2]);
                    } else {
                        setArg(m[1], m[2]);
                    }
                }
            } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [
                        false
                    ] : false);
                }
            } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    } else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    } else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        } else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        } else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            } else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
            } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    } else {
                        setArg(key, defaultValue(key));
                    }
                }
            } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for(let j = 0; j < letters.length; j++){
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            i = eatArray(i, key, args, value);
                        } else if (checkAllAliases(key, flags.nargs) !== false) {
                            i = eatNargs(i, key, args, value);
                        } else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    } else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    } else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    } else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        } else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        } else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            } else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            } else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            } else {
                pushPositional(arg);
            }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function(key) {
            if (!hasKey(argv, key.split('.'))) setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter((key)=>key !== '--' && key.includes('-')
            ).forEach((key)=>{
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map((k)=>aliases[k]
            )).forEach((alias)=>{
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map((prop)=>camelCase(prop)
                    ).join('.')];
                }
                delete argv[alias];
            });
        }
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            } else {
                for(ii = i + 1; ii < args.length; ii++){
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;
                    else break;
                }
                if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for(ii = i + 1; ii < consumed + i + 1; ii++){
                setArg(key, args[ii]);
            }
            return i + consumed;
        }
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
                argsToSet.push(true);
            } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [
                        defVal
                    ];
                }
            } else {
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign));
                }
                for(let ii = i + 1; ii < args.length; ii++){
                    if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
                    i = ii;
                    argsToSet.push(processValue(key, next));
                }
            }
            if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function(prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function(x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function(x) {
                    let keyProperties = x.split('.');
                    const a = [].concat(splitKey);
                    a.shift();
                    keyProperties = keyProperties.concat(a);
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [
                    key
                ].concat(flags.aliases[key] || []);
                keys.forEach(function(key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get () {
                            return val;
                        },
                        set (value) {
                            val = typeof value === 'string' ? mixin1.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [
                    alias
                ];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val) {
            if (typeof val === 'string' && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
                val = val.substring(1, val.length - 1);
            }
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string') val = val === 'true';
            }
            let value = Array.isArray(val) ? val.map(function(v) {
                return maybeCoerceNumber(key, v);
            }) : maybeCoerceNumber(key, val);
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val)) value = val.map((val)=>{
                    return mixin1.normalize(val);
                });
                else value = mixin1.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_') return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
                if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
                    value = Number(value);
                }
            }
            return value;
        }
        function setConfig(argv) {
            const configLookup = Object.create(null);
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function(configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin1.resolve(mixin1.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            } catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        } else {
                            config = mixin1.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    } catch (ex) {
                        if (ex.name === 'PermissionDenied') error = ex;
                        else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function(key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    setConfigObject(value, fullKey);
                } else {
                    if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function(configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined') return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin1.env();
            Object.keys(env).forEach(function(envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    const keys = envVar.split('__').map(function(key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function(key) {
                if (!applied.has(key)) {
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            [].concat(flags.aliases[key] || [], key).forEach((ali)=>{
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        } catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key)=>{
                if (~key.indexOf('.')) return;
                if (typeof argv[key] === 'undefined') argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function(key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog) defaulted[key] = true;
                    (aliases[key] || []).forEach(function(x) {
                        if (hasKey(obj, x.split('.'))) return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation']) keys = [
                keys.join('.')
            ];
            keys.slice(0, -1).forEach(function(key) {
                o = o[key] || {
                };
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object') return false;
            else return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation']) keys = [
                keys.join('.')
            ];
            keys.slice(0, -1).forEach(function(key) {
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {
                    };
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    if (Array.isArray(o[key])) {
                        o[key].push({
                        });
                    } else {
                        o[key] = [
                            o[key],
                            {
                            }
                        ];
                    }
                    o = o[key][o[key].length - 1];
                } else {
                    o = o[key];
                }
            });
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            } else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [
                        o[key]
                    ]).concat([
                        value
                    ]);
                } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                } else {
                    o[key] = o[key].concat([
                        value
                    ]);
                }
            } else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [
                    value
                ];
            } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
                o[key] = [
                    o[key],
                    value
                ];
            } else {
                o[key] = value;
            }
        }
        function extendAliases(...args) {
            args.forEach(function(obj) {
                Object.keys(obj || {
                }).forEach(function(key) {
                    if (flags.aliases[key]) return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    flags.aliases[key].concat(key).forEach(function(x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].concat(key).forEach(function(x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function(x) {
                        flags.aliases[x] = [
                            key
                        ].concat(flags.aliases[key].filter(function(y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find((key)=>keys.includes(key)
            );
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map((k)=>flags[k]
            ));
            return toCheck.some(function(flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function(pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        function hasAllShortFlags(arg) {
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for(let j = 0; j < letters.length; j++){
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            if (arg.match(negative)) {
                return false;
            }
            if (hasAllShortFlags(arg)) {
                return false;
            }
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            const normalFlag = /^-+([^=]+?)$/;
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
                return defaults[key];
            } else {
                return defaultForType(guessType(key));
            }
        }
        function defaultForType(type) {
            const def = {
                boolean: true,
                string: '',
                number: undefined,
                array: []
            };
            return def[type];
        }
        function guessType(key) {
            let type = 'boolean';
            if (checkAllAliases(key, flags.strings)) type = 'string';
            else if (checkAllAliases(key, flags.numbers)) type = 'number';
            else if (checkAllAliases(key, flags.bools)) type = 'boolean';
            else if (checkAllAliases(key, flags.arrays)) type = 'array';
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        function checkConfiguration() {
            Object.keys(flags.counts).find((key)=>{
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                } else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({
            }, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({
            }, defaulted),
            error: error,
            newAliases: Object.assign({
            }, newAliases)
        };
    }
}
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    while(change){
        change = false;
        for(let i = 0; i < aliasArrays.length; i++){
            for(let ii = i + 1; ii < aliasArrays.length; ii++){
                const intersect = aliasArrays[i].filter(function(v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
    if (key === '__proto__') return '___proto___';
    return key;
}
const parser = new YargsParser({
    cwd: Deno.cwd,
    env: ()=>{
        Deno.env.toObject();
    },
    format: (str, arg)=>{
        return str.replace('%s', arg);
    },
    normalize: mod1.normalize,
    resolve: mod1.resolve,
    require: (path)=>{
        if (!path.match(/\.json$/)) {
            throw Error('only .json config files are supported in Deno');
        } else {
            return JSON.parse(Deno.readTextFileSync(path));
        }
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function(args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
let shim;
class Y18N {
    constructor(opts1){
        opts1 = opts1 || {
        };
        this.directory = opts1.directory || './locales';
        this.updateFiles = typeof opts1.updateFiles === 'boolean' ? opts1.updateFiles : true;
        this.locale = opts1.locale || 'en';
        this.fallbackToLanguage = typeof opts1.fallbackToLanguage === 'boolean' ? opts1.fallbackToLanguage : true;
        this.cache = {
        };
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === 'function') cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale]) this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        } else {
            cb();
        }
        return shim.format.apply(shim.format, [
            this.cache[this.locale][str] || str
        ].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === 'function') cb = args.pop();
        if (!this.cache[this.locale]) this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        } else {
            cb();
        }
        var values = [
            str
        ];
        if (~str.indexOf('%d')) values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale]) this._readLocaleFile();
        for(const key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function(part, i) {
            var arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [
            str
        ].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1) this._processWriteQueue();
    }
    _processWriteQueue() {
        var _this = this;
        var work = this.writeQueue[0];
        var directory = work.directory;
        var locale = work.locale;
        var cb = work.cb;
        var languageFile = this._resolveLocaleFile(directory, locale);
        var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function(err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0) _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        var localeLookup = {
        };
        var languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
        } catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT') localeLookup = {
            };
            else throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        var file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            var languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile)) file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim.exists(file);
    }
}
function y18n(opts, _shim) {
    shim = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {
}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {
}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {
}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format5, ...args1){
        this.format = format5;
        this.args = args1;
        this.haveSeen = new Array(args1.length);
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {
        }).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return fractional;
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        fractional = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        e = e.length == 1 ? "0" + e : e;
        const val = `${m[F.mantissa]}.${fractional}${upcase ? "E" : "e"}${m[F.esign]}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        const dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        fractional = this.roundFractionToPrecision(fractional, precision);
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 255).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {
            };
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
const __default4 = {
    fs: {
        readFileSync: (path)=>{
            try {
                return Deno.readTextFileSync(path);
            } catch (err) {
                err.code = 'ENOENT';
                throw err;
            }
        },
        writeFile: Deno.writeFile
    },
    format: sprintf,
    resolve: (base, p1, p2)=>{
        try {
            return mod1.resolve(base, p1, p2);
        } catch (err) {
        }
    },
    exists: (file)=>{
        try {
            return Deno.statSync(file).isFile;
        } catch (err) {
            return false;
        }
    }
};
const y18n1 = (opts)=>{
    return y18n(opts, __default4);
};
class YError extends Error {
    constructor(msg){
        super(msg || 'yargs error');
        this.name = 'YError';
        Error.captureStackTrace(this, YError);
    }
}
const importMeta = {
    url: "https://deno.land/x/yargs@v17.2.1-deno/lib/platform-shims/deno.ts",
    main: false
};
const REQUIRE_ERROR = 'require is not supported by ESM';
const REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM';
const argv = [
    'deno run',
    ...Deno.args
];
const __dirname = new URL('.', importMeta.url).pathname;
let cwd = '';
let env = {
};
try {
    env = Deno.env.toObject();
    cwd = Deno.cwd();
} catch (err1) {
    if (err1.name !== 'PermissionDenied') {
        throw err1;
    }
}
const path1 = {
    basename: basename2,
    dirname: dirname2,
    extname: extname2,
    relative: (p1, p2)=>{
        try {
            return mod1.relative(p1, p2);
        } catch (err) {
            if (err.name !== 'PermissionDenied') {
                throw err;
            }
            return p1;
        }
    },
    resolve: mod1.resolve
};
const __default5 = {
    assert: {
        notStrictEqual: assertNotEquals,
        strictEqual: assertStrictEquals
    },
    cliui: ui,
    findUp: __default3,
    getEnv: (key)=>{
        return env[key];
    },
    inspect: Deno.inspect,
    getCallerFile: ()=>undefined
    ,
    getProcessArgvBin: ()=>{
        return 'deno';
    },
    mainFilename: cwd,
    Parser: yargsParser,
    path: path1,
    process: {
        argv: ()=>argv
        ,
        cwd: ()=>cwd
        ,
        emitWarning: (warning, type)=>{
        },
        execPath: ()=>{
            try {
                return Deno.execPath();
            } catch (_err) {
                return 'deno';
            }
        },
        exit: Deno.exit,
        nextTick: window.queueMicrotask,
        stdColumns: 80 ?? null
    },
    readFileSync: Deno.readTextFileSync,
    require: ()=>{
        throw new YError(REQUIRE_ERROR);
    },
    requireDirectory: ()=>{
        throw new YError(REQUIRE_DIRECTORY_ERROR);
    },
    stringWidth: (str)=>{
        return [
            ...str
        ].length;
    },
    y18n: y18n1({
        directory: mod1.resolve(__dirname, '../../locales'),
        updateFiles: false
    })
};
function assertNotStrictEqual(actual, expected, shim, message) {
    shim.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim) {
    shim.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) {
    return Object.keys(object);
}
const completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
const completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
function isPromise(maybePromise) {
    return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === 'function';
}
function parseCommand(cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand) throw new Error(`No command found in: ${cmd}`);
    const parsedCommand = {
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: []
    };
    splitCommand.forEach((cmd, i)=>{
        let variadic = false;
        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;
        if (/^\[/.test(cmd)) {
            parsedCommand.optional.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic
            });
        } else {
            parsedCommand.demanded.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic
            });
        }
    });
    return parsedCommand;
}
const positionName = [
    'first',
    'second',
    'third',
    'fourth',
    'fifth',
    'sixth'
];
function argsert(arg1, arg2, arg3) {
    function parseArgs() {
        return typeof arg1 === 'object' ? [
            {
                demanded: [],
                optional: []
            },
            arg1,
            arg2
        ] : [
            parseCommand(`cmd ${arg1}`),
            arg2,
            arg3, 
        ];
    }
    try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while(args.length && args[args.length - 1] === undefined)args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach((demanded)=>{
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = demanded.cmd.filter((type)=>type === observedType || type === '*'
            );
            if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);
            position += 1;
        });
        parsed.optional.forEach((optional)=>{
            if (args.length === 0) return;
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = optional.cmd.filter((type)=>type === observedType || type === '*'
            );
            if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);
            position += 1;
        });
    } catch (err) {
        console.warn(err.stack);
    }
}
function guessType(arg) {
    if (Array.isArray(arg)) {
        return 'array';
    } else if (arg === null) {
        return 'null';
    }
    return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);
}
class GlobalMiddleware {
    constructor(yargs){
        this.globalMiddleware = [];
        this.frozens = [];
        this.yargs = yargs;
    }
    addMiddleware(callback, applyBeforeValidation, global = true, mutates = false) {
        argsert('<array|function> [boolean] [boolean] [boolean]', [
            callback,
            applyBeforeValidation,
            global
        ], arguments.length);
        if (Array.isArray(callback)) {
            for(let i = 0; i < callback.length; i++){
                if (typeof callback[i] !== 'function') {
                    throw Error('middleware must be a function');
                }
                const m = callback[i];
                m.applyBeforeValidation = applyBeforeValidation;
                m.global = global;
            }
            Array.prototype.push.apply(this.globalMiddleware, callback);
        } else if (typeof callback === 'function') {
            const m = callback;
            m.applyBeforeValidation = applyBeforeValidation;
            m.global = global;
            m.mutates = mutates;
            this.globalMiddleware.push(callback);
        }
        return this.yargs;
    }
    addCoerceMiddleware(callback, option) {
        const aliases = this.yargs.getAliases();
        this.globalMiddleware = this.globalMiddleware.filter((m)=>{
            const toCheck = [
                ...aliases[option] || [],
                option
            ];
            if (!m.option) return true;
            else return !toCheck.includes(m.option);
        });
        callback.option = option;
        return this.addMiddleware(callback, true, true, true);
    }
    getMiddleware() {
        return this.globalMiddleware;
    }
    freeze() {
        this.frozens.push([
            ...this.globalMiddleware
        ]);
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        if (frozen !== undefined) this.globalMiddleware = frozen;
    }
    reset() {
        this.globalMiddleware = this.globalMiddleware.filter((m)=>m.global
        );
    }
}
function commandMiddlewareFactory(commandMiddleware) {
    if (!commandMiddleware) return [];
    return commandMiddleware.map((middleware)=>{
        middleware.applyBeforeValidation = false;
        return middleware;
    });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
    return middlewares.reduce((acc, middleware)=>{
        if (middleware.applyBeforeValidation !== beforeValidation) {
            return acc;
        }
        if (middleware.mutates) {
            if (middleware.applied) return acc;
            middleware.applied = true;
        }
        if (isPromise(acc)) {
            return acc.then((initialObj)=>Promise.all([
                    initialObj,
                    middleware(initialObj, yargs), 
                ])
            ).then(([initialObj, middlewareObj])=>Object.assign(initialObj, middlewareObj)
            );
        } else {
            const result = middleware(acc, yargs);
            return isPromise(result) ? result.then((middlewareObj)=>Object.assign(acc, middlewareObj)
            ) : Object.assign(acc, result);
        }
    }, argv);
}
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err)=>{
    throw err;
}) {
    try {
        const result = isFunction(getResult) ? getResult() : getResult;
        return isPromise(result) ? result.then((result)=>resultHandler(result)
        ) : resultHandler(result);
    } catch (err) {
        return errorHandler(err);
    }
}
function isFunction(arg) {
    return typeof arg === 'function';
}
function whichModule(exported) {
    if (typeof require === 'undefined') return null;
    for(let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++){
        mod = require.cache[files[i]];
        if (mod.exports === exported) return mod;
    }
    return null;
}
function objFilter(original = {
}, filter = ()=>true
) {
    const obj = {
    };
    objectKeys(original).forEach((key)=>{
        if (filter(key, original[key])) {
            obj[key] = original[key];
        }
    });
    return obj;
}
function setBlocking(blocking) {
    if (typeof process === 'undefined') return;
    [
        process.stdout,
        process.stderr
    ].forEach((_stream)=>{
        const stream = _stream;
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
            stream._handle.setBlocking(blocking);
        }
    });
}
function isBoolean(fail) {
    return typeof fail === 'boolean';
}
function usage(yargs, shim) {
    const __ = shim.y18n.__;
    const self = {
    };
    const fails = [];
    self.failFn = function failFn(f) {
        fails.push(f);
    };
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
            return typeof arg1 === 'string' ? [
                true,
                arg1
            ] : [
                arg1,
                arg2
            ];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (fails.length) {
            for(let i = fails.length - 1; i >= 0; --i){
                const fail = fails[i];
                if (isBoolean(fail)) {
                    if (err) throw err;
                    else if (msg) throw Error(msg);
                } else {
                    fail(msg, err, self);
                }
            }
        } else {
            if (yargs.getExitProcess()) setBlocking(true);
            if (!failureOutput) {
                failureOutput = true;
                if (showHelpOnFail) {
                    yargs.showHelp('error');
                    logger.error();
                }
                if (msg || err) logger.error(msg || err);
                if (failMessage) {
                    if (msg || err) logger.error('');
                    logger.error(failMessage);
                }
            }
            err = err || new YError(msg);
            if (yargs.getExitProcess()) {
                return yargs.exit(1);
            } else if (yargs.getInternalMethods().hasParseCallback()) {
                return yargs.exit(1, err);
            } else {
                throw err;
            }
        }
    };
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description)=>{
        if (msg === null) {
            usageDisabled = true;
            usages = [];
            return self;
        }
        usageDisabled = false;
        usages.push([
            msg,
            description || ''
        ]);
        return self;
    };
    self.getUsage = ()=>{
        return usages;
    };
    self.getUsageDisabled = ()=>{
        return usageDisabled;
    };
    self.getPositionalGroupName = ()=>{
        return __('Positionals:');
    };
    let examples = [];
    self.example = (cmd, description)=>{
        examples.push([
            cmd,
            description || ''
        ]);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
            commands = commands.map((cmdArray)=>{
                cmdArray[2] = false;
                return cmdArray;
            });
        }
        commands.push([
            cmd,
            description || '',
            isDefault,
            aliases,
            deprecated
        ]);
    };
    self.getCommands = ()=>commands
    ;
    let descriptions = {
    };
    self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
            keyOrKeys.forEach((k)=>{
                self.describe(k, desc);
            });
        } else if (typeof keyOrKeys === 'object') {
            Object.keys(keyOrKeys).forEach((k)=>{
                self.describe(k, keyOrKeys[k]);
            });
        } else {
            descriptions[keyOrKeys] = desc;
        }
    };
    self.getDescriptions = ()=>descriptions
    ;
    let epilogs = [];
    self.epilog = (msg)=>{
        epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = (cols)=>{
        wrapSet = true;
        wrap = cols;
    };
    function getWrap() {
        if (!wrapSet) {
            wrap = windowWidth();
            wrapSet = true;
        }
        return wrap;
    }
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = (str)=>deferY18nLookupPrefix + str
    ;
    self.help = function help() {
        if (cachedHelpMessage) return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName ? yargs.$0 : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key)=>{
            if (key !== '_') acc[key] = true;
            return acc;
        }, {
        }));
        const theWrap = getWrap();
        const ui = shim.cliui({
            width: theWrap,
            wrap: !!theWrap
        });
        if (!usageDisabled) {
            if (usages.length) {
                usages.forEach((usage)=>{
                    ui.div({
                        text: `${usage[0].replace(/\$0/g, base$0)}`
                    });
                    if (usage[1]) {
                        ui.div({
                            text: `${usage[1]}`,
                            padding: [
                                1,
                                0,
                                0,
                                0
                            ]
                        });
                    }
                });
                ui.div();
            } else if (commands.length) {
                let u = null;
                if (demandedCommands._) {
                    u = `${base$0} <${__('command')}>\n`;
                } else {
                    u = `${base$0} [${__('command')}]\n`;
                }
                ui.div(`${u}`);
            }
        }
        if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
            ui.div(__('Commands:'));
            const context = yargs.getInternalMethods().getContext();
            const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';
            if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] === true) {
                commands = commands.sort((a, b)=>a[0].localeCompare(b[0])
                );
            }
            const prefix = base$0 ? `${base$0} ` : '';
            commands.forEach((command)=>{
                const commandString = `${prefix}${parentCommands}${command[0].replace(/^\$0 ?/, '')}`;
                ui.span({
                    text: commandString,
                    padding: [
                        0,
                        2,
                        0,
                        2
                    ],
                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
                }, {
                    text: command[1]
                });
                const hints = [];
                if (command[2]) hints.push(`[${__('default')}]`);
                if (command[3] && command[3].length) {
                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);
                }
                if (command[4]) {
                    if (typeof command[4] === 'string') {
                        hints.push(`[${__('deprecated: %s', command[4])}]`);
                    } else {
                        hints.push(`[${__('deprecated')}]`);
                    }
                }
                if (hints.length) {
                    ui.div({
                        text: hints.join(' '),
                        padding: [
                            0,
                            0,
                            0,
                            2
                        ],
                        align: 'right'
                    });
                } else {
                    ui.div();
                }
            });
            ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter((key)=>!yargs.parsed.newAliases[key] && aliasKeys.every((alias)=>(options.alias[alias] || []).indexOf(key) === -1
            )
        );
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup]) groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw)=>/^--/.test(getText(sw))
        ;
        const displayedGroups = Object.keys(groups).filter((groupName)=>groups[groupName].length > 0
        ).map((groupName)=>{
            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key)=>{
                if (aliasKeys.includes(key)) return key;
                for(let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++){
                    if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
                }
                return key;
            });
            return {
                groupName,
                normalizedKeys
            };
        }).filter(({ normalizedKeys  })=>normalizedKeys.length > 0
        ).map(({ groupName , normalizedKeys  })=>{
            const switches = normalizedKeys.reduce((acc, key)=>{
                acc[key] = [
                    key
                ].concat(options.alias[key] || []).map((sw)=>{
                    if (groupName === self.getPositionalGroupName()) return sw;
                    else {
                        return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;
                    }
                }).sort((sw1, sw2)=>isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1
                ).join(', ');
                return acc;
            }, {
            });
            return {
                groupName,
                normalizedKeys,
                switches
            };
        });
        const shortSwitchesUsed = displayedGroups.filter(({ groupName  })=>groupName !== self.getPositionalGroupName()
        ).some(({ normalizedKeys , switches  })=>!normalizedKeys.every((key)=>isLongSwitch(switches[key])
            )
        );
        if (shortSwitchesUsed) {
            displayedGroups.filter(({ groupName  })=>groupName !== self.getPositionalGroupName()
            ).forEach(({ normalizedKeys , switches  })=>{
                normalizedKeys.forEach((key)=>{
                    if (isLongSwitch(switches[key])) {
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                    }
                });
            });
        }
        displayedGroups.forEach(({ groupName , normalizedKeys , switches  })=>{
            ui.div(groupName);
            normalizedKeys.forEach((key)=>{
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (desc.includes(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (options.boolean.includes(key)) type = `[${__('boolean')}]`;
                if (options.count.includes(key)) type = `[${__('count')}]`;
                if (options.string.includes(key)) type = `[${__('string')}]`;
                if (options.normalize.includes(key)) type = `[${__('string')}]`;
                if (options.array.includes(key)) type = `[${__('array')}]`;
                if (options.number.includes(key)) type = `[${__('number')}]`;
                const deprecatedExtra = (deprecated)=>typeof deprecated === 'string' ? `[${__('deprecated: %s', deprecated)}]` : `[${__('deprecated')}]`
                ;
                const extra = [
                    key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
                    type,
                    key in demandedOptions ? `[${__('required')}]` : null,
                    options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,
                    defaultString(options.default[key], options.defaultDescription[key]), 
                ].filter(Boolean).join(' ');
                ui.span({
                    text: getText(kswitch),
                    padding: [
                        0,
                        2,
                        0,
                        2 + getIndentation(kswitch)
                    ],
                    width: maxWidth(switches, theWrap) + 4
                }, desc);
                if (extra) ui.div({
                    text: extra,
                    padding: [
                        0,
                        0,
                        0,
                        2
                    ],
                    align: 'right'
                });
                else ui.div();
            });
            ui.div();
        });
        if (examples.length) {
            ui.div(__('Examples:'));
            examples.forEach((example)=>{
                example[0] = example[0].replace(/\$0/g, base$0);
            });
            examples.forEach((example)=>{
                if (example[1] === '') {
                    ui.div({
                        text: example[0],
                        padding: [
                            0,
                            2,
                            0,
                            2
                        ]
                    });
                } else {
                    ui.div({
                        text: example[0],
                        padding: [
                            0,
                            2,
                            0,
                            2
                        ],
                        width: maxWidth(examples, theWrap) + 4
                    }, {
                        text: example[1]
                    });
                }
            });
            ui.div();
        }
        if (epilogs.length > 0) {
            const e = epilogs.map((epilog)=>epilog.replace(/\$0/g, base$0)
            ).join('\n');
            ui.div(`${e}\n`);
        }
        return ui.toString().replace(/\s*$/, '');
    };
    function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
            table = Object.values(table).map((v)=>[
                    v
                ]
            );
        }
        table.forEach((v)=>{
            width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
    }
    function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach((key)=>{
            options.alias[key].forEach((alias)=>{
                if (descriptions[alias]) self.describe(key, descriptions[alias]);
                if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
                if (options.boolean.includes(alias)) yargs.boolean(key);
                if (options.count.includes(alias)) yargs.count(key);
                if (options.string.includes(alias)) yargs.string(key);
                if (options.normalize.includes(alias)) yargs.normalize(key);
                if (options.array.includes(alias)) yargs.array(key);
                if (options.number.includes(alias)) yargs.number(key);
            });
        });
    }
    let cachedHelpMessage;
    self.cacheHelpMessage = function() {
        cachedHelpMessage = this.help();
    };
    self.clearCachedHelpMessage = function() {
        cachedHelpMessage = undefined;
    };
    self.hasCachedHelpMessage = function() {
        return !!cachedHelpMessage;
    };
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group)=>{
            groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key)=>{
            toCheck = [
                key
            ].concat(aliases[key]);
            if (!toCheck.some((k)=>groupedKeys.indexOf(k) !== -1
            )) {
                groups[defaultGroup].push(key);
            }
        });
        return groupedKeys;
    }
    function filterHiddenOptions(key) {
        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
    }
    self.showHelp = (level)=>{
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level) level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
    };
    self.functionDescription = (fn)=>{
        const description = fn.name ? shim.Parser.decamelize(fn.name, '-') : __('generated-value');
        return [
            '(',
            description,
            ')'
        ].join('');
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length) return string;
        array.forEach((value)=>{
            if (string.length) string += sep;
            string += JSON.stringify(value);
        });
        return string;
    };
    function defaultString(value, defaultDescription) {
        let string = `[${__('default:')} `;
        if (value === undefined && !defaultDescription) return null;
        if (defaultDescription) {
            string += defaultDescription;
        } else {
            switch(typeof value){
                case 'string':
                    string += `"${value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
            }
        }
        return `${string}]`;
    }
    function windowWidth() {
        const maxWidth = 80;
        if (shim.process.stdColumns) {
            return Math.min(80, shim.process.stdColumns);
        } else {
            return 80;
        }
    }
    let version = null;
    self.version = (ver)=>{
        version = ver;
    };
    self.showVersion = (level)=>{
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level) level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(version);
    };
    self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, (k)=>!localLookup[k]
        );
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        if (!frozen) return;
        ({ failMessage , failureOutput , usages , usageDisabled , epilogs , examples , commands , descriptions ,  } = frozen);
    };
    return self;
}
function isIndentedText(text) {
    return typeof text === 'object';
}
function addIndentation(text, indent) {
    return isIndentedText(text) ? {
        text: text.text,
        indentation: text.indentation + indent
    } : {
        text,
        indentation: indent
    };
}
function getIndentation(text) {
    return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
    return isIndentedText(text) ? text.text : text;
}
function levenshtein(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    const matrix = [];
    let i;
    for(i = 0; i <= b.length; i++){
        matrix[i] = [
            i
        ];
    }
    let j;
    for(j = 0; j <= a.length; j++){
        matrix[0][j] = j;
    }
    for(i = 1; i <= b.length; i++){
        for(j = 1; j <= a.length; j++){
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
                    matrix[i][j] = matrix[i - 2][j - 2] + 1;
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                }
            }
        }
    }
    return matrix[b.length][a.length];
}
const specialKeys = [
    '$0',
    '--',
    '_'
];
function validation(yargs, usage, shim) {
    const __ = shim.y18n.__;
    const __n = shim.y18n.__n;
    const self = {
    };
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
            if (_s < demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
                } else {
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                }
            } else if (_s > demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
                } else {
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
        }
    };
    self.requiredArguments = function requiredArguments(argv, demandedOptions) {
        let missing = null;
        for (const key of Object.keys(demandedOptions)){
            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {
                missing = missing || {
                };
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key of Object.keys(missing)){
                const msg = missing[key];
                if (msg && customMsgs.indexOf(msg) < 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        var _a;
        const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        Object.keys(argv).forEach((key)=>{
            if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach((key)=>{
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (checkPositionals) {
            const demandedCommands = yargs.getDemandedCommands();
            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
            const expected = currentContext.commands.length + maxNonOptDemanded;
            if (expected < argv._.length) {
                argv._.slice(expected).forEach((key)=>{
                    key = String(key);
                    if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
                        unknown.push(key);
                    }
                });
            }
        }
        if (unknown.length) {
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
            argv._.slice(currentContext.commands.length).forEach((key)=>{
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
        } else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        return [
            key,
            ...aliases[key]
        ].some((a)=>!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]
        );
    };
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {
        };
        if (!Object.keys(options.choices).length) return;
        Object.keys(argv).forEach((key)=>{
            if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach((value)=>{
                    if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length) return;
        let msg = __('Invalid values:');
        invalidKeys.forEach((key)=>{
            msg += `\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    let implied = {
    };
    self.implies = function implies(key, value) {
        argsert('<string|object> [array|number|string]', [
            key,
            value
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                self.implies(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i)=>self.implies(key, i)
                );
            } else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') {
            val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !Object.prototype.hasOwnProperty.call(argv, val);
        } else {
            val = Object.prototype.hasOwnProperty.call(argv, val);
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key)=>{
            const origKey = key;
            (implied[key] || []).forEach((value)=>{
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) {
                    implyFail.push(` ${origKey} -> ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__('Implications failed:')}\n`;
            implyFail.forEach((value)=>{
                msg += value;
            });
            usage.fail(msg);
        }
    };
    let conflicting = {
    };
    self.conflicts = function conflicts(key, value) {
        argsert('<string|object> [array|string]', [
            key,
            value
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                self.conflicts(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i)=>self.conflicts(key, i)
                );
            } else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = ()=>conflicting
    ;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key)=>{
            if (conflicting[key]) {
                conflicting[key].forEach((value)=>{
                    if (value && argv[key] !== undefined && argv[value] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            }
        });
        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {
            Object.keys(conflicting).forEach((key)=>{
                conflicting[key].forEach((value)=>{
                    if (value && argv[shim.Parser.camelCase(key)] !== undefined && argv[shim.Parser.camelCase(value)] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            });
        }
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b)=>b.length - a.length
        );
        let recommended = null;
        let bestDistance = Infinity;
        for(let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++){
            const d = levenshtein(cmd, candidate);
            if (d <= threshold && d < bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended) usage.fail(__('Did you mean %s?', recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, (k)=>!localLookup[k]
        );
        conflicting = objFilter(conflicting, (k)=>!localLookup[k]
        );
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            conflicting
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ implied , conflicting  } = frozen);
    };
    return self;
}
let previouslyVisitedConfigs = [];
let shim1;
function applyExtends(config, cwd, mergeExtends, _shim) {
    shim1 = _shim;
    let defaultConfig = {
    };
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
        if (typeof config.extends !== 'string') return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
            try {
                pathToDefault = require.resolve(config.extends);
            } catch (_err) {
                return config;
            }
        } else {
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath ? JSON.parse(shim1.readFileSync(pathToDefault, 'utf8')) : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim1.path.dirname(pathToDefault), mergeExtends, shim1);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({
    }, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
    }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
    return shim1.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
    const target = {
    };
    function isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)){
        if (isObject(config2[key]) && isObject(target[key])) {
            target[key] = mergeDeep(config1[key], config2[key]);
        } else {
            target[key] = config2[key];
        }
    }
    return target;
}
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
const DEFAULT_MARKER = /(^\*)|(^\$0)/;
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command, _YargsInstance_cwd, _YargsInstance_context, _YargsInstance_completion, _YargsInstance_completionCommand, _YargsInstance_defaultShowHiddenOpt, _YargsInstance_exitError, _YargsInstance_detectLocale, _YargsInstance_emittedWarnings, _YargsInstance_exitProcess, _YargsInstance_frozens, _YargsInstance_globalMiddleware, _YargsInstance_groups, _YargsInstance_hasOutput, _YargsInstance_helpOpt, _YargsInstance_logger, _YargsInstance_output, _YargsInstance_options, _YargsInstance_parentRequire, _YargsInstance_parserConfig, _YargsInstance_parseFn, _YargsInstance_parseContext, _YargsInstance_pkgs, _YargsInstance_preservedGroups, _YargsInstance_processArgs, _YargsInstance_recommendCommands, _YargsInstance_shim, _YargsInstance_strict, _YargsInstance_strictCommands, _YargsInstance_strictOptions, _YargsInstance_usage, _YargsInstance_versionOpt, _YargsInstance_validation;
function YargsFactory(_shim) {
    return (processArgs = [], cwd = _shim.process.cwd(), parentRequire)=>{
        const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
        Object.defineProperty(yargs, 'argv', {
            get: ()=>{
                return yargs.parse();
            },
            enumerable: true
        });
        yargs.help();
        yargs.version();
        return yargs;
    };
}
const kCopyDoubleDash = Symbol('copyDoubleDash');
const kCreateLogger = Symbol('copyDoubleDash');
const kDeleteFromParserHintObject = Symbol('deleteFromParserHintObject');
const kEmitWarning = Symbol('emitWarning');
const kFreeze = Symbol('freeze');
const kGetDollarZero = Symbol('getDollarZero');
const kGetParserConfiguration = Symbol('getParserConfiguration');
const kGuessLocale = Symbol('guessLocale');
const kGuessVersion = Symbol('guessVersion');
const kParsePositionalNumbers = Symbol('parsePositionalNumbers');
const kPkgUp = Symbol('pkgUp');
const kPopulateParserHintArray = Symbol('populateParserHintArray');
const kPopulateParserHintSingleValueDictionary = Symbol('populateParserHintSingleValueDictionary');
const kPopulateParserHintArrayDictionary = Symbol('populateParserHintArrayDictionary');
const kPopulateParserHintDictionary = Symbol('populateParserHintDictionary');
const kSanitizeKey = Symbol('sanitizeKey');
const kSetKey = Symbol('setKey');
const kUnfreeze = Symbol('unfreeze');
const kValidateAsync = Symbol('validateAsync');
const kGetCommandInstance = Symbol('getCommandInstance');
const kGetContext = Symbol('getContext');
const kGetHasOutput = Symbol('getHasOutput');
const kGetLoggerInstance = Symbol('getLoggerInstance');
const kGetParseContext = Symbol('getParseContext');
const kGetUsageInstance = Symbol('getUsageInstance');
const kGetValidationInstance = Symbol('getValidationInstance');
const kHasParseCallback = Symbol('hasParseCallback');
const kPostProcess = Symbol('postProcess');
const kRebase = Symbol('rebase');
const kReset = Symbol('reset');
const kRunYargsParserAndExecuteCommands = Symbol('runYargsParserAndExecuteCommands');
const kRunValidation = Symbol('runValidation');
const kSetHasOutput = Symbol('setHasOutput');
const kTrackManuallySetKeys = Symbol('kTrackManuallySetKeys');
function isYargsInstance(y) {
    return !!y && typeof y.getInternalMethods === 'function';
}
class CommandInstance {
    constructor(usage1, validation1, globalMiddleware, shim2){
        this.requireCache = new Set();
        this.handlers = {
        };
        this.aliasMap = {
        };
        this.frozens = [];
        this.shim = shim2;
        this.usage = usage1;
        this.globalMiddleware = globalMiddleware;
        this.validation = validation1;
    }
    addDirectory(dir, req, callerFile, opts) {
        opts = opts || {
        };
        if (typeof opts.recurse !== 'boolean') opts.recurse = false;
        if (!Array.isArray(opts.extensions)) opts.extensions = [
            'js'
        ];
        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o)=>o
        ;
        opts.visit = (obj, joined, filename)=>{
            const visited = parentVisit(obj, joined, filename);
            if (visited) {
                if (this.requireCache.has(joined)) return visited;
                else this.requireCache.add(joined);
                this.addHandler(visited);
            }
            return visited;
        };
        this.shim.requireDirectory({
            require: req,
            filename: callerFile
        }, dir, opts);
    }
    addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (()=>{
        });
        if (Array.isArray(cmd)) {
            if (isCommandAndAliases(cmd)) {
                [cmd, ...aliases] = cmd;
            } else {
                for (const command of cmd){
                    this.addHandler(command);
                }
            }
        } else if (isCommandHandlerDefinition(cmd)) {
            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : this.moduleName(cmd);
            if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);
            this.addHandler(command, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
        } else if (isCommandBuilderDefinition(builder)) {
            this.addHandler([
                cmd
            ].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
        }
        if (typeof cmd === 'string') {
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map((alias)=>parseCommand(alias).cmd
            );
            let isDefault = false;
            const parsedAliases = [
                parsedCommand.cmd
            ].concat(aliases).filter((c)=>{
                if (DEFAULT_MARKER.test(c)) {
                    isDefault = true;
                    return false;
                }
                return true;
            });
            if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');
            if (isDefault) {
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
            }
            aliases.forEach((alias)=>{
                this.aliasMap[alias] = parsedCommand.cmd;
            });
            if (description !== false) {
                this.usage.command(cmd, description, isDefault, aliases, deprecated);
            }
            this.handlers[parsedCommand.cmd] = {
                original: cmd,
                description,
                handler,
                builder: builder || {
                },
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional
            };
            if (isDefault) this.defaultCommand = this.handlers[parsedCommand.cmd];
        }
    }
    getCommandHandlers() {
        return this.handlers;
    }
    getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
    }
    hasDefaultCommand() {
        return !!this.defaultCommand;
    }
    runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
        const commandHandler = this.handlers[command] || this.handlers[this.aliasMap[command]] || this.defaultCommand;
        const currentContext = yargs.getInternalMethods().getContext();
        const parentCommands = currentContext.commands.slice();
        const isDefaultCommand = !command;
        if (command) {
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
        }
        const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
        return isPromise(builderResult) ? builderResult.then((result)=>this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)
        ) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
    }
    applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
        const builder = commandHandler.builder;
        let innerYargs = yargs;
        if (isCommandBuilderCallback(builder)) {
            const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
            if (isPromise(builderOutput)) {
                return builderOutput.then((output)=>{
                    innerYargs = isYargsInstance(output) ? output : yargs;
                    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
                });
            }
        } else if (isCommandBuilderOptionDefinitions(builder)) {
            innerYargs = yargs.getInternalMethods().reset(aliases);
            Object.keys(commandHandler.builder).forEach((key)=>{
                innerYargs.option(key, builder[key]);
            });
        }
        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
    }
    parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
        if (isDefaultCommand) innerYargs.getInternalMethods().getUsageInstance().unfreeze();
        if (this.shouldUpdateUsage(innerYargs)) {
            innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
        return isPromise(innerArgv) ? innerArgv.then((argv)=>({
                aliases: innerYargs.parsed.aliases,
                innerArgv: argv
            })
        ) : {
            aliases: innerYargs.parsed.aliases,
            innerArgv: innerArgv
        };
    }
    shouldUpdateUsage(yargs) {
        return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
    }
    usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
        const pc = parentCommands.filter((c)=>{
            return !DEFAULT_MARKER.test(c);
        });
        pc.push(c);
        return `$0 ${pc.join(' ')}`;
    }
    applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
        let positionalMap = {
        };
        if (helpOnly) return innerArgv;
        if (!yargs.getInternalMethods().getHasOutput()) {
            positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
        }
        const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
        innerArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
        if (!yargs.getInternalMethods().getHasOutput()) {
            const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
            innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                validation(result);
                return result;
            });
        }
        if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
            yargs.getInternalMethods().setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                const handlerResult = commandHandler.handler(result);
                return isPromise(handlerResult) ? handlerResult.then(()=>result
                ) : result;
            });
            if (!isDefaultCommand) {
                yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
            }
            if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
                innerArgv.catch((error)=>{
                    try {
                        yargs.getInternalMethods().getUsageInstance().fail(null, error);
                    } catch (_err) {
                    }
                });
            }
        }
        if (!isDefaultCommand) {
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
        }
        return innerArgv;
    }
    populatePositionals(commandHandler, argv, context, yargs) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {
        };
        this.validation.positionalCount(demanded.length, argv._.length);
        while(demanded.length){
            const demand = demanded.shift();
            this.populatePositional(demand, argv, positionalMap);
        }
        while(optional.length){
            const maybe = optional.shift();
            this.populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map((a)=>'' + a
        ));
        this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
        return positionalMap;
    }
    populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
            positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
            if (argv._.length) positionalMap[cmd] = [
                String(argv._.shift())
            ];
        }
    }
    cmdToParseOptions(cmdString) {
        const parseOptions = {
            array: [],
            default: {
            },
            alias: {
            },
            demand: {
            }
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach((d)=>{
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o)=>{
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
    }
    postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
        const options = Object.assign({
        }, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)){
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {
        };
        const unparsed = [];
        Object.keys(positionalMap).forEach((key)=>{
            positionalMap[key].map((value)=>{
                if (options.configuration['unknown-options-as-args']) options.key[key] = true;
                unparsed.push(`--${key}`);
                unparsed.push(value);
            });
        });
        if (!unparsed.length) return;
        const config = Object.assign({
        }, options.configuration, {
            'populate--': false
        });
        const parsed = this.shim.Parser.detailed(unparsed, Object.assign({
        }, options, {
            configuration: config
        }));
        if (parsed.error) {
            yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach((key)=>{
                positionalKeys.push(...parsed.aliases[key]);
            });
            const defaults = yargs.getOptions().default;
            Object.keys(parsed.argv).forEach((key)=>{
                if (positionalKeys.includes(key)) {
                    if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
                    if (!Object.prototype.hasOwnProperty.call(defaults, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
                        argv[key] = [].concat(argv[key], parsed.argv[key]);
                    } else {
                        argv[key] = parsed.argv[key];
                    }
                }
            });
        }
    }
    runDefaultBuilderOn(yargs) {
        if (!this.defaultCommand) return;
        if (this.shouldUpdateUsage(yargs)) {
            const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
        }
        const builder = this.defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
            return builder(yargs, true);
        } else if (!isCommandBuilderDefinition(builder)) {
            Object.keys(builder).forEach((key)=>{
                yargs.option(key, builder[key]);
            });
        }
        return undefined;
    }
    moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod) throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
        return this.commandFromFilename(mod.filename);
    }
    commandFromFilename(filename) {
        return this.shim.path.basename(filename, this.shim.path.extname(filename));
    }
    extractDesc({ describe , description , desc  }) {
        for (const test of [
            describe,
            description,
            desc
        ]){
            if (typeof test === 'string' || test === false) return test;
            assertNotStrictEqual(test, true, this.shim);
        }
        return false;
    }
    freeze() {
        this.frozens.push({
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand
        });
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        assertNotStrictEqual(frozen, undefined, this.shim);
        ({ handlers: this.handlers , aliasMap: this.aliasMap , defaultCommand: this.defaultCommand ,  } = frozen);
    }
    reset() {
        this.handlers = {
        };
        this.aliasMap = {
        };
        this.defaultCommand = undefined;
        this.requireCache = new Set();
        return this;
    }
}
function command(usage, validation, globalMiddleware, shim) {
    return new CommandInstance(usage, validation, globalMiddleware, shim);
}
function isCommandBuilderDefinition(builder) {
    return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';
}
function isCommandAndAliases(cmd) {
    return cmd.every((c)=>typeof c === 'string'
    );
}
function isCommandBuilderCallback(builder) {
    return typeof builder === 'function';
}
class Completion {
    constructor(yargs1, usage2, command1, shim3){
        var _a1, _b, _c;
        this.yargs = yargs1;
        this.usage = usage2;
        this.command = command1;
        this.shim = shim3;
        this.completionKey = 'get-yargs-completions';
        this.aliases = null;
        this.customCompletionFunction = null;
        this.zshShell = (_c = ((_a1 = this.shim.getEnv('SHELL')) === null || _a1 === void 0 ? void 0 : _a1.includes('zsh')) || ((_b = this.shim.getEnv('ZSH_NAME')) === null || _b === void 0 ? void 0 : _b.includes('zsh'))) !== null && _c !== void 0 ? _c : false;
    }
    defaultCompletion(args, argv, current, done) {
        const handlers = this.command.getCommandHandlers();
        for(let i = 0, ii = args.length; i < ii; ++i){
            if (handlers[args[i]] && handlers[args[i]].builder) {
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) {
                    const y = this.yargs.getInternalMethods().reset();
                    builder(y, true);
                    return y.argv;
                }
            }
        }
        const completions = [];
        this.commandCompletions(completions, args, current);
        this.optionCompletions(completions, args, argv, current);
        this.choicesCompletions(completions, args, argv, current);
        done(null, completions);
    }
    commandCompletions(completions, args, current) {
        const parentCommands = this.yargs.getInternalMethods().getContext().commands;
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
            this.usage.getCommands().forEach((usageCommand)=>{
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) {
                    if (!this.zshShell) {
                        completions.push(commandName);
                    } else {
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                    }
                }
            });
        }
    }
    optionCompletions(completions, args, argv, current) {
        if ((current.match(/^-/) || current === '' && completions.length === 0) && !this.previousArgHasChoices(args)) {
            const options = this.yargs.getOptions();
            const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
            Object.keys(options.key).forEach((key)=>{
                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);
                const isPositionalKey = positionalKeys.includes(key);
                if (!isPositionalKey && !this.argsContainKey(args, argv, key, negable)) {
                    this.completeOptionKey(key, completions, current);
                    if (negable && !!options.default[key]) this.completeOptionKey(`no-${key}`, completions, current);
                }
            });
        }
    }
    choicesCompletions(completions, args, argv, current) {
        if (this.previousArgHasChoices(args)) {
            const choices = this.getPreviousArgChoices(args);
            if (choices && choices.length > 0) {
                completions.push(...choices);
            }
        }
    }
    getPreviousArgChoices(args) {
        if (args.length < 1) return;
        let previousArg = args[args.length - 1];
        let filter = '';
        if (!previousArg.startsWith('--') && args.length > 1) {
            filter = previousArg;
            previousArg = args[args.length - 2];
        }
        if (!previousArg.startsWith('--')) return;
        const previousArgKey = previousArg.replace(/-/g, '');
        const options = this.yargs.getOptions();
        if (Object.keys(options.key).some((key)=>key === previousArgKey
        ) && Array.isArray(options.choices[previousArgKey])) {
            return options.choices[previousArgKey].filter((choice)=>!filter || choice.startsWith(filter)
            );
        }
    }
    previousArgHasChoices(args) {
        const choices = this.getPreviousArgChoices(args);
        return choices !== undefined && choices.length > 0;
    }
    argsContainKey(args, argv, key, negable) {
        if (args.indexOf(`--${key}`) !== -1) return true;
        if (negable && args.indexOf(`--no-${key}`) !== -1) return true;
        if (this.aliases) {
            for (const alias of this.aliases[key]){
                if (argv[alias] !== undefined) return true;
            }
        }
        return false;
    }
    completeOptionKey(key, completions, current) {
        const descs = this.usage.getDescriptions();
        const startsByTwoDashes = (s)=>/^--/.test(s)
        ;
        const isShortOption = (s)=>/^[^0-9]$/.test(s)
        ;
        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
        if (!this.zshShell) {
            completions.push(dashes + key);
        } else {
            const desc = descs[key] || '';
            completions.push(dashes + `${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '')}`);
        }
    }
    customCompletion(args, argv, current, done) {
        assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
        if (isSyncCompletionFunction(this.customCompletionFunction)) {
            const result = this.customCompletionFunction(current, argv);
            if (isPromise(result)) {
                return result.then((list)=>{
                    this.shim.process.nextTick(()=>{
                        done(null, list);
                    });
                }).catch((err)=>{
                    this.shim.process.nextTick(()=>{
                        done(err, undefined);
                    });
                });
            }
            return done(null, result);
        } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
            return this.customCompletionFunction(current, argv, (onCompleted = done)=>this.defaultCompletion(args, argv, current, onCompleted)
            , (completions)=>{
                done(null, completions);
            });
        } else {
            return this.customCompletionFunction(current, argv, (completions)=>{
                done(null, completions);
            });
        }
    }
    getCompletion(args, done) {
        const current = args.length ? args[args.length - 1] : '';
        const argv = this.yargs.parse(args, true);
        const completionFunction = this.customCompletionFunction ? (argv)=>this.customCompletion(args, argv, current, done)
         : (argv)=>this.defaultCompletion(args, argv, current, done)
        ;
        return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
    }
    generateCompletionScript($0, cmd) {
        let script = this.zshShell ? completionZshTemplate : completionShTemplate;
        const name = this.shim.path.basename($0);
        if ($0.match(/\.js$/)) $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
    }
    registerFunction(fn) {
        this.customCompletionFunction = fn;
    }
    setParsed(parsed) {
        this.aliases = parsed.aliases;
    }
}
function completion(yargs, usage, command, shim) {
    return new Completion(yargs, usage, command, shim);
}
class YargsInstance {
    constructor(processArgs = [], cwd1, parentRequire, shim4){
        this.customScriptName = false;
        this.parsed = false;
        _YargsInstance_command.set(this, void 0);
        _YargsInstance_cwd.set(this, void 0);
        _YargsInstance_context.set(this, {
            commands: [],
            fullCommands: []
        });
        _YargsInstance_completion.set(this, null);
        _YargsInstance_completionCommand.set(this, null);
        _YargsInstance_defaultShowHiddenOpt.set(this, 'show-hidden');
        _YargsInstance_exitError.set(this, null);
        _YargsInstance_detectLocale.set(this, true);
        _YargsInstance_emittedWarnings.set(this, {
        });
        _YargsInstance_exitProcess.set(this, true);
        _YargsInstance_frozens.set(this, []);
        _YargsInstance_globalMiddleware.set(this, void 0);
        _YargsInstance_groups.set(this, {
        });
        _YargsInstance_hasOutput.set(this, false);
        _YargsInstance_helpOpt.set(this, null);
        _YargsInstance_logger.set(this, void 0);
        _YargsInstance_output.set(this, '');
        _YargsInstance_options.set(this, void 0);
        _YargsInstance_parentRequire.set(this, void 0);
        _YargsInstance_parserConfig.set(this, {
        });
        _YargsInstance_parseFn.set(this, null);
        _YargsInstance_parseContext.set(this, null);
        _YargsInstance_pkgs.set(this, {
        });
        _YargsInstance_preservedGroups.set(this, {
        });
        _YargsInstance_processArgs.set(this, void 0);
        _YargsInstance_recommendCommands.set(this, false);
        _YargsInstance_shim.set(this, void 0);
        _YargsInstance_strict.set(this, false);
        _YargsInstance_strictCommands.set(this, false);
        _YargsInstance_strictOptions.set(this, false);
        _YargsInstance_usage.set(this, void 0);
        _YargsInstance_versionOpt.set(this, null);
        _YargsInstance_validation.set(this, void 0);
        __classPrivateFieldSet(this, _YargsInstance_shim, shim4, "f");
        __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
        __classPrivateFieldSet(this, _YargsInstance_cwd, cwd1, "f");
        __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
        __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
        this.$0 = this[kGetDollarZero]();
        this[kReset]();
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
    }
    addHelpOpt(opt, msg) {
        const defaultHelpOpt = 'help';
        argsert('[string|boolean] [string]', [
            opt,
            msg
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
            __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
        }
        if (opt === false && msg === undefined) return this;
        __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === 'string' ? opt : defaultHelpOpt, "f");
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show help'));
        return this;
    }
    help(opt, msg) {
        return this.addHelpOpt(opt, msg);
    }
    addShowHiddenOpt(opt, msg) {
        argsert('[string|boolean] [string]', [
            opt,
            msg
        ], arguments.length);
        if (opt === false && msg === undefined) return this;
        const showHiddenOpt = typeof opt === 'string' ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        this.boolean(showHiddenOpt);
        this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show hidden options'));
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
        return this;
    }
    showHidden(opt, msg) {
        return this.addShowHiddenOpt(opt, msg);
    }
    alias(key, value) {
        argsert('<object|string|array> [string|array]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.alias.bind(this), 'alias', key, value);
        return this;
    }
    array(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('array', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    boolean(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('boolean', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    check(f, global) {
        argsert('<function> [boolean]', [
            f,
            global
        ], arguments.length);
        this.middleware((argv, _yargs)=>{
            return maybeAsyncResult(()=>{
                return f(argv);
            }, (result)=>{
                if (!result) {
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__('Argument check failed: %s', f.toString()));
                } else if (typeof result === 'string' || result instanceof Error) {
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
                }
                return argv;
            }, (err)=>{
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
                return argv;
            });
        }, false, global);
        return this;
    }
    choices(key, value) {
        argsert('<object|string|array> [string|array]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.choices.bind(this), 'choices', key, value);
        return this;
    }
    coerce(keys, value) {
        argsert('<object|string|array> [function]', [
            keys,
            value
        ], arguments.length);
        if (Array.isArray(keys)) {
            if (!value) {
                throw new YError('coerce callback must be provided');
            }
            for (const key of keys){
                this.coerce(key, value);
            }
            return this;
        } else if (typeof keys === 'object') {
            for (const key of Object.keys(keys)){
                this.coerce(key, keys[key]);
            }
            return this;
        }
        if (!value) {
            throw new YError('coerce callback must be provided');
        }
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs)=>{
            let aliases;
            return maybeAsyncResult(()=>{
                aliases = yargs.getAliases();
                return value(argv[keys]);
            }, (result)=>{
                argv[keys] = result;
                if (aliases[keys]) {
                    for (const alias of aliases[keys]){
                        argv[alias] = result;
                    }
                }
                return argv;
            }, (err)=>{
                throw new YError(err.message);
            });
        }, keys);
        return this;
    }
    conflicts(key1, key2) {
        argsert('<string|object> [string|array]', [
            key1,
            key2
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
        return this;
    }
    config(key = 'config', msg, parseFn) {
        argsert('[object|string] [string|function] [function]', [
            key,
            msg,
            parseFn
        ], arguments.length);
        if (typeof key === 'object' && !Array.isArray(key)) {
            key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
            return this;
        }
        if (typeof msg === 'function') {
            parseFn = msg;
            msg = undefined;
        }
        this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Path to JSON config file'));
        (Array.isArray(key) ? key : [
            key
        ]).forEach((k)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
        });
        return this;
    }
    completion(cmd, desc, fn) {
        argsert('[string] [string|boolean|function] [function]', [
            cmd,
            desc,
            fn
        ], arguments.length);
        if (typeof desc === 'function') {
            fn = desc;
            desc = undefined;
        }
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion', "f");
        if (!desc && desc !== false) {
            desc = 'generate completion script';
        }
        this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
        if (fn) __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
        return this;
    }
    command(cmd, description, builder, handler, middlewares, deprecated) {
        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [
            cmd,
            description,
            builder,
            handler,
            middlewares,
            deprecated
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return this;
    }
    commands(cmd, description, builder, handler, middlewares, deprecated) {
        return this.command(cmd, description, builder, handler, middlewares, deprecated);
    }
    commandDir(dir, opts) {
        argsert('<string> [object]', [
            dir,
            opts
        ], arguments.length);
        const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
        return this;
    }
    count(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('count', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    default(key, value, defaultDescription) {
        argsert('<object|string|array> [*] [string]', [
            key,
            value,
            defaultDescription
        ], arguments.length);
        if (defaultDescription) {
            assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
        }
        if (typeof value === 'function') {
            assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key]) __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
            value = value.call();
        }
        this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), 'default', key, value);
        return this;
    }
    defaults(key, value, defaultDescription) {
        return this.default(key, value, defaultDescription);
    }
    demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [
            min,
            max,
            minMsg,
            maxMsg
        ], arguments.length);
        if (typeof max !== 'number') {
            minMsg = max;
            max = Infinity;
        }
        this.global('_', false);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
            min,
            max,
            minMsg,
            maxMsg
        };
        return this;
    }
    demand(keys, max, msg) {
        if (Array.isArray(max)) {
            max.forEach((key)=>{
                assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
            max = Infinity;
        } else if (typeof max !== 'number') {
            msg = max;
            max = Infinity;
        }
        if (typeof keys === 'number') {
            assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            this.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
            keys.forEach((key)=>{
                assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
        } else {
            if (typeof msg === 'string') {
                this.demandOption(keys, msg);
            } else if (msg === true || typeof msg === 'undefined') {
                this.demandOption(keys);
            }
        }
        return this;
    }
    demandOption(keys, msg) {
        argsert('<object|string|array> [string]', [
            keys,
            msg
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), 'demandedOptions', keys, msg);
        return this;
    }
    deprecateOption(option, message) {
        argsert('<string> [string|boolean]', [
            option,
            message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
        return this;
    }
    describe(keys, description) {
        argsert('<object|string|array> [string]', [
            keys,
            description
        ], arguments.length);
        this[kSetKey](keys, true);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
        return this;
    }
    detectLocale(detect) {
        argsert('<boolean>', [
            detect
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
        return this;
    }
    env(prefix) {
        argsert('[string|boolean]', [
            prefix
        ], arguments.length);
        if (prefix === false) delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        else __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || '';
        return this;
    }
    epilogue(msg) {
        argsert('<string>', [
            msg
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
        return this;
    }
    epilog(msg) {
        return this.epilogue(msg);
    }
    example(cmd, description) {
        argsert('<string|array> [string]', [
            cmd,
            description
        ], arguments.length);
        if (Array.isArray(cmd)) {
            cmd.forEach((exampleParams)=>this.example(...exampleParams)
            );
        } else {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
        }
        return this;
    }
    exit(code, err) {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
    }
    exitProcess(enabled = true) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
        return this;
    }
    fail(f) {
        argsert('<function|boolean>', [
            f
        ], arguments.length);
        if (typeof f === 'boolean' && f !== false) {
            throw new YError("Invalid first argument. Expected function or boolean 'false'");
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
        return this;
    }
    getAliases() {
        return this.parsed ? this.parsed.aliases : {
        };
    }
    async getCompletion(args, done) {
        argsert('<array> [function]', [
            args,
            done
        ], arguments.length);
        if (!done) {
            return new Promise((resolve, reject)=>{
                __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions)=>{
                    if (err) reject(err);
                    else resolve(completions);
                });
            });
        } else {
            return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
        }
    }
    getDemandedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
    }
    getDemandedCommands() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
    }
    getDeprecatedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
    }
    getDetectLocale() {
        return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
    }
    getExitProcess() {
        return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
    }
    getGroups() {
        return Object.assign({
        }, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
    }
    getHelp() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise(parse)) {
                    return parse.then(()=>{
                        return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
                    });
                }
            }
            const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise(builderResponse)) {
                return builderResponse.then(()=>{
                    return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
                });
            }
        }
        return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
    }
    getOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_options, "f");
    }
    getStrict() {
        return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
    }
    getStrictCommands() {
        return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
    }
    getStrictOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
    }
    global(globals, global) {
        argsert('<string|array> [boolean]', [
            globals,
            global
        ], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l)=>globals.indexOf(l) === -1
            );
        } else {
            globals.forEach((g)=>{
                if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g)) __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
            });
        }
        return this;
    }
    group(opts, groupName) {
        argsert('<string|array> <string>', [
            opts,
            groupName
        ], arguments.length);
        const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
        if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
            delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
        }
        const seen = {
        };
        __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key)=>{
            if (seen[key]) return false;
            return seen[key] = true;
        });
        return this;
    }
    hide(key) {
        argsert('<string>', [
            key
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
        return this;
    }
    implies(key, value) {
        argsert('<string|object> [number|string|array]', [
            key,
            value
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
        return this;
    }
    locale(locale) {
        argsert('[string]', [
            locale
        ], arguments.length);
        if (!locale) {
            this[kGuessLocale]();
            return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
        }
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
        return this;
    }
    middleware(callback, applyBeforeValidation, global) {
        return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global);
    }
    nargs(key, value) {
        argsert('<string|object|array> [number]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), 'narg', key, value);
        return this;
    }
    normalize(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('normalize', keys);
        return this;
    }
    number(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('number', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    option(key, opt) {
        argsert('<string|object> [object]', [
            key,
            opt
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                this.options(k, key[k]);
            });
        } else {
            if (typeof opt !== 'object') {
                opt = {
                };
            }
            this[kTrackManuallySetKeys](key);
            if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === 'version' || (opt === null || opt === void 0 ? void 0 : opt.alias) === 'version')) {
                this[kEmitWarning]([
                    '"version" is a reserved word.',
                    'Please do one of the following:',
                    '- Disable version with `yargs.version(false)` if using "version" as an option',
                    '- Use the built-in `yargs.version` method instead (if applicable)',
                    '- Use a different option key',
                    'https://yargs.js.org/docs/#api-reference-version', 
                ].join('\n'), undefined, 'versionWarning');
            }
            __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
            if (opt.alias) this.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) {
                this.deprecateOption(key, deprecate);
            }
            const demand = opt.demand || opt.required || opt.require;
            if (demand) {
                this.demand(key, demand);
            }
            if (opt.demandOption) {
                this.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
            }
            if (opt.conflicts) {
                this.conflicts(key, opt.conflicts);
            }
            if ('default' in opt) {
                this.default(key, opt.default);
            }
            if (opt.implies !== undefined) {
                this.implies(key, opt.implies);
            }
            if (opt.nargs !== undefined) {
                this.nargs(key, opt.nargs);
            }
            if (opt.config) {
                this.config(key, opt.configParser);
            }
            if (opt.normalize) {
                this.normalize(key);
            }
            if (opt.choices) {
                this.choices(key, opt.choices);
            }
            if (opt.coerce) {
                this.coerce(key, opt.coerce);
            }
            if (opt.group) {
                this.group(key, opt.group);
            }
            if (opt.boolean || opt.type === 'boolean') {
                this.boolean(key);
                if (opt.alias) this.boolean(opt.alias);
            }
            if (opt.array || opt.type === 'array') {
                this.array(key);
                if (opt.alias) this.array(opt.alias);
            }
            if (opt.number || opt.type === 'number') {
                this.number(key);
                if (opt.alias) this.number(opt.alias);
            }
            if (opt.string || opt.type === 'string') {
                this.string(key);
                if (opt.alias) this.string(opt.alias);
            }
            if (opt.count || opt.type === 'count') {
                this.count(key);
            }
            if (typeof opt.global === 'boolean') {
                this.global(key, opt.global);
            }
            if (opt.defaultDescription) {
                __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
            }
            if (opt.skipValidation) {
                this.skipValidation(key);
            }
            const desc = opt.describe || opt.description || opt.desc;
            this.describe(key, desc);
            if (opt.hidden) {
                this.hide(key);
            }
            if (opt.requiresArg) {
                this.requiresArg(key);
            }
        }
        return this;
    }
    options(key, opt) {
        return this.option(key, opt);
    }
    parse(args, shortCircuit, _parseFn) {
        argsert('[string|array] [function|boolean|object] [function]', [
            args,
            shortCircuit,
            _parseFn
        ], arguments.length);
        this[kFreeze]();
        if (typeof args === 'undefined') {
            args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        }
        if (typeof shortCircuit === 'object') {
            __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
            shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === 'function') {
            __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
            shortCircuit = false;
        }
        if (!shortCircuit) __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
        const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
        const tmpParsed = this.parsed;
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
        if (isPromise(parsed)) {
            return parsed.then((argv)=>{
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                return argv;
            }).catch((err)=>{
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
                    __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                }
                throw err;
            }).finally(()=>{
                this[kUnfreeze]();
                this.parsed = tmpParsed;
            });
        } else {
            if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
            this[kUnfreeze]();
            this.parsed = tmpParsed;
        }
        return parsed;
    }
    parseAsync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
    }
    parseSync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        if (isPromise(maybePromise)) {
            throw new YError('.parseSync() must not be used with asynchronous builders, handlers, or middleware');
        }
        return maybePromise;
    }
    parserConfiguration(config) {
        argsert('<object>', [
            config
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
        return this;
    }
    pkgConf(key, rootPath) {
        argsert('<string> [string]', [
            key,
            rootPath
        ], arguments.length);
        let conf = null;
        const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
        if (obj[key] && typeof obj[key] === 'object') {
            conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
        }
        return this;
    }
    positional(key, opts) {
        argsert('<string> <object>', [
            key,
            opts
        ], arguments.length);
        const supportedOpts = [
            'default',
            'defaultDescription',
            'implies',
            'normalize',
            'choices',
            'conflicts',
            'coerce',
            'type',
            'describe',
            'desc',
            'description',
            'alias', 
        ];
        opts = objFilter(opts, (k, v)=>{
            if (k === 'type' && ![
                'string',
                'number',
                'boolean'
            ].includes(v)) return false;
            return supportedOpts.includes(k);
        });
        const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
        const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
            array: [],
            alias: {
            },
            default: {
            },
            demand: {
            }
        };
        objectKeys(parseOptions).forEach((pk)=>{
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) {
                if (parseOption.indexOf(key) !== -1) opts[pk] = true;
            } else {
                if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];
            }
        });
        this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
        return this.option(key, opts);
    }
    recommendCommands(recommend = true) {
        argsert('[boolean]', [
            recommend
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
        return this;
    }
    required(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    require(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    requiresArg(keys) {
        argsert('<array|string|object> [number]', [
            keys
        ], arguments.length);
        if (typeof keys === 'string' && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
            return this;
        } else {
            this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), 'narg', keys, NaN);
        }
        return this;
    }
    showCompletionScript($0, cmd) {
        argsert('[string] [string]', [
            $0,
            cmd
        ], arguments.length);
        $0 = $0 || this.$0;
        __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion'));
        return this;
    }
    showHelp(level) {
        argsert('[string|function]', [
            level
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise(parse)) {
                    parse.then(()=>{
                        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                    });
                    return this;
                }
            }
            const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise(builderResponse)) {
                builderResponse.then(()=>{
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                });
                return this;
            }
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        return this;
    }
    scriptName(scriptName) {
        this.customScriptName = true;
        this.$0 = scriptName;
        return this;
    }
    showHelpOnFail(enabled, message) {
        argsert('[boolean|string] [string]', [
            enabled,
            message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
        return this;
    }
    showVersion(level) {
        argsert('[string|function]', [
            level
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
        return this;
    }
    skipValidation(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('skipValidation', keys);
        return this;
    }
    strict(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
        return this;
    }
    strictCommands(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
        return this;
    }
    strictOptions(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
        return this;
    }
    string(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('string', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    terminalWidth() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
    }
    updateLocale(obj) {
        return this.updateStrings(obj);
    }
    updateStrings(obj) {
        argsert('<object>', [
            obj
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
        return this;
    }
    usage(msg, description, builder, handler) {
        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [
            msg,
            description,
            builder,
            handler
        ], arguments.length);
        if (description !== undefined) {
            assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            if ((msg || '').match(/^\$0( |$)/)) {
                return this.command(msg, description, builder, handler);
            } else {
                throw new YError('.usage() description must start with $0 if being used as alias for .command()');
            }
        } else {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
            return this;
        }
    }
    version(opt, msg, ver) {
        const defaultVersionOpt = 'version';
        argsert('[boolean|string] [string] [string]', [
            opt,
            msg,
            ver
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(undefined);
            __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
        }
        if (arguments.length === 0) {
            ver = this[kGuessVersion]();
            opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
            if (opt === false) {
                return this;
            }
            ver = opt;
            opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
            ver = msg;
            msg = undefined;
        }
        __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === 'string' ? opt : defaultVersionOpt, "f");
        msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show version number');
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || undefined);
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
        return this;
    }
    wrap(cols) {
        argsert('<number|null|undefined>', [
            cols
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
        return this;
    }
    [(_YargsInstance_command = new WeakMap(), _YargsInstance_cwd = new WeakMap(), _YargsInstance_context = new WeakMap(), _YargsInstance_completion = new WeakMap(), _YargsInstance_completionCommand = new WeakMap(), _YargsInstance_defaultShowHiddenOpt = new WeakMap(), _YargsInstance_exitError = new WeakMap(), _YargsInstance_detectLocale = new WeakMap(), _YargsInstance_emittedWarnings = new WeakMap(), _YargsInstance_exitProcess = new WeakMap(), _YargsInstance_frozens = new WeakMap(), _YargsInstance_globalMiddleware = new WeakMap(), _YargsInstance_groups = new WeakMap(), _YargsInstance_hasOutput = new WeakMap(), _YargsInstance_helpOpt = new WeakMap(), _YargsInstance_logger = new WeakMap(), _YargsInstance_output = new WeakMap(), _YargsInstance_options = new WeakMap(), _YargsInstance_parentRequire = new WeakMap(), _YargsInstance_parserConfig = new WeakMap(), _YargsInstance_parseFn = new WeakMap(), _YargsInstance_parseContext = new WeakMap(), _YargsInstance_pkgs = new WeakMap(), _YargsInstance_preservedGroups = new WeakMap(), _YargsInstance_processArgs = new WeakMap(), _YargsInstance_recommendCommands = new WeakMap(), _YargsInstance_shim = new WeakMap(), _YargsInstance_strict = new WeakMap(), _YargsInstance_strictCommands = new WeakMap(), _YargsInstance_strictOptions = new WeakMap(), _YargsInstance_usage = new WeakMap(), _YargsInstance_versionOpt = new WeakMap(), _YargsInstance_validation = new WeakMap(), kCopyDoubleDash)](argv) {
        if (!argv._ || !argv['--']) return argv;
        argv._.push.apply(argv._, argv['--']);
        try {
            delete argv['--'];
        } catch (_err) {
        }
        return argv;
    }
    [kCreateLogger]() {
        return {
            log: (...args)=>{
                if (!this[kHasParseCallback]()) console.log(...args);
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
            },
            error: (...args)=>{
                if (!this[kHasParseCallback]()) console.error(...args);
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
            }
        };
    }
    [kDeleteFromParserHintObject](optionKey) {
        objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey)=>{
            if (((key)=>key === 'configObjects'
            )(hintKey)) return;
            const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
            if (Array.isArray(hint)) {
                if (hint.includes(optionKey)) hint.splice(hint.indexOf(optionKey), 1);
            } else if (typeof hint === 'object') {
                delete hint[optionKey];
            }
        });
        delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
    }
    [kEmitWarning](warning, type, deduplicationId) {
        if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
            __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
            __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
        }
    }
    [kFreeze]() {
        __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
            options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
            configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
            exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
            groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
            strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
            strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
            strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
            completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
            output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
            exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
            hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
            parsed: this.parsed,
            parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
            parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
        });
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
    }
    [kGetDollarZero]() {
        let $0 = '';
        let default$0;
        if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
            default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
        } else {
            default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
        }
        $0 = default$0.map((x)=>{
            const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
            return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
        }).join(' ').trim();
        if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_') && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_')) {
            $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_').replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, '');
        }
        return $0;
    }
    [kGetParserConfiguration]() {
        return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
    }
    [kGuessLocale]() {
        if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f")) return;
        const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_ALL') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_MESSAGES') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANG') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANGUAGE') || 'en_US';
        this.locale(locale.replace(/[.:].*/, ''));
    }
    [kGuessVersion]() {
        const obj = this[kPkgUp]();
        return obj.version || 'unknown';
    }
    [kParsePositionalNumbers](argv) {
        const args = argv['--'] ? argv['--'] : argv._;
        for(let i = 0, arg; (arg = args[i]) !== undefined; i++){
            if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
                args[i] = Number(arg);
            }
        }
        return argv;
    }
    [kPkgUp](rootPath) {
        const npath = rootPath || '*';
        if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath]) return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
        let obj = {
        };
        try {
            let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
            if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
                startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
            }
            const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names)=>{
                if (names.includes('package.json')) {
                    return 'package.json';
                } else {
                    return undefined;
                }
            });
            assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, 'utf8'));
        } catch (_noop) {
        }
        __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {
        };
        return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    }
    [kPopulateParserHintArray](type, keys) {
        keys = [].concat(keys);
        keys.forEach((key)=>{
            key = this[kSanitizeKey](key);
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
        });
    }
    [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = value;
        });
    }
    [kPopulateParserHintArrayDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] || []).concat(value);
        });
    }
    [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
            key.forEach((k)=>{
                builder(k, value);
            });
        } else if (((key)=>typeof key === 'object'
        )(key)) {
            for (const k of objectKeys(key)){
                builder(k, key[k]);
            }
        } else {
            singleKeyHandler(type, this[kSanitizeKey](key), value);
        }
    }
    [kSanitizeKey](key) {
        if (key === '__proto__') return '___proto___';
        return key;
    }
    [kSetKey](key, set) {
        this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), 'key', key, set);
        return this;
    }
    [kUnfreeze]() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
        assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        let configObjects;
        _a = this, _b = this, _c = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, { options: ({
            set value (_o){
                __classPrivateFieldSet(_a, _YargsInstance_options, _o, "f");
            }
        }).value , configObjects , exitProcess: ({
            set value (_o1){
                __classPrivateFieldSet(_b, _YargsInstance_exitProcess, _o1, "f");
            }
        }).value , groups: ({
            set value (_o2){
                __classPrivateFieldSet(_c, _YargsInstance_groups, _o2, "f");
            }
        }).value , output: ({
            set value (_o3){
                __classPrivateFieldSet(_d, _YargsInstance_output, _o3, "f");
            }
        }).value , exitError: ({
            set value (_o4){
                __classPrivateFieldSet(_e, _YargsInstance_exitError, _o4, "f");
            }
        }).value , hasOutput: ({
            set value (_o5){
                __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o5, "f");
            }
        }).value , parsed: this.parsed , strict: ({
            set value (_o6){
                __classPrivateFieldSet(_g, _YargsInstance_strict, _o6, "f");
            }
        }).value , strictCommands: ({
            set value (_o7){
                __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o7, "f");
            }
        }).value , strictOptions: ({
            set value (_o8){
                __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o8, "f");
            }
        }).value , completionCommand: ({
            set value (_o9){
                __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o9, "f");
            }
        }).value , parseFn: ({
            set value (_o10){
                __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o10, "f");
            }
        }).value , parseContext: ({
            set value (_o11){
                __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o11, "f");
            }
        }).value ,  } = frozen;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
    }
    [kValidateAsync](validation, argv) {
        return maybeAsyncResult(argv, (result)=>{
            validation(result);
            return result;
        });
    }
    getInternalMethods() {
        return {
            getCommandInstance: this[kGetCommandInstance].bind(this),
            getContext: this[kGetContext].bind(this),
            getHasOutput: this[kGetHasOutput].bind(this),
            getLoggerInstance: this[kGetLoggerInstance].bind(this),
            getParseContext: this[kGetParseContext].bind(this),
            getParserConfiguration: this[kGetParserConfiguration].bind(this),
            getUsageInstance: this[kGetUsageInstance].bind(this),
            getValidationInstance: this[kGetValidationInstance].bind(this),
            hasParseCallback: this[kHasParseCallback].bind(this),
            postProcess: this[kPostProcess].bind(this),
            reset: this[kReset].bind(this),
            runValidation: this[kRunValidation].bind(this),
            runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
            setHasOutput: this[kSetHasOutput].bind(this)
        };
    }
    [kGetCommandInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_command, "f");
    }
    [kGetContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_context, "f");
    }
    [kGetHasOutput]() {
        return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
    }
    [kGetLoggerInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
    }
    [kGetParseContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {
        };
    }
    [kGetUsageInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
    }
    [kGetValidationInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
    }
    [kHasParseCallback]() {
        return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
    }
    [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
        if (calledFromCommand) return argv;
        if (isPromise(argv)) return argv;
        if (!populateDoubleDash) {
            argv = this[kCopyDoubleDash](argv);
        }
        const parsePositionalNumbers = this[kGetParserConfiguration]()['parse-positional-numbers'] || this[kGetParserConfiguration]()['parse-positional-numbers'] === undefined;
        if (parsePositionalNumbers) {
            argv = this[kParsePositionalNumbers](argv);
        }
        if (runGlobalMiddleware) {
            argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
        }
        return argv;
    }
    [kReset](aliases = {
    }) {
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {
        }, "f");
        const tmpOptions = {
        };
        tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
        tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
        const localLookup = {
        };
        tmpOptions.local.forEach((l)=>{
            localLookup[l] = true;
            (aliases[l] || []).forEach((a)=>{
                localLookup[a] = true;
            });
        });
        Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName)=>{
            const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key)=>!(key in localLookup)
            );
            if (keys.length > 0) {
                acc[groupName] = keys;
            }
            return acc;
        }, {
        }));
        __classPrivateFieldSet(this, _YargsInstance_groups, {
        }, "f");
        const arrayOptions = [
            'array',
            'boolean',
            'string',
            'skipValidation',
            'count',
            'normalize',
            'number',
            'hiddenOptions', 
        ];
        const objectOptions = [
            'narg',
            'key',
            'alias',
            'default',
            'defaultDescription',
            'config',
            'choices',
            'demandedOptions',
            'demandedCommands',
            'deprecatedOptions', 
        ];
        arrayOptions.forEach((k)=>{
            tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k)=>!localLookup[k]
            );
        });
        objectOptions.forEach((k)=>{
            tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k)=>!localLookup[k]
            );
        });
        tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f")) __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_output, '', "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
        this.parsed = false;
        return this;
    }
    [kRebase](base, dir) {
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
    }
    [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
        let skipValidation = !!calledFromCommand || helpOnly;
        args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
        const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration['populate--'];
        const config = Object.assign({
        }, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
            'populate--': true
        });
        const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({
        }, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
            configuration: {
                'parse-positional-numbers': false,
                ...config
            }
        }));
        const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
        let argvPromise = undefined;
        const aliases = parsed.aliases;
        let helpOptSet = false;
        let versionOptSet = false;
        Object.keys(argv).forEach((key)=>{
            if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
                helpOptSet = true;
            } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
                versionOptSet = true;
            }
        });
        argv.$0 = this.$0;
        this.parsed = parsed;
        if (commandIndex === 0) {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
        }
        try {
            this[kGuessLocale]();
            if (shortCircuit) {
                return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
            }
            if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
                const helpCmds = [
                    __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")
                ].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k)=>k.length > 1
                );
                if (helpCmds.includes('' + argv._[argv._.length - 1])) {
                    argv._.pop();
                    helpOptSet = true;
                }
            }
            const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
            const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
            const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
            if (argv._.length) {
                if (handlerKeys.length) {
                    let firstUnknownCommand;
                    for(let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++){
                        cmd = String(argv._[i]);
                        if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                            const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
                            return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                        } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                            firstUnknownCommand = cmd;
                            break;
                        }
                    }
                    if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
                        __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
                    }
                }
                if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    this.showCompletionScript();
                    this.exit(0);
                }
            }
            if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
                const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
                return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            }
            if (requestCompletions) {
                if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
                __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions)=>{
                    if (err) throw new YError(err.message);
                    (completions || []).forEach((completion)=>{
                        __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion);
                    });
                    this.exit(0);
                });
                return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
            }
            if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
                if (helpOptSet) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    skipValidation = true;
                    this.showHelp('log');
                    this.exit(0);
                } else if (versionOptSet) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    skipValidation = true;
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion('log');
                    this.exit(0);
                }
            }
            if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
                skipValidation = Object.keys(argv).some((key)=>__classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true
                );
            }
            if (!skipValidation) {
                if (parsed.error) throw new YError(parsed.error.message);
                if (!requestCompletions) {
                    const validation = this[kRunValidation](aliases, {
                    }, parsed.error);
                    if (!calledFromCommand) {
                        argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
                    }
                    argvPromise = this[kValidateAsync](validation, argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv);
                    if (isPromise(argvPromise) && !calledFromCommand) {
                        argvPromise = argvPromise.then(()=>{
                            return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
                        });
                    }
                }
            }
        } catch (err) {
            if (err instanceof YError) __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
            else throw err;
        }
        return this[kPostProcess](argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
    }
    [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
        const demandedOptions = {
            ...this.getDemandedOptions()
        };
        return (argv)=>{
            if (parseErrors) throw new YError(parseErrors.message);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
            let failedStrictCommands = false;
            if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
                failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
            }
            if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
            } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {
                }, false, false);
            }
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
        };
    }
    [kSetHasOutput]() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    }
    [kTrackManuallySetKeys](keys) {
        if (typeof keys === 'string') {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        } else {
            for (const k of keys){
                __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
            }
        }
    }
}
function isCommandBuilderOptionDefinitions(builder) {
    return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) {
    return typeof cmd === 'object' && !Array.isArray(cmd);
}
function isSyncCompletionFunction(completionFunction) {
    return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
    return completionFunction.length > 3;
}
const Yargs = YargsFactory(__default5);
const MAX_BITS = 15;
const D_CODES = 30;
const BL_CODES = 19;
const LITERALS = 256;
const L_CODES = 256 + 1 + 29;
const HEAP_SIZE = 2 * L_CODES + 1;
const END_BLOCK = 256;
const MAX_BL_BITS = 7;
const Buf_size = 8 * 2;
const Z_DEFAULT_COMPRESSION = -1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;
const Z_NO_FLUSH = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH = 4;
const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_BUF_ERROR = -5;
function extractArray(array) {
    return flatArray(array.map(([length, value])=>new Array(length).fill(value, 0, length)
    ));
}
function flatArray(array) {
    return array.reduce((a, b)=>a.concat(Array.isArray(b) ? flatArray(b) : b)
    , []);
}
const _dist_code = [
    0,
    1,
    2,
    3
].concat(...extractArray([
    [
        2,
        4
    ],
    [
        2,
        5
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        8,
        8
    ],
    [
        8,
        9
    ],
    [
        16,
        10
    ],
    [
        16,
        11
    ],
    [
        32,
        12
    ],
    [
        32,
        13
    ],
    [
        64,
        14
    ],
    [
        64,
        15
    ],
    [
        2,
        0
    ],
    [
        1,
        16
    ],
    [
        1,
        17
    ],
    [
        2,
        18
    ],
    [
        2,
        19
    ],
    [
        4,
        20
    ],
    [
        4,
        21
    ],
    [
        8,
        22
    ],
    [
        8,
        23
    ],
    [
        16,
        24
    ],
    [
        16,
        25
    ],
    [
        32,
        26
    ],
    [
        32,
        27
    ],
    [
        64,
        28
    ],
    [
        64,
        29
    ]
]));
function Tree() {
    const that = this;
    function gen_bitlen(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const extra = that.stat_desc.extra_bits;
        const base = that.stat_desc.extra_base;
        const max_length = that.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for(bits = 0; bits <= 15; bits++)s.bl_count[bits] = 0;
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for(h = s.heap_max + 1; h < HEAP_SIZE; h++){
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > that.max_code) continue;
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) xbits = extra[n - base];
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
        if (overflow === 0) return;
        do {
            bits = max_length - 1;
            while(s.bl_count[bits] === 0)bits--;
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        }while (overflow > 0)
        for(bits = max_length; bits !== 0; bits--){
            n = s.bl_count[bits];
            while(n !== 0){
                m = s.heap[--h];
                if (m > that.max_code) continue;
                if (tree[m * 2 + 1] != bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    }
    function bi_reverse(code, len) {
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        }while (--len > 0)
        return res >>> 1;
    }
    function gen_codes(tree, max_code, bl_count) {
        const next_code = [];
        let code = 0;
        let bits;
        let n;
        let len;
        for(bits = 1; bits <= 15; bits++){
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for(n = 0; n <= max_code; n++){
            len = tree[n * 2 + 1];
            if (len === 0) continue;
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    }
    that.build_tree = function(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const elems = that.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for(n = 0; n < elems; n++){
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while(s.heap_len < 2){
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (stree) s.static_len -= stree[node * 2 + 1];
        }
        that.max_code = max_code;
        for(n = Math.floor(s.heap_len / 2); n >= 1; n--)s.pqdownheap(tree, n);
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            s.pqdownheap(tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            s.pqdownheap(tree, 1);
        }while (s.heap_len >= 2)
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s);
        gen_codes(tree, that.max_code, s.bl_count);
    };
}
Tree._length_code = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7
].concat(...extractArray([
    [
        2,
        8
    ],
    [
        2,
        9
    ],
    [
        2,
        10
    ],
    [
        2,
        11
    ],
    [
        4,
        12
    ],
    [
        4,
        13
    ],
    [
        4,
        14
    ],
    [
        4,
        15
    ],
    [
        8,
        16
    ],
    [
        8,
        17
    ],
    [
        8,
        18
    ],
    [
        8,
        19
    ],
    [
        16,
        20
    ],
    [
        16,
        21
    ],
    [
        16,
        22
    ],
    [
        16,
        23
    ],
    [
        32,
        24
    ],
    [
        32,
        25
    ],
    [
        32,
        26
    ],
    [
        31,
        27
    ],
    [
        1,
        28
    ]
]));
Tree.base_length = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    28,
    32,
    40,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    160,
    192,
    224,
    0
];
Tree.base_dist = [
    0,
    1,
    2,
    3,
    4,
    6,
    8,
    12,
    16,
    24,
    32,
    48,
    64,
    96,
    128,
    192,
    256,
    384,
    512,
    768,
    1024,
    1536,
    2048,
    3072,
    4096,
    6144,
    8192,
    12288,
    16384,
    24576
];
Tree.d_code = function(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
Tree.extra_lbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
];
Tree.extra_dbits = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
Tree.extra_blbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
];
Tree.bl_order = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
    const that = this;
    that.static_tree = static_tree;
    that.extra_bits = extra_bits;
    that.extra_base = extra_base;
    that.elems = elems;
    that.max_length = max_length;
}
StaticTree.static_ltree = [
    12,
    8,
    140,
    8,
    76,
    8,
    204,
    8,
    44,
    8,
    172,
    8,
    108,
    8,
    236,
    8,
    28,
    8,
    156,
    8,
    92,
    8,
    220,
    8,
    60,
    8,
    188,
    8,
    124,
    8,
    252,
    8,
    2,
    8,
    130,
    8,
    66,
    8,
    194,
    8,
    34,
    8,
    162,
    8,
    98,
    8,
    226,
    8,
    18,
    8,
    146,
    8,
    82,
    8,
    210,
    8,
    50,
    8,
    178,
    8,
    114,
    8,
    242,
    8,
    10,
    8,
    138,
    8,
    74,
    8,
    202,
    8,
    42,
    8,
    170,
    8,
    106,
    8,
    234,
    8,
    26,
    8,
    154,
    8,
    90,
    8,
    218,
    8,
    58,
    8,
    186,
    8,
    122,
    8,
    250,
    8,
    6,
    8,
    134,
    8,
    70,
    8,
    198,
    8,
    38,
    8,
    166,
    8,
    102,
    8,
    230,
    8,
    22,
    8,
    150,
    8,
    86,
    8,
    214,
    8,
    54,
    8,
    182,
    8,
    118,
    8,
    246,
    8,
    14,
    8,
    142,
    8,
    78,
    8,
    206,
    8,
    46,
    8,
    174,
    8,
    110,
    8,
    238,
    8,
    30,
    8,
    158,
    8,
    94,
    8,
    222,
    8,
    62,
    8,
    190,
    8,
    126,
    8,
    254,
    8,
    1,
    8,
    129,
    8,
    65,
    8,
    193,
    8,
    33,
    8,
    161,
    8,
    97,
    8,
    225,
    8,
    17,
    8,
    145,
    8,
    81,
    8,
    209,
    8,
    49,
    8,
    177,
    8,
    113,
    8,
    241,
    8,
    9,
    8,
    137,
    8,
    73,
    8,
    201,
    8,
    41,
    8,
    169,
    8,
    105,
    8,
    233,
    8,
    25,
    8,
    153,
    8,
    89,
    8,
    217,
    8,
    57,
    8,
    185,
    8,
    121,
    8,
    249,
    8,
    5,
    8,
    133,
    8,
    69,
    8,
    197,
    8,
    37,
    8,
    165,
    8,
    101,
    8,
    229,
    8,
    21,
    8,
    149,
    8,
    85,
    8,
    213,
    8,
    53,
    8,
    181,
    8,
    117,
    8,
    245,
    8,
    13,
    8,
    141,
    8,
    77,
    8,
    205,
    8,
    45,
    8,
    173,
    8,
    109,
    8,
    237,
    8,
    29,
    8,
    157,
    8,
    93,
    8,
    221,
    8,
    61,
    8,
    189,
    8,
    125,
    8,
    253,
    8,
    19,
    9,
    275,
    9,
    147,
    9,
    403,
    9,
    83,
    9,
    339,
    9,
    211,
    9,
    467,
    9,
    51,
    9,
    307,
    9,
    179,
    9,
    435,
    9,
    115,
    9,
    371,
    9,
    243,
    9,
    499,
    9,
    11,
    9,
    267,
    9,
    139,
    9,
    395,
    9,
    75,
    9,
    331,
    9,
    203,
    9,
    459,
    9,
    43,
    9,
    299,
    9,
    171,
    9,
    427,
    9,
    107,
    9,
    363,
    9,
    235,
    9,
    491,
    9,
    27,
    9,
    283,
    9,
    155,
    9,
    411,
    9,
    91,
    9,
    347,
    9,
    219,
    9,
    475,
    9,
    59,
    9,
    315,
    9,
    187,
    9,
    443,
    9,
    123,
    9,
    379,
    9,
    251,
    9,
    507,
    9,
    7,
    9,
    263,
    9,
    135,
    9,
    391,
    9,
    71,
    9,
    327,
    9,
    199,
    9,
    455,
    9,
    39,
    9,
    295,
    9,
    167,
    9,
    423,
    9,
    103,
    9,
    359,
    9,
    231,
    9,
    487,
    9,
    23,
    9,
    279,
    9,
    151,
    9,
    407,
    9,
    87,
    9,
    343,
    9,
    215,
    9,
    471,
    9,
    55,
    9,
    311,
    9,
    183,
    9,
    439,
    9,
    119,
    9,
    375,
    9,
    247,
    9,
    503,
    9,
    15,
    9,
    271,
    9,
    143,
    9,
    399,
    9,
    79,
    9,
    335,
    9,
    207,
    9,
    463,
    9,
    47,
    9,
    303,
    9,
    175,
    9,
    431,
    9,
    111,
    9,
    367,
    9,
    239,
    9,
    495,
    9,
    31,
    9,
    287,
    9,
    159,
    9,
    415,
    9,
    95,
    9,
    351,
    9,
    223,
    9,
    479,
    9,
    63,
    9,
    319,
    9,
    191,
    9,
    447,
    9,
    127,
    9,
    383,
    9,
    255,
    9,
    511,
    9,
    0,
    7,
    64,
    7,
    32,
    7,
    96,
    7,
    16,
    7,
    80,
    7,
    48,
    7,
    112,
    7,
    8,
    7,
    72,
    7,
    40,
    7,
    104,
    7,
    24,
    7,
    88,
    7,
    56,
    7,
    120,
    7,
    4,
    7,
    68,
    7,
    36,
    7,
    100,
    7,
    20,
    7,
    84,
    7,
    52,
    7,
    116,
    7,
    3,
    8,
    131,
    8,
    67,
    8,
    195,
    8,
    35,
    8,
    163,
    8,
    99,
    8,
    227,
    8
];
StaticTree.static_dtree = [
    0,
    5,
    16,
    5,
    8,
    5,
    24,
    5,
    4,
    5,
    20,
    5,
    12,
    5,
    28,
    5,
    2,
    5,
    18,
    5,
    10,
    5,
    26,
    5,
    6,
    5,
    22,
    5,
    14,
    5,
    30,
    5,
    1,
    5,
    17,
    5,
    9,
    5,
    25,
    5,
    5,
    5,
    21,
    5,
    13,
    5,
    29,
    5,
    3,
    5,
    19,
    5,
    11,
    5,
    27,
    5,
    7,
    5,
    23,
    5
];
StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    const that = this;
    that.good_length = good_length;
    that.max_lazy = max_lazy;
    that.nice_length = nice_length;
    that.max_chain = max_chain;
    that.func = func;
}
const STORED = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
    new Config(0, 0, 0, 0, 0),
    new Config(4, 4, 8, 4, 1),
    new Config(4, 5, 16, 8, 1),
    new Config(4, 6, 32, 32, 1),
    new Config(4, 4, 16, 16, 2),
    new Config(8, 16, 32, 32, 2),
    new Config(8, 16, 128, 128, 2),
    new Config(8, 32, 128, 256, 2),
    new Config(32, 128, 258, 1024, 2),
    new Config(32, 258, 258, 4096, 2)
];
const z_errmsg = [
    "need dictionary",
    "stream end",
    "",
    "",
    "stream error",
    "data error",
    "",
    "buffer error",
    "",
    ""
];
const NeedMore = 0;
const BlockDone = 1;
const FinishStarted = 2;
const FinishDone = 3;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const Z_DEFLATED = 8;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
function smaller(tree, n, m, depth) {
    const tn2 = tree[n * 2];
    const tm2 = tree[m * 2];
    return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
}
function Deflate() {
    const that = this;
    let strm;
    let status;
    let pending_buf_size;
    let last_flush;
    let w_size;
    let w_bits;
    let w_mask;
    let window;
    let window_size;
    let prev;
    let head;
    let ins_h;
    let hash_size;
    let hash_bits;
    let hash_mask;
    let hash_shift;
    let block_start;
    let match_length;
    let prev_match;
    let match_available;
    let strstart;
    let match_start;
    let lookahead;
    let prev_length;
    let max_chain_length;
    let max_lazy_match;
    let level;
    let strategy;
    let good_match;
    let nice_match;
    let dyn_ltree;
    let dyn_dtree;
    let bl_tree;
    const l_desc = new Tree();
    const d_desc = new Tree();
    const bl_desc = new Tree();
    that.depth = [];
    let l_buf;
    let lit_bufsize;
    let last_lit;
    let d_buf;
    let matches;
    let last_eob_len;
    let bi_buf;
    let bi_valid;
    that.bl_count = [];
    that.heap = [];
    dyn_ltree = [];
    dyn_dtree = [];
    bl_tree = [];
    function lm_init() {
        window_size = 2 * w_size;
        head[hash_size - 1] = 0;
        for(let i = 0; i < hash_size - 1; i++){
            head[i] = 0;
        }
        max_lazy_match = config_table[level].max_lazy;
        good_match = config_table[level].good_length;
        nice_match = config_table[level].nice_length;
        max_chain_length = config_table[level].max_chain;
        strstart = 0;
        block_start = 0;
        lookahead = 0;
        match_length = prev_length = MIN_MATCH - 1;
        match_available = 0;
        ins_h = 0;
    }
    function init_block() {
        let i;
        for(i = 0; i < L_CODES; i++)dyn_ltree[i * 2] = 0;
        for(i = 0; i < 30; i++)dyn_dtree[i * 2] = 0;
        for(i = 0; i < 19; i++)bl_tree[i * 2] = 0;
        dyn_ltree[END_BLOCK * 2] = 1;
        that.opt_len = that.static_len = 0;
        last_lit = matches = 0;
    }
    function tr_init() {
        l_desc.dyn_tree = dyn_ltree;
        l_desc.stat_desc = StaticTree.static_l_desc;
        d_desc.dyn_tree = dyn_dtree;
        d_desc.stat_desc = StaticTree.static_d_desc;
        bl_desc.dyn_tree = bl_tree;
        bl_desc.stat_desc = StaticTree.static_bl_desc;
        bi_buf = 0;
        bi_valid = 0;
        last_eob_len = 8;
        init_block();
    }
    that.pqdownheap = function(tree, k) {
        const heap = that.heap;
        const v = heap[k];
        let j = k << 1;
        while(j <= that.heap_len){
            if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
                j++;
            }
            if (smaller(tree, v, heap[j], that.depth)) break;
            heap[k] = heap[j];
            k = j;
            j <<= 1;
        }
        heap[k] = v;
    };
    function scan_tree(tree, max_code) {
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for(let n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen != prevlen) bl_tree[curlen * 2]++;
                bl_tree[16 * 2]++;
            } else if (count <= 10) {
                bl_tree[17 * 2]++;
            } else {
                bl_tree[18 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function build_bl_tree() {
        let max_blindex;
        scan_tree(dyn_ltree, l_desc.max_code);
        scan_tree(dyn_dtree, d_desc.max_code);
        bl_desc.build_tree(that);
        for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){
            if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0) break;
        }
        that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    }
    function put_byte(p) {
        that.pending_buf[that.pending++] = p;
    }
    function put_short(w) {
        put_byte(w & 255);
        put_byte(w >>> 8 & 255);
    }
    function putShortMSB(b) {
        put_byte(b >> 8 & 255);
        put_byte(b & 255 & 255);
    }
    function send_bits(value, length) {
        let val;
        const len = length;
        if (bi_valid > Buf_size - len) {
            val = value;
            bi_buf |= val << bi_valid & 65535;
            put_short(bi_buf);
            bi_buf = val >>> Buf_size - bi_valid;
            bi_valid += len - Buf_size;
        } else {
            bi_buf |= value << bi_valid & 65535;
            bi_valid += len;
        }
    }
    function send_code(c, tree) {
        const c2 = c * 2;
        send_bits(tree[c2] & 65535, tree[c2 + 1] & 65535);
    }
    function send_tree(tree, max_code) {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for(n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(curlen, bl_tree);
                }while (--count !== 0)
            } else if (curlen !== 0) {
                if (curlen != prevlen) {
                    send_code(curlen, bl_tree);
                    count--;
                }
                send_code(16, bl_tree);
                send_bits(count - 3, 2);
            } else if (count <= 10) {
                send_code(17, bl_tree);
                send_bits(count - 3, 3);
            } else {
                send_code(18, bl_tree);
                send_bits(count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function send_all_trees(lcodes, dcodes, blcodes) {
        let rank;
        send_bits(lcodes - 257, 5);
        send_bits(dcodes - 1, 5);
        send_bits(blcodes - 4, 4);
        for(rank = 0; rank < blcodes; rank++){
            send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
        }
        send_tree(dyn_ltree, lcodes - 1);
        send_tree(dyn_dtree, dcodes - 1);
    }
    function bi_flush() {
        if (bi_valid == 16) {
            put_short(bi_buf);
            bi_buf = 0;
            bi_valid = 0;
        } else if (bi_valid >= 8) {
            put_byte(bi_buf & 255);
            bi_buf >>>= 8;
            bi_valid -= 8;
        }
    }
    function _tr_align() {
        send_bits(1 << 1, 3);
        send_code(256, StaticTree.static_ltree);
        bi_flush();
        if (1 + last_eob_len + 10 - bi_valid < 9) {
            send_bits(1 << 1, 3);
            send_code(256, StaticTree.static_ltree);
            bi_flush();
        }
        last_eob_len = 7;
    }
    function _tr_tally(dist, lc) {
        let out_length, in_length, dcode;
        that.pending_buf[d_buf + last_lit * 2] = dist >>> 8 & 255;
        that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 255;
        that.pending_buf[l_buf + last_lit] = lc & 255;
        last_lit++;
        if (dist === 0) {
            dyn_ltree[lc * 2]++;
        } else {
            matches++;
            dist--;
            dyn_ltree[(Tree._length_code[lc] + 256 + 1) * 2]++;
            dyn_dtree[Tree.d_code(dist) * 2]++;
        }
        if ((last_lit & 8191) === 0 && level > 2) {
            out_length = last_lit * 8;
            in_length = strstart - block_start;
            for(dcode = 0; dcode < 30; dcode++){
                out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
            }
            out_length >>>= 3;
            if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2)) return true;
        }
        return last_lit == lit_bufsize - 1;
    }
    function compress_block(ltree, dtree) {
        let dist;
        let lc;
        let lx = 0;
        let code;
        let extra;
        if (last_lit !== 0) {
            do {
                dist = that.pending_buf[d_buf + lx * 2] << 8 & 65280 | that.pending_buf[d_buf + lx * 2 + 1] & 255;
                lc = that.pending_buf[l_buf + lx] & 255;
                lx++;
                if (dist === 0) {
                    send_code(lc, ltree);
                } else {
                    code = Tree._length_code[lc];
                    send_code(code + 256 + 1, ltree);
                    extra = Tree.extra_lbits[code];
                    if (extra !== 0) {
                        lc -= Tree.base_length[code];
                        send_bits(lc, extra);
                    }
                    dist--;
                    code = Tree.d_code(dist);
                    send_code(code, dtree);
                    extra = Tree.extra_dbits[code];
                    if (extra !== 0) {
                        dist -= Tree.base_dist[code];
                        send_bits(dist, extra);
                    }
                }
            }while (lx < last_lit)
        }
        send_code(256, ltree);
        last_eob_len = ltree[END_BLOCK * 2 + 1];
    }
    function bi_windup() {
        if (bi_valid > 8) {
            put_short(bi_buf);
        } else if (bi_valid > 0) {
            put_byte(bi_buf & 255);
        }
        bi_buf = 0;
        bi_valid = 0;
    }
    function copy_block(buf, len, header) {
        bi_windup();
        last_eob_len = 8;
        if (header) {
            put_short(len);
            put_short(~len);
        }
        that.pending_buf.set(window.subarray(buf, buf + len), that.pending);
        that.pending += len;
    }
    function _tr_stored_block(buf, stored_len, eof) {
        send_bits((0 << 1) + (eof ? 1 : 0), 3);
        copy_block(buf, stored_len, true);
    }
    function _tr_flush_block(buf, stored_len, eof) {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (level > 0) {
            l_desc.build_tree(that);
            d_desc.build_tree(that);
            max_blindex = build_bl_tree();
            opt_lenb = that.opt_len + 3 + 7 >>> 3;
            static_lenb = that.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf != -1) {
            _tr_stored_block(buf, stored_len, eof);
        } else if (static_lenb == opt_lenb) {
            send_bits((1 << 1) + (eof ? 1 : 0), 3);
            compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
        } else {
            send_bits((2 << 1) + (eof ? 1 : 0), 3);
            send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
            compress_block(dyn_ltree, dyn_dtree);
        }
        init_block();
        if (eof) {
            bi_windup();
        }
    }
    function flush_block_only(eof) {
        _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
        block_start = strstart;
        strm.flush_pending();
    }
    function fill_window() {
        let n, m;
        let p;
        let more;
        do {
            more = window_size - lookahead - strstart;
            if (more === 0 && strstart === 0 && lookahead === 0) {
                more = w_size;
            } else if (more == -1) {
                more--;
            } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
                window.set(window.subarray(w_size, w_size + w_size), 0);
                match_start -= w_size;
                strstart -= w_size;
                block_start -= w_size;
                n = hash_size;
                p = n;
                do {
                    m = head[--p] & 65535;
                    head[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                n = w_size;
                p = n;
                do {
                    m = prev[--p] & 65535;
                    prev[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                more += w_size;
            }
            if (strm.avail_in === 0) return;
            n = strm.read_buf(window, strstart + lookahead, more);
            lookahead += n;
            if (lookahead >= 3) {
                ins_h = window[strstart] & 255;
                ins_h = (ins_h << hash_shift ^ window[strstart + 1] & 255) & hash_mask;
            }
        }while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0)
    }
    function deflate_stored(flush) {
        let max_block_size = 65535;
        let max_start;
        if (max_block_size > pending_buf_size - 5) {
            max_block_size = pending_buf_size - 5;
        }
        while(true){
            if (lookahead <= 1) {
                fill_window();
                if (lookahead === 0 && flush == 0) return 0;
                if (lookahead === 0) break;
            }
            strstart += lookahead;
            lookahead = 0;
            max_start = block_start + max_block_size;
            if (strstart === 0 || strstart >= max_start) {
                lookahead = strstart - max_start;
                strstart = max_start;
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
            if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) return flush == 4 ? 2 : 0;
        return flush == 4 ? 3 : 1;
    }
    function longest_match(cur_match) {
        let chain_length = max_chain_length;
        let scan = strstart;
        let match;
        let len;
        let best_len = prev_length;
        const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
        let _nice_match = nice_match;
        const wmask = w_mask;
        const strend = strstart + 258;
        let scan_end1 = window[scan + best_len - 1];
        let scan_end = window[scan + best_len];
        if (prev_length >= good_match) {
            chain_length >>= 2;
        }
        if (_nice_match > lookahead) _nice_match = lookahead;
        do {
            match = cur_match;
            if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) continue;
            scan += 2;
            match++;
            do {
            }while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend)
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                match_start = cur_match;
                best_len = len;
                if (len >= _nice_match) break;
                scan_end1 = window[scan + best_len - 1];
                scan_end = window[scan + best_len];
            }
        }while ((cur_match = prev[cur_match & wmask] & 65535) > limit && --chain_length !== 0)
        if (best_len <= lookahead) return best_len;
        return lookahead;
    }
    function deflate_fast(flush) {
        let hash_head = 0;
        let bflush;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
                hash_head = head[ins_h] & 65535;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            if (hash_head !== 0 && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
            }
            if (match_length >= 3) {
                bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
                lookahead -= match_length;
                if (match_length <= max_lazy_match && lookahead >= 3) {
                    match_length--;
                    do {
                        strstart++;
                        ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
                        hash_head = head[ins_h] & 65535;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }while (--match_length !== 0)
                    strstart++;
                } else {
                    strstart += match_length;
                    match_length = 0;
                    ins_h = window[strstart] & 255;
                    ins_h = (ins_h << hash_shift ^ window[strstart + 1] & 255) & hash_mask;
                }
            } else {
                bflush = _tr_tally(0, window[strstart] & 255);
                lookahead--;
                strstart++;
            }
            if (bflush) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflate_slow(flush) {
        let hash_head = 0;
        let bflush;
        let max_insert;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
                hash_head = head[ins_h] & 65535;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            prev_length = match_length;
            prev_match = match_start;
            match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
                if (match_length <= 5 && (strategy == 1 || match_length == 3 && strstart - match_start > 4096)) {
                    match_length = MIN_MATCH - 1;
                }
            }
            if (prev_length >= 3 && match_length <= prev_length) {
                max_insert = strstart + lookahead - MIN_MATCH;
                bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
                lookahead -= prev_length - 1;
                prev_length -= 2;
                do {
                    if (++strstart <= max_insert) {
                        ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
                        hash_head = head[ins_h] & 65535;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }
                }while (--prev_length !== 0)
                match_available = 0;
                match_length = MIN_MATCH - 1;
                strstart++;
                if (bflush) {
                    flush_block_only(false);
                    if (strm.avail_out === 0) return 0;
                }
            } else if (match_available !== 0) {
                bflush = _tr_tally(0, window[strstart - 1] & 255);
                if (bflush) {
                    flush_block_only(false);
                }
                strstart++;
                lookahead--;
                if (strm.avail_out === 0) return 0;
            } else {
                match_available = 1;
                strstart++;
                lookahead--;
            }
        }
        if (match_available !== 0) {
            bflush = _tr_tally(0, window[strstart - 1] & 255);
            match_available = 0;
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflateReset(strm) {
        strm.total_in = strm.total_out = 0;
        strm.msg = null;
        that.pending = 0;
        that.pending_out = 0;
        status = BUSY_STATE;
        last_flush = Z_NO_FLUSH;
        tr_init();
        lm_init();
        return 0;
    }
    that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {
        if (!_method) _method = Z_DEFLATED;
        if (!memLevel) memLevel = DEF_MEM_LEVEL;
        if (!_strategy) _strategy = Z_DEFAULT_STRATEGY;
        strm.msg = null;
        if (_level == Z_DEFAULT_COMPRESSION) _level = 6;
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        strm.dstate = that;
        w_bits = bits;
        w_size = 1 << w_bits;
        w_mask = w_size - 1;
        hash_bits = memLevel + 7;
        hash_size = 1 << hash_bits;
        hash_mask = hash_size - 1;
        hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        window = new Uint8Array(w_size * 2);
        prev = [];
        head = [];
        lit_bufsize = 1 << memLevel + 6;
        that.pending_buf = new Uint8Array(lit_bufsize * 4);
        pending_buf_size = lit_bufsize * 4;
        d_buf = Math.floor(lit_bufsize / 2);
        l_buf = (1 + 2) * lit_bufsize;
        level = _level;
        strategy = _strategy;
        return deflateReset(strm);
    };
    that.deflateEnd = function() {
        if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
            return Z_STREAM_ERROR;
        }
        that.pending_buf = null;
        head = null;
        prev = null;
        window = null;
        that.dstate = null;
        return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
    };
    that.deflateParams = function(strm, _level, _strategy) {
        let err = Z_OK;
        if (_level == Z_DEFAULT_COMPRESSION) {
            _level = 6;
        }
        if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
            err = strm.deflate(Z_PARTIAL_FLUSH);
        }
        if (level != _level) {
            level = _level;
            max_lazy_match = config_table[level].max_lazy;
            good_match = config_table[level].good_length;
            nice_match = config_table[level].nice_length;
            max_chain_length = config_table[level].max_chain;
        }
        strategy = _strategy;
        return err;
    };
    that.deflateSetDictionary = function(strm, dictionary, dictLength) {
        let length = dictLength;
        let n, index = 0;
        if (!dictionary || status != INIT_STATE) return Z_STREAM_ERROR;
        if (length < MIN_MATCH) return Z_OK;
        if (length > w_size - MIN_LOOKAHEAD) {
            length = w_size - MIN_LOOKAHEAD;
            index = dictLength - length;
        }
        window.set(dictionary.subarray(index, index + length), 0);
        strstart = length;
        block_start = length;
        ins_h = window[0] & 255;
        ins_h = (ins_h << hash_shift ^ window[1] & 255) & hash_mask;
        for(n = 0; n <= length - MIN_MATCH; n++){
            ins_h = (ins_h << hash_shift ^ window[n + (MIN_MATCH - 1)] & 255) & hash_mask;
            prev[n & w_mask] = head[ins_h];
            head[ins_h] = n;
        }
        return Z_OK;
    };
    that.deflate = function(_strm, flush) {
        let i, header, level_flags, old_flush, bstate;
        if (flush > Z_FINISH || flush < 0) {
            return Z_STREAM_ERROR;
        }
        if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];
            return Z_STREAM_ERROR;
        }
        if (_strm.avail_out === 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        strm = _strm;
        old_flush = last_flush;
        last_flush = flush;
        if (status == INIT_STATE) {
            header = Z_DEFLATED + (w_bits - 8 << 4) << 8;
            level_flags = (level - 1 & 255) >> 1;
            if (level_flags > 3) level_flags = 3;
            header |= level_flags << 6;
            if (strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            status = BUSY_STATE;
            putShortMSB(header);
        }
        if (that.pending !== 0) {
            strm.flush_pending();
            if (strm.avail_out === 0) {
                last_flush = -1;
                return Z_OK;
            }
        } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
            strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (status == FINISH_STATE && strm.avail_in !== 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {
            bstate = -1;
            switch(config_table[level].func){
                case STORED:
                    bstate = deflate_stored(flush);
                    break;
                case FAST:
                    bstate = deflate_fast(flush);
                    break;
                case SLOW:
                    bstate = deflate_slow(flush);
                    break;
                default:
            }
            if (bstate == FinishStarted || bstate == FinishDone) {
                status = FINISH_STATE;
            }
            if (bstate == NeedMore || bstate == FinishStarted) {
                if (strm.avail_out === 0) {
                    last_flush = -1;
                }
                return Z_OK;
            }
            if (bstate == BlockDone) {
                if (flush == Z_PARTIAL_FLUSH) {
                    _tr_align();
                } else {
                    _tr_stored_block(0, 0, false);
                    if (flush == Z_FULL_FLUSH) {
                        for(i = 0; i < hash_size; i++)head[i] = 0;
                    }
                }
                strm.flush_pending();
                if (strm.avail_out === 0) {
                    last_flush = -1;
                    return Z_OK;
                }
            }
        }
        if (flush != Z_FINISH) return Z_OK;
        return Z_STREAM_END;
    };
}
function ZStream() {
    const that = this;
    that.next_in_index = 0;
    that.next_out_index = 0;
    that.avail_in = 0;
    that.total_in = 0;
    that.avail_out = 0;
    that.total_out = 0;
}
ZStream.prototype = {
    deflateInit: function(level, bits) {
        const that = this;
        that.dstate = new Deflate();
        if (!bits) bits = MAX_BITS;
        return that.dstate.deflateInit(that, level, bits);
    },
    deflate: function(flush) {
        const that = this;
        if (!that.dstate) {
            return Z_STREAM_ERROR;
        }
        return that.dstate.deflate(that, flush);
    },
    deflateEnd: function() {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        const ret = that.dstate.deflateEnd();
        that.dstate = null;
        return ret;
    },
    deflateParams: function(level, strategy) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateParams(that, level, strategy);
    },
    deflateSetDictionary: function(dictionary, dictLength) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
    },
    read_buf: function(buf, start, size) {
        const that = this;
        let len = that.avail_in;
        if (len > size) len = size;
        if (len === 0) return 0;
        that.avail_in -= len;
        buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
        that.next_in_index += len;
        that.total_in += len;
        return len;
    },
    flush_pending: function() {
        const that = this;
        let len = that.dstate.pending;
        if (len > that.avail_out) len = that.avail_out;
        if (len === 0) return;
        that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
        that.next_out_index += len;
        that.dstate.pending_out += len;
        that.total_out += len;
        that.avail_out -= len;
        that.dstate.pending -= len;
        if (that.dstate.pending === 0) {
            that.dstate.pending_out = 0;
        }
    }
};
function ZipDeflate(options) {
    const that = this;
    const z = new ZStream();
    const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let level = options ? options.level : Z_DEFAULT_COMPRESSION;
    if (typeof level == "undefined") level = Z_DEFAULT_COMPRESSION;
    z.deflateInit(level);
    z.next_out = buf;
    that.append = function(data, onprogress) {
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        if (!data.length) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(flush);
            if (err != Z_OK) throw new Error("deflating: " + z.msg);
            if (z.next_out_index) if (z.next_out_index == bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] || new Uint8Array(0);
        }
        return array;
    };
    that.flush = function() {
        let err, array, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(Z_FINISH);
            if (err != Z_STREAM_END && err != Z_OK) throw new Error("deflating: " + z.msg);
            if (bufsize - z.avail_out > 0) buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
        }while (z.avail_in > 0 || z.avail_out === 0)
        z.deflateEnd();
        array = new Uint8Array(bufferSize);
        buffers.forEach(function(chunk) {
            array.set(chunk, bufferIndex);
            bufferIndex += chunk.length;
        });
        return array;
    };
}
function getMaximumCompressedSize(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
const MAX_BITS1 = 15;
const Z_OK1 = 0;
const Z_STREAM_END1 = 1;
const Z_NEED_DICT1 = 2;
const Z_STREAM_ERROR1 = -2;
const Z_DATA_ERROR1 = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR1 = -5;
const inflate_mask = [
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535
];
const Z_FINISH1 = 4;
const fixed_bl = 9;
const fixed_bd = 5;
const fixed_tl = [
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    192,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    160,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    224,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    144,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    208,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    176,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    240,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    200,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    168,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    232,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    152,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    216,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    184,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    248,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    196,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    164,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    228,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    148,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    212,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    180,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    244,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    204,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    172,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    236,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    156,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    220,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    188,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    252,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    194,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    162,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    226,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    146,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    210,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    178,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    242,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    202,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    170,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    234,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    154,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    218,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    186,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    250,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    198,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    166,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    230,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    150,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    214,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    182,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    246,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    206,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    174,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    238,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    158,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    222,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    190,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    254,
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    193,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    161,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    225,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    145,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    209,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    177,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    241,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    201,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    169,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    233,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    153,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    217,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    185,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    249,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    197,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    165,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    229,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    149,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    213,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    181,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    245,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    205,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    173,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    237,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    157,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    221,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    189,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    253,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    195,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    163,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    227,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    147,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    211,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    179,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    243,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    203,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    171,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    235,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    155,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    219,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    187,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    251,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    199,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    167,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    231,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    151,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    215,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    183,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    247,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    207,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    175,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    239,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    159,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    223,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    191,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    255
];
const fixed_td = [
    80,
    5,
    1,
    87,
    5,
    257,
    83,
    5,
    17,
    91,
    5,
    4097,
    81,
    5,
    5,
    89,
    5,
    1025,
    85,
    5,
    65,
    93,
    5,
    16385,
    80,
    5,
    3,
    88,
    5,
    513,
    84,
    5,
    33,
    92,
    5,
    8193,
    82,
    5,
    9,
    90,
    5,
    2049,
    86,
    5,
    129,
    192,
    5,
    24577,
    80,
    5,
    2,
    87,
    5,
    385,
    83,
    5,
    25,
    91,
    5,
    6145,
    81,
    5,
    7,
    89,
    5,
    1537,
    85,
    5,
    97,
    93,
    5,
    24577,
    80,
    5,
    4,
    88,
    5,
    769,
    84,
    5,
    49,
    92,
    5,
    12289,
    82,
    5,
    13,
    90,
    5,
    3073,
    86,
    5,
    193,
    192,
    5,
    24577
];
const cplens = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
];
const cplext = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    112,
    112
];
const cpdist = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577
];
const cpdext = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
const BMAX = 15;
function InfTree() {
    const that = this;
    let hn;
    let v;
    let c;
    let r;
    let u;
    let x;
    function huft_build(b, bindex, n, s, d, e, t, m, hp, hn, v) {
        let a;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let mask;
        let p;
        let q;
        let w;
        let xp;
        let y;
        let z;
        p = 0;
        i = n;
        do {
            c[b[bindex + p]]++;
            p++;
            i--;
        }while (i !== 0)
        if (c[0] == n) {
            t[0] = -1;
            m[0] = 0;
            return 0;
        }
        l = m[0];
        for(j = 1; j <= 15; j++)if (c[j] !== 0) break;
        k = j;
        if (l < j) {
            l = j;
        }
        for(i = BMAX; i !== 0; i--){
            if (c[i] !== 0) break;
        }
        g = i;
        if (l > i) {
            l = i;
        }
        m[0] = l;
        for(y = 1 << j; j < i; j++, y <<= 1){
            if ((y -= c[j]) < 0) {
                return Z_DATA_ERROR1;
            }
        }
        if ((y -= c[i]) < 0) {
            return Z_DATA_ERROR1;
        }
        c[i] += y;
        x[1] = j = 0;
        p = 1;
        xp = 2;
        while(--i !== 0){
            x[xp] = j += c[p];
            xp++;
            p++;
        }
        i = 0;
        p = 0;
        do {
            if ((j = b[bindex + p]) !== 0) {
                v[x[j]++] = i;
            }
            p++;
        }while (++i < n)
        n = x[g];
        x[0] = i = 0;
        p = 0;
        h = -1;
        w = -l;
        u[0] = 0;
        q = 0;
        z = 0;
        for(; k <= g; k++){
            a = c[k];
            while((a--) !== 0){
                while(k > w + l){
                    h++;
                    w += l;
                    z = g - w;
                    z = z > l ? l : z;
                    if ((f = 1 << (j = k - w)) > a + 1) {
                        f -= a + 1;
                        xp = k;
                        if (j < z) {
                            while(++j < z){
                                if ((f <<= 1) <= c[++xp]) break;
                                f -= c[xp];
                            }
                        }
                    }
                    z = 1 << j;
                    if (hn[0] + z > 1440) {
                        return Z_DATA_ERROR1;
                    }
                    u[h] = q = hn[0];
                    hn[0] += z;
                    if (h !== 0) {
                        x[h] = i;
                        r[0] = j;
                        r[1] = l;
                        j = i >>> w - l;
                        r[2] = q - u[h - 1] - j;
                        hp.set(r, (u[h - 1] + j) * 3);
                    } else {
                        t[0] = q;
                    }
                }
                r[1] = k - w;
                if (p >= n) {
                    r[0] = 128 + 64;
                } else if (v[p] < s) {
                    r[0] = v[p] < 256 ? 0 : 32 + 64;
                    r[2] = v[p++];
                } else {
                    r[0] = e[v[p] - s] + 16 + 64;
                    r[2] = d[v[p++] - s];
                }
                f = 1 << k - w;
                for(j = i >>> w; j < z; j += f){
                    hp.set(r, (q + j) * 3);
                }
                for(j = 1 << k - 1; (i & j) !== 0; j >>>= 1){
                    i ^= j;
                }
                i ^= j;
                mask = (1 << w) - 1;
                while((i & mask) != x[h]){
                    h--;
                    w -= l;
                    mask = (1 << w) - 1;
                }
            }
        }
        return y !== 0 && g != 1 ? Z_BUF_ERROR1 : 0;
    }
    function initWorkArea(vsize) {
        let i;
        if (!hn) {
            hn = [];
            v = [];
            c = new Int32Array(BMAX + 1);
            r = [];
            u = new Int32Array(BMAX);
            x = new Int32Array(BMAX + 1);
        }
        if (v.length < vsize) {
            v = [];
        }
        for(i = 0; i < vsize; i++){
            v[i] = 0;
        }
        for(i = 0; i < 15 + 1; i++){
            c[i] = 0;
        }
        for(i = 0; i < 3; i++){
            r[i] = 0;
        }
        u.set(c.subarray(0, 15), 0);
        x.set(c.subarray(0, 15 + 1), 0);
    }
    that.inflate_trees_bits = function(c, bb, tb, hp, z) {
        let result;
        initWorkArea(19);
        hn[0] = 0;
        result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
        if (result == Z_DATA_ERROR1) {
            z.msg = "oversubscribed dynamic bit lengths tree";
        } else if (result == Z_BUF_ERROR1 || bb[0] === 0) {
            z.msg = "incomplete dynamic bit lengths tree";
            result = Z_DATA_ERROR1;
        }
        return result;
    };
    that.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
        let result;
        initWorkArea(288);
        hn[0] = 0;
        result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
        if (result != Z_OK1 || bl[0] === 0) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed literal/length tree";
            } else if (result != Z_MEM_ERROR) {
                z.msg = "incomplete literal/length tree";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        initWorkArea(288);
        result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
        if (result != Z_OK1 || bd[0] === 0 && nl > 257) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed distance tree";
            } else if (result == Z_BUF_ERROR1) {
                z.msg = "incomplete distance tree";
                result = Z_DATA_ERROR1;
            } else if (result != Z_MEM_ERROR) {
                z.msg = "empty distance tree with lengths";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        return Z_OK1;
    };
}
InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
    bl[0] = fixed_bl;
    bd[0] = fixed_bd;
    tl[0] = fixed_tl;
    td[0] = fixed_td;
    return Z_OK1;
};
const START = 0;
const LEN = 1;
const LENEXT = 2;
const DIST = 3;
const DISTEXT = 4;
const COPY = 5;
const LIT = 6;
const WASH = 7;
const END = 8;
const BADCODE = 9;
function InfCodes() {
    const that = this;
    let mode;
    let len = 0;
    let tree;
    let tree_index = 0;
    let need = 0;
    let lit = 0;
    let get = 0;
    let dist = 0;
    let lbits = 0;
    let dbits = 0;
    let ltree;
    let ltree_index = 0;
    let dtree;
    let dtree_index = 0;
    function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
        let t;
        let tp;
        let tp_index;
        let e;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let ml;
        let md;
        let c;
        let d;
        let r;
        let tp_index_t_3;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        ml = inflate_mask[bl];
        md = inflate_mask[bd];
        do {
            while(k < 20){
                n--;
                b |= (z.read_byte(p++) & 255) << k;
                k += 8;
            }
            t = b & ml;
            tp = tl;
            tp_index = tl_index;
            tp_index_t_3 = (tp_index + t) * 3;
            if ((e = tp[tp_index_t_3]) === 0) {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                s.window[q++] = tp[tp_index_t_3 + 2];
                m--;
                continue;
            }
            do {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                if ((e & 16) !== 0) {
                    e &= 15;
                    c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                    b >>= e;
                    k -= e;
                    while(k < 15){
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    t = b & md;
                    tp = td;
                    tp_index = td_index;
                    tp_index_t_3 = (tp_index + t) * 3;
                    e = tp[tp_index_t_3];
                    do {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        if ((e & 16) !== 0) {
                            e &= 15;
                            while(k < e){
                                n--;
                                b |= (z.read_byte(p++) & 255) << k;
                                k += 8;
                            }
                            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                            b >>= e;
                            k -= e;
                            m -= c;
                            if (q >= d) {
                                r = q - d;
                                if (q - r > 0 && 2 > q - r) {
                                    s.window[q++] = s.window[r++];
                                    s.window[q++] = s.window[r++];
                                    c -= 2;
                                } else {
                                    s.window.set(s.window.subarray(r, r + 2), q);
                                    q += 2;
                                    r += 2;
                                    c -= 2;
                                }
                            } else {
                                r = q - d;
                                do {
                                    r += s.end;
                                }while (r < 0)
                                e = s.end - r;
                                if (c > e) {
                                    c -= e;
                                    if (q - r > 0 && e > q - r) {
                                        do {
                                            s.window[q++] = s.window[r++];
                                        }while (--e !== 0)
                                    } else {
                                        s.window.set(s.window.subarray(r, r + e), q);
                                        q += e;
                                        r += e;
                                        e = 0;
                                    }
                                    r = 0;
                                }
                            }
                            if (q - r > 0 && c > q - r) {
                                do {
                                    s.window[q++] = s.window[r++];
                                }while (--c !== 0)
                            } else {
                                s.window.set(s.window.subarray(r, r + c), q);
                                q += c;
                                r += c;
                                c = 0;
                            }
                            break;
                        } else if ((e & 64) === 0) {
                            t += tp[tp_index_t_3 + 2];
                            t += b & inflate_mask[e];
                            tp_index_t_3 = (tp_index + t) * 3;
                            e = tp[tp_index_t_3];
                        } else {
                            z.msg = "invalid distance code";
                            c = z.avail_in - n;
                            c = k >> 3 < c ? k >> 3 : c;
                            n += c;
                            p -= c;
                            k -= c << 3;
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return Z_DATA_ERROR1;
                        }
                    }while (true)
                    break;
                }
                if ((e & 64) === 0) {
                    t += tp[tp_index_t_3 + 2];
                    t += b & inflate_mask[e];
                    tp_index_t_3 = (tp_index + t) * 3;
                    if ((e = tp[tp_index_t_3]) === 0) {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        s.window[q++] = tp[tp_index_t_3 + 2];
                        m--;
                        break;
                    }
                } else if ((e & 32) !== 0) {
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return 1;
                } else {
                    z.msg = "invalid literal/length code";
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return Z_DATA_ERROR1;
                }
            }while (true)
        }while (m >= 258 && n >= 10)
        c = z.avail_in - n;
        c = k >> 3 < c ? k >> 3 : c;
        n += c;
        p -= c;
        k -= c << 3;
        s.bitb = b;
        s.bitk = k;
        z.avail_in = n;
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        s.write = q;
        return 0;
    }
    that.init = function(bl, bd, tl, tl_index, td, td_index) {
        mode = START;
        lbits = bl;
        dbits = bd;
        ltree = tl;
        ltree_index = tl_index;
        dtree = td;
        dtree_index = td_index;
        tree = null;
    };
    that.proc = function(s, z, r) {
        let j;
        let tindex;
        let e;
        let b = 0;
        let k = 0;
        let p = 0;
        let n;
        let q;
        let m;
        let f;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        while(true){
            switch(mode){
                case START:
                    if (m >= 258 && n >= 10) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
                        p = z.next_in_index;
                        n = z.avail_in;
                        b = s.bitb;
                        k = s.bitk;
                        q = s.write;
                        m = q < s.read ? s.read - q - 1 : s.end - q;
                        if (r != Z_OK1) {
                            mode = r == Z_STREAM_END1 ? WASH : BADCODE;
                            break;
                        }
                    }
                    need = lbits;
                    tree = ltree;
                    tree_index = ltree_index;
                    mode = LEN;
                case LEN:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if (e === 0) {
                        lit = tree[tindex + 2];
                        mode = LIT;
                        break;
                    }
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        len = tree[tindex + 2];
                        mode = LENEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    if ((e & 32) !== 0) {
                        mode = WASH;
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid literal/length code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case LENEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    len += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    need = dbits;
                    tree = dtree;
                    tree_index = dtree_index;
                    mode = DIST;
                case DIST:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        dist = tree[tindex + 2];
                        mode = DISTEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid distance code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case DISTEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    dist += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    mode = COPY;
                case COPY:
                    f = q - dist;
                    while(f < 0){
                        f += s.end;
                    }
                    while(len !== 0){
                        if (m === 0) {
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.write = q;
                                r = s.inflate_flush(z, r);
                                q = s.write;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                                if (q == s.end && s.read !== 0) {
                                    q = 0;
                                    m = q < s.read ? s.read - q - 1 : s.end - q;
                                }
                                if (m === 0) {
                                    s.bitb = b;
                                    s.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    s.write = q;
                                    return s.inflate_flush(z, r);
                                }
                            }
                        }
                        s.window[q++] = s.window[f++];
                        m--;
                        if (f == s.end) f = 0;
                        len--;
                    }
                    mode = START;
                    break;
                case LIT:
                    if (m === 0) {
                        if (q == s.end && s.read !== 0) {
                            q = 0;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                        }
                        if (m === 0) {
                            s.write = q;
                            r = s.inflate_flush(z, r);
                            q = s.write;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.bitb = b;
                                s.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                s.write = q;
                                return s.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    s.window[q++] = lit;
                    m--;
                    mode = START;
                    break;
                case WASH:
                    if (k > 7) {
                        k -= 8;
                        n++;
                        p--;
                    }
                    s.write = q;
                    r = s.inflate_flush(z, r);
                    q = s.write;
                    m = q < s.read ? s.read - q - 1 : s.end - q;
                    if (s.read != s.write) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        return s.inflate_flush(z, r);
                    }
                    mode = END;
                case END:
                    r = Z_STREAM_END1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case BADCODE:
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
            }
        }
    };
    that.free = function() {
    };
}
const border = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
const TYPE = 0;
const LENS = 1;
const STORED1 = 2;
const TABLE = 3;
const BTREE = 4;
const DTREE = 5;
const CODES = 6;
const DRY = 7;
const DONELOCKS = 8;
const BADBLOCKS = 9;
function InfBlocks(z, w) {
    const that = this;
    let mode = 0;
    let left = 0;
    let table = 0;
    let index = 0;
    let blens;
    const bb = [
        0
    ];
    const tb = [
        0
    ];
    const codes = new InfCodes();
    let last = 0;
    let hufts = new Int32Array(1440 * 3);
    const check = 0;
    const inftree = new InfTree();
    that.bitk = 0;
    that.bitb = 0;
    that.window = new Uint8Array(w);
    that.end = w;
    that.read = 0;
    that.write = 0;
    that.reset = function(z, c) {
        if (c) c[0] = check;
        if (mode == CODES) {
            codes.free(z);
        }
        mode = TYPE;
        that.bitk = 0;
        that.bitb = 0;
        that.read = that.write = 0;
    };
    that.reset(z, null);
    that.inflate_flush = function(z, r) {
        let n;
        let p;
        let q;
        p = z.next_out_index;
        q = that.read;
        n = (q <= that.write ? that.write : that.end) - q;
        if (n > z.avail_out) n = z.avail_out;
        if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
        z.avail_out -= n;
        z.total_out += n;
        z.next_out.set(that.window.subarray(q, q + n), p);
        p += n;
        q += n;
        if (q == that.end) {
            q = 0;
            if (that.write == that.end) that.write = 0;
            n = that.write - q;
            if (n > z.avail_out) n = z.avail_out;
            if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
            z.avail_out -= n;
            z.total_out += n;
            z.next_out.set(that.window.subarray(q, q + n), p);
            p += n;
            q += n;
        }
        z.next_out_index = p;
        that.read = q;
        return r;
    };
    that.proc = function(z, r) {
        let t;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let i;
        p = z.next_in_index;
        n = z.avail_in;
        b = that.bitb;
        k = that.bitk;
        q = that.write;
        m = q < that.read ? that.read - q - 1 : that.end - q;
        while(true){
            let bl, bd, tl, td, bl_, bd_, tl_, td_;
            switch(mode){
                case TYPE:
                    while(k < 3){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    t = b & 7;
                    last = t & 1;
                    switch(t >>> 1){
                        case 0:
                            b >>>= 3;
                            k -= 3;
                            t = k & 7;
                            b >>>= t;
                            k -= t;
                            mode = LENS;
                            break;
                        case 1:
                            bl = [];
                            bd = [];
                            tl = [
                                []
                            ];
                            td = [
                                []
                            ];
                            InfTree.inflate_trees_fixed(bl, bd, tl, td);
                            codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
                            b >>>= 3;
                            k -= 3;
                            mode = CODES;
                            break;
                        case 2:
                            b >>>= 3;
                            k -= 3;
                            mode = TABLE;
                            break;
                        case 3:
                            b >>>= 3;
                            k -= 3;
                            mode = BADBLOCKS;
                            z.msg = "invalid block type";
                            r = Z_DATA_ERROR1;
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                    }
                    break;
                case LENS:
                    while(k < 32){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    if ((~b >>> 16 & 65535) != (b & 65535)) {
                        mode = BADBLOCKS;
                        z.msg = "invalid stored block lengths";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    left = b & 65535;
                    b = k = 0;
                    mode = left !== 0 ? STORED1 : last !== 0 ? DRY : TYPE;
                    break;
                case STORED1:
                    if (n === 0) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    if (m === 0) {
                        if (q == that.end && that.read !== 0) {
                            q = 0;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                        }
                        if (m === 0) {
                            that.write = q;
                            r = that.inflate_flush(z, r);
                            q = that.write;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                            if (q == that.end && that.read !== 0) {
                                q = 0;
                                m = q < that.read ? that.read - q - 1 : that.end - q;
                            }
                            if (m === 0) {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    t = left;
                    if (t > n) t = n;
                    if (t > m) t = m;
                    that.window.set(z.read_buf(p, t), q);
                    p += t;
                    n -= t;
                    q += t;
                    m -= t;
                    if ((left -= t) !== 0) break;
                    mode = last !== 0 ? DRY : TYPE;
                    break;
                case TABLE:
                    while(k < 14){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 255) << k;
                        k += 8;
                    }
                    table = t = b & 16383;
                    if ((t & 31) > 29 || (t >> 5 & 31) > 29) {
                        mode = BADBLOCKS;
                        z.msg = "too many length or distance symbols";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    t = 258 + (t & 31) + (t >> 5 & 31);
                    if (!blens || blens.length < t) {
                        blens = [];
                    } else {
                        for(i = 0; i < t; i++){
                            blens[i] = 0;
                        }
                    }
                    b >>>= 14;
                    k -= 14;
                    index = 0;
                    mode = BTREE;
                case BTREE:
                    while(index < 4 + (table >>> 10)){
                        while(k < 3){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 255) << k;
                            k += 8;
                        }
                        blens[border[index++]] = b & 7;
                        b >>>= 3;
                        k -= 3;
                    }
                    while(index < 19){
                        blens[border[index++]] = 0;
                    }
                    bb[0] = 7;
                    t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
                    if (t != Z_OK1) {
                        r = t;
                        if (r == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    index = 0;
                    mode = DTREE;
                case DTREE:
                    while(true){
                        t = table;
                        if (index >= 258 + (t & 31) + (t >> 5 & 31)) {
                            break;
                        }
                        let j, c;
                        t = bb[0];
                        while(k < t){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 255) << k;
                            k += 8;
                        }
                        t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
                        c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];
                        if (c < 16) {
                            b >>>= t;
                            k -= t;
                            blens[index++] = c;
                        } else {
                            i = c == 18 ? 7 : c - 14;
                            j = c == 18 ? 11 : 3;
                            while(k < t + i){
                                if (n !== 0) {
                                    r = Z_OK1;
                                } else {
                                    that.bitb = b;
                                    that.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    that.write = q;
                                    return that.inflate_flush(z, r);
                                }
                                n--;
                                b |= (z.read_byte(p++) & 255) << k;
                                k += 8;
                            }
                            b >>>= t;
                            k -= t;
                            j += b & inflate_mask[i];
                            b >>>= i;
                            k -= i;
                            i = index;
                            t = table;
                            if (i + j > 258 + (t & 31) + (t >> 5 & 31) || c == 16 && i < 1) {
                                blens = null;
                                mode = BADBLOCKS;
                                z.msg = "invalid bit length repeat";
                                r = Z_DATA_ERROR1;
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            c = c == 16 ? blens[i - 1] : 0;
                            do {
                                blens[i++] = c;
                            }while (--j !== 0)
                            index = i;
                        }
                    }
                    tb[0] = -1;
                    bl_ = [];
                    bd_ = [];
                    tl_ = [];
                    td_ = [];
                    bl_[0] = 9;
                    bd_[0] = 6;
                    t = table;
                    t = inftree.inflate_trees_dynamic(257 + (t & 31), 1 + (t >> 5 & 31), blens, bl_, bd_, tl_, td_, hufts, z);
                    if (t != Z_OK1) {
                        if (t == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        r = t;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
                    mode = CODES;
                case CODES:
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    if ((r = codes.proc(that, z, r)) != Z_STREAM_END1) {
                        return that.inflate_flush(z, r);
                    }
                    r = Z_OK1;
                    codes.free(z);
                    p = z.next_in_index;
                    n = z.avail_in;
                    b = that.bitb;
                    k = that.bitk;
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (last === 0) {
                        mode = TYPE;
                        break;
                    }
                    mode = DRY;
                case DRY:
                    that.write = q;
                    r = that.inflate_flush(z, r);
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (that.read != that.write) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    mode = DONELOCKS;
                case DONELOCKS:
                    r = Z_STREAM_END1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                case BADBLOCKS:
                    r = Z_DATA_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
            }
        }
    };
    that.free = function(z) {
        that.reset(z, null);
        that.window = null;
        hufts = null;
    };
    that.set_dictionary = function(d, start, n) {
        that.window.set(d.subarray(start, start + n), 0);
        that.read = that.write = n;
    };
    that.sync_point = function() {
        return mode == LENS ? 1 : 0;
    };
}
const PRESET_DICT1 = 32;
const Z_DEFLATED1 = 8;
const METHOD = 0;
const FLAG = 1;
const DICT4 = 2;
const DICT3 = 3;
const DICT2 = 4;
const DICT1 = 5;
const DICT0 = 6;
const BLOCKS = 7;
const DONE = 12;
const BAD = 13;
const mark = [
    0,
    0,
    255,
    255
];
function Inflate() {
    const that = this;
    that.mode = 0;
    that.method = 0;
    that.was = [
        0
    ];
    that.need = 0;
    that.marker = 0;
    that.wbits = 0;
    function inflateReset(z) {
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        z.total_in = z.total_out = 0;
        z.msg = null;
        z.istate.mode = BLOCKS;
        z.istate.blocks.reset(z, null);
        return 0;
    }
    that.inflateEnd = function(z) {
        if (that.blocks) that.blocks.free(z);
        that.blocks = null;
        return Z_OK1;
    };
    that.inflateInit = function(z, w) {
        z.msg = null;
        that.blocks = null;
        if (w < 8 || w > 15) {
            that.inflateEnd(z);
            return Z_STREAM_ERROR1;
        }
        that.wbits = w;
        z.istate.blocks = new InfBlocks(z, 1 << w);
        inflateReset(z);
        return Z_OK1;
    };
    that.inflate = function(z, f) {
        let r;
        let b;
        if (!z || !z.istate || !z.next_in) return Z_STREAM_ERROR1;
        const istate = z.istate;
        f = f == Z_FINISH1 ? Z_BUF_ERROR1 : Z_OK1;
        r = Z_BUF_ERROR1;
        while(true){
            switch(istate.mode){
                case METHOD:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    if (((istate.method = z.read_byte(z.next_in_index++)) & 15) != Z_DEFLATED1) {
                        istate.mode = BAD;
                        z.msg = "unknown compression method";
                        istate.marker = 5;
                        break;
                    }
                    if ((istate.method >> 4) + 8 > istate.wbits) {
                        istate.mode = BAD;
                        z.msg = "invalid window size";
                        istate.marker = 5;
                        break;
                    }
                    istate.mode = FLAG;
                case FLAG:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    b = z.read_byte(z.next_in_index++) & 255;
                    if (((istate.method << 8) + b) % 31 !== 0) {
                        istate.mode = BAD;
                        z.msg = "incorrect header check";
                        istate.marker = 5;
                        break;
                    }
                    if ((b & PRESET_DICT1) === 0) {
                        istate.mode = BLOCKS;
                        break;
                    }
                    istate.mode = DICT4;
                case DICT4:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need = (z.read_byte(z.next_in_index++) & 255) << 24 & 4278190080;
                    istate.mode = DICT3;
                case DICT3:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 255) << 16 & 16711680;
                    istate.mode = DICT2;
                case DICT2:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 255) << 8 & 65280;
                    istate.mode = DICT1;
                case DICT1:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += z.read_byte(z.next_in_index++) & 255;
                    istate.mode = DICT0;
                    return Z_NEED_DICT1;
                case DICT0:
                    istate.mode = BAD;
                    z.msg = "need dictionary";
                    istate.marker = 0;
                    return Z_STREAM_ERROR1;
                case BLOCKS:
                    r = istate.blocks.proc(z, r);
                    if (r == Z_DATA_ERROR1) {
                        istate.mode = BAD;
                        istate.marker = 0;
                        break;
                    }
                    if (r == Z_OK1) {
                        r = f;
                    }
                    if (r != Z_STREAM_END1) {
                        return r;
                    }
                    r = f;
                    istate.blocks.reset(z, istate.was);
                    istate.mode = DONE;
                case DONE:
                    return Z_STREAM_END1;
                case BAD:
                    return Z_DATA_ERROR1;
                default:
                    return Z_STREAM_ERROR1;
            }
        }
    };
    that.inflateSetDictionary = function(z, dictionary, dictLength) {
        let index = 0, length = dictLength;
        if (!z || !z.istate || z.istate.mode != DICT0) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (length >= 1 << istate.wbits) {
            length = (1 << istate.wbits) - 1;
            index = dictLength - length;
        }
        istate.blocks.set_dictionary(dictionary, index, length);
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSync = function(z) {
        let n;
        let p;
        let m;
        let r, w;
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (istate.mode != BAD) {
            istate.mode = BAD;
            istate.marker = 0;
        }
        if ((n = z.avail_in) === 0) return Z_BUF_ERROR1;
        p = z.next_in_index;
        m = istate.marker;
        while(n !== 0 && m < 4){
            if (z.read_byte(p) == mark[m]) {
                m++;
            } else if (z.read_byte(p) !== 0) {
                m = 0;
            } else {
                m = 4 - m;
            }
            p++;
            n--;
        }
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        z.avail_in = n;
        istate.marker = m;
        if (m != 4) {
            return Z_DATA_ERROR1;
        }
        r = z.total_in;
        w = z.total_out;
        inflateReset(z);
        z.total_in = r;
        z.total_out = w;
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSyncPoint = function(z) {
        if (!z || !z.istate || !z.istate.blocks) return Z_STREAM_ERROR1;
        return z.istate.blocks.sync_point();
    };
}
function ZStream1() {
}
ZStream1.prototype = {
    inflateInit: function(bits) {
        const that = this;
        that.istate = new Inflate();
        if (!bits) bits = MAX_BITS1;
        return that.istate.inflateInit(that, bits);
    },
    inflate: function(f) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflate(that, f);
    },
    inflateEnd: function() {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        const ret = that.istate.inflateEnd(that);
        that.istate = null;
        return ret;
    },
    inflateSync: function() {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSync(that);
    },
    inflateSetDictionary: function(dictionary, dictLength) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSetDictionary(that, dictionary, dictLength);
    },
    read_byte: function(start) {
        const that = this;
        return that.next_in[start];
    },
    read_buf: function(start, size) {
        const that = this;
        return that.next_in.subarray(start, start + size);
    }
};
function ZipInflate(options) {
    const that = this;
    const z = new ZStream1();
    const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let nomoreinput = false;
    z.inflateInit();
    z.next_out = buf;
    that.append = function(data, onprogress) {
        const buffers = [];
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        if (data.length === 0) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            if (z.avail_in === 0 && !nomoreinput) {
                z.next_in_index = 0;
                nomoreinput = true;
            }
            err = z.inflate(flush);
            if (nomoreinput && err === Z_BUF_ERROR1) {
                if (z.avail_in !== 0) throw new Error("inflating: bad input");
            } else if (err !== Z_OK1 && err !== Z_STREAM_END1) throw new Error("inflating: " + z.msg);
            if ((nomoreinput || err === Z_STREAM_END1) && z.avail_in === data.length) throw new Error("inflating: bad input");
            if (z.next_out_index) if (z.next_out_index === bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] || new Uint8Array(0);
        }
        return array;
    };
    that.flush = function() {
        z.inflateEnd();
    };
}
const DEFAULT_CONFIGURATION = {
    chunkSize: 512 * 1024,
    maxWorkers: typeof navigator != "undefined" && navigator.hardwareConcurrency || 2,
    terminateWorkerTimeout: 5000,
    useWebWorkers: true,
    workerScripts: undefined
};
const config = Object.assign({
}, DEFAULT_CONFIGURATION);
function getConfiguration() {
    return config;
}
function configure(configuration) {
    if (configuration.chunkSize !== undefined) {
        config.chunkSize = configuration.chunkSize;
    }
    if (configuration.maxWorkers !== undefined) {
        config.maxWorkers = configuration.maxWorkers;
    }
    if (configuration.terminateWorkerTimeout !== undefined) {
        config.terminateWorkerTimeout = configuration.terminateWorkerTimeout;
    }
    if (configuration.useWebWorkers !== undefined) {
        config.useWebWorkers = configuration.useWebWorkers;
    }
    if (configuration.Deflate !== undefined) {
        config.Deflate = configuration.Deflate;
    }
    if (configuration.Inflate !== undefined) {
        config.Inflate = configuration.Inflate;
    }
    if (configuration.workerScripts !== undefined) {
        if (configuration.workerScripts.deflate) {
            if (!Array.isArray(configuration.workerScripts.deflate)) {
                throw new Error("workerScripts.deflate must be an array");
            }
            if (!config.workerScripts) {
                config.workerScripts = {
                };
            }
            config.workerScripts.deflate = configuration.workerScripts.deflate;
        }
        if (configuration.workerScripts.inflate) {
            if (!Array.isArray(configuration.workerScripts.inflate)) {
                throw new Error("workerScripts.inflate must be an array");
            }
            if (!config.workerScripts) {
                config.workerScripts = {
                };
            }
            config.workerScripts.inflate = configuration.workerScripts.inflate;
        }
    }
}
const table = {
    "application": {
        "andrew-inset": "ez",
        "annodex": "anx",
        "atom+xml": "atom",
        "atomcat+xml": "atomcat",
        "atomserv+xml": "atomsrv",
        "bbolin": "lin",
        "cap": [
            "cap",
            "pcap"
        ],
        "cu-seeme": "cu",
        "davmount+xml": "davmount",
        "dsptype": "tsp",
        "ecmascript": [
            "es",
            "ecma"
        ],
        "futuresplash": "spl",
        "hta": "hta",
        "java-archive": "jar",
        "java-serialized-object": "ser",
        "java-vm": "class",
        "javascript": "js",
        "m3g": "m3g",
        "mac-binhex40": "hqx",
        "mathematica": [
            "nb",
            "ma",
            "mb"
        ],
        "msaccess": "mdb",
        "msword": [
            "doc",
            "dot"
        ],
        "mxf": "mxf",
        "oda": "oda",
        "ogg": "ogx",
        "pdf": "pdf",
        "pgp-keys": "key",
        "pgp-signature": [
            "asc",
            "sig"
        ],
        "pics-rules": "prf",
        "postscript": [
            "ps",
            "ai",
            "eps",
            "epsi",
            "epsf",
            "eps2",
            "eps3"
        ],
        "rar": "rar",
        "rdf+xml": "rdf",
        "rss+xml": "rss",
        "rtf": "rtf",
        "smil": [
            "smi",
            "smil"
        ],
        "xhtml+xml": [
            "xhtml",
            "xht"
        ],
        "xml": [
            "xml",
            "xsl",
            "xsd"
        ],
        "xspf+xml": "xspf",
        "zip": "zip",
        "vnd.android.package-archive": "apk",
        "vnd.cinderella": "cdy",
        "vnd.google-earth.kml+xml": "kml",
        "vnd.google-earth.kmz": "kmz",
        "vnd.mozilla.xul+xml": "xul",
        "vnd.ms-excel": [
            "xls",
            "xlb",
            "xlt",
            "xlm",
            "xla",
            "xlc",
            "xlw"
        ],
        "vnd.ms-pki.seccat": "cat",
        "vnd.ms-pki.stl": "stl",
        "vnd.ms-powerpoint": [
            "ppt",
            "pps",
            "pot"
        ],
        "vnd.oasis.opendocument.chart": "odc",
        "vnd.oasis.opendocument.database": "odb",
        "vnd.oasis.opendocument.formula": "odf",
        "vnd.oasis.opendocument.graphics": "odg",
        "vnd.oasis.opendocument.graphics-template": "otg",
        "vnd.oasis.opendocument.image": "odi",
        "vnd.oasis.opendocument.presentation": "odp",
        "vnd.oasis.opendocument.presentation-template": "otp",
        "vnd.oasis.opendocument.spreadsheet": "ods",
        "vnd.oasis.opendocument.spreadsheet-template": "ots",
        "vnd.oasis.opendocument.text": "odt",
        "vnd.oasis.opendocument.text-master": "odm",
        "vnd.oasis.opendocument.text-template": "ott",
        "vnd.oasis.opendocument.text-web": "oth",
        "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
        "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
        "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
        "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
        "vnd.openxmlformats-officedocument.presentationml.template": "potx",
        "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
        "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
        "vnd.smaf": "mmf",
        "vnd.stardivision.calc": "sdc",
        "vnd.stardivision.chart": "sds",
        "vnd.stardivision.draw": "sda",
        "vnd.stardivision.impress": "sdd",
        "vnd.stardivision.math": [
            "sdf",
            "smf"
        ],
        "vnd.stardivision.writer": [
            "sdw",
            "vor"
        ],
        "vnd.stardivision.writer-global": "sgl",
        "vnd.sun.xml.calc": "sxc",
        "vnd.sun.xml.calc.template": "stc",
        "vnd.sun.xml.draw": "sxd",
        "vnd.sun.xml.draw.template": "std",
        "vnd.sun.xml.impress": "sxi",
        "vnd.sun.xml.impress.template": "sti",
        "vnd.sun.xml.math": "sxm",
        "vnd.sun.xml.writer": "sxw",
        "vnd.sun.xml.writer.global": "sxg",
        "vnd.sun.xml.writer.template": "stw",
        "vnd.symbian.install": [
            "sis",
            "sisx"
        ],
        "vnd.visio": [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ],
        "vnd.wap.wbxml": "wbxml",
        "vnd.wap.wmlc": "wmlc",
        "vnd.wap.wmlscriptc": "wmlsc",
        "vnd.wordperfect": "wpd",
        "vnd.wordperfect5.1": "wp5",
        "x-123": "wk",
        "x-7z-compressed": "7z",
        "x-abiword": "abw",
        "x-apple-diskimage": "dmg",
        "x-bcpio": "bcpio",
        "x-bittorrent": "torrent",
        "x-cbr": [
            "cbr",
            "cba",
            "cbt",
            "cb7"
        ],
        "x-cbz": "cbz",
        "x-cdf": [
            "cdf",
            "cda"
        ],
        "x-cdlink": "vcd",
        "x-chess-pgn": "pgn",
        "x-cpio": "cpio",
        "x-csh": "csh",
        "x-debian-package": [
            "deb",
            "udeb"
        ],
        "x-director": [
            "dcr",
            "dir",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ],
        "x-dms": "dms",
        "x-doom": "wad",
        "x-dvi": "dvi",
        "x-httpd-eruby": "rhtml",
        "x-font": "pcf.Z",
        "x-freemind": "mm",
        "x-gnumeric": "gnumeric",
        "x-go-sgf": "sgf",
        "x-graphing-calculator": "gcf",
        "x-gtar": [
            "gtar",
            "taz"
        ],
        "x-hdf": "hdf",
        "x-httpd-php": [
            "phtml",
            "pht",
            "php"
        ],
        "x-httpd-php-source": "phps",
        "x-httpd-php3": "php3",
        "x-httpd-php3-preprocessed": "php3p",
        "x-httpd-php4": "php4",
        "x-httpd-php5": "php5",
        "x-ica": "ica",
        "x-info": "info",
        "x-internet-signup": [
            "ins",
            "isp"
        ],
        "x-iphone": "iii",
        "x-iso9660-image": "iso",
        "x-java-jnlp-file": "jnlp",
        "x-jmol": "jmz",
        "x-killustrator": "kil",
        "x-koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "x-kpresenter": [
            "kpr",
            "kpt"
        ],
        "x-kword": [
            "kwd",
            "kwt"
        ],
        "x-latex": "latex",
        "x-lha": "lha",
        "x-lyx": "lyx",
        "x-lzh": "lzh",
        "x-lzx": "lzx",
        "x-maker": [
            "frm",
            "maker",
            "frame",
            "fm",
            "fb",
            "book",
            "fbdoc"
        ],
        "x-ms-wmd": "wmd",
        "x-ms-wmz": "wmz",
        "x-msdos-program": [
            "com",
            "exe",
            "bat",
            "dll"
        ],
        "x-msi": "msi",
        "x-netcdf": [
            "nc",
            "cdf"
        ],
        "x-ns-proxy-autoconfig": [
            "pac",
            "dat"
        ],
        "x-nwc": "nwc",
        "x-object": "o",
        "x-oz-application": "oza",
        "x-pkcs7-certreqresp": "p7r",
        "x-python-code": [
            "pyc",
            "pyo"
        ],
        "x-qgis": [
            "qgs",
            "shp",
            "shx"
        ],
        "x-quicktimeplayer": "qtl",
        "x-redhat-package-manager": "rpm",
        "x-ruby": "rb",
        "x-sh": "sh",
        "x-shar": "shar",
        "x-shockwave-flash": [
            "swf",
            "swfl"
        ],
        "x-silverlight": "scr",
        "x-stuffit": "sit",
        "x-sv4cpio": "sv4cpio",
        "x-sv4crc": "sv4crc",
        "x-tar": "tar",
        "x-tcl": "tcl",
        "x-tex-gf": "gf",
        "x-tex-pk": "pk",
        "x-texinfo": [
            "texinfo",
            "texi"
        ],
        "x-trash": [
            "~",
            "%",
            "bak",
            "old",
            "sik"
        ],
        "x-troff": [
            "t",
            "tr",
            "roff"
        ],
        "x-troff-man": "man",
        "x-troff-me": "me",
        "x-troff-ms": "ms",
        "x-ustar": "ustar",
        "x-wais-source": "src",
        "x-wingz": "wz",
        "x-x509-ca-cert": [
            "crt",
            "der",
            "cer"
        ],
        "x-xcf": "xcf",
        "x-xfig": "fig",
        "x-xpinstall": "xpi",
        "applixware": "aw",
        "atomsvc+xml": "atomsvc",
        "ccxml+xml": "ccxml",
        "cdmi-capability": "cdmia",
        "cdmi-container": "cdmic",
        "cdmi-domain": "cdmid",
        "cdmi-object": "cdmio",
        "cdmi-queue": "cdmiq",
        "docbook+xml": "dbk",
        "dssc+der": "dssc",
        "dssc+xml": "xdssc",
        "emma+xml": "emma",
        "epub+zip": "epub",
        "exi": "exi",
        "font-tdpfr": "pfr",
        "gml+xml": "gml",
        "gpx+xml": "gpx",
        "gxf": "gxf",
        "hyperstudio": "stk",
        "inkml+xml": [
            "ink",
            "inkml"
        ],
        "ipfix": "ipfix",
        "json": "json",
        "jsonml+json": "jsonml",
        "lost+xml": "lostxml",
        "mads+xml": "mads",
        "marc": "mrc",
        "marcxml+xml": "mrcx",
        "mathml+xml": "mathml",
        "mbox": "mbox",
        "mediaservercontrol+xml": "mscml",
        "metalink+xml": "metalink",
        "metalink4+xml": "meta4",
        "mets+xml": "mets",
        "mods+xml": "mods",
        "mp21": [
            "m21",
            "mp21"
        ],
        "mp4": "mp4s",
        "oebps-package+xml": "opf",
        "omdoc+xml": "omdoc",
        "onenote": [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ],
        "oxps": "oxps",
        "patch-ops-error+xml": "xer",
        "pgp-encrypted": "pgp",
        "pkcs10": "p10",
        "pkcs7-mime": [
            "p7m",
            "p7c"
        ],
        "pkcs7-signature": "p7s",
        "pkcs8": "p8",
        "pkix-attr-cert": "ac",
        "pkix-crl": "crl",
        "pkix-pkipath": "pkipath",
        "pkixcmp": "pki",
        "pls+xml": "pls",
        "prs.cww": "cww",
        "pskc+xml": "pskcxml",
        "reginfo+xml": "rif",
        "relax-ng-compact-syntax": "rnc",
        "resource-lists+xml": "rl",
        "resource-lists-diff+xml": "rld",
        "rls-services+xml": "rs",
        "rpki-ghostbusters": "gbr",
        "rpki-manifest": "mft",
        "rpki-roa": "roa",
        "rsd+xml": "rsd",
        "sbml+xml": "sbml",
        "scvp-cv-request": "scq",
        "scvp-cv-response": "scs",
        "scvp-vp-request": "spq",
        "scvp-vp-response": "spp",
        "sdp": "sdp",
        "set-payment-initiation": "setpay",
        "set-registration-initiation": "setreg",
        "shf+xml": "shf",
        "sparql-query": "rq",
        "sparql-results+xml": "srx",
        "srgs": "gram",
        "srgs+xml": "grxml",
        "sru+xml": "sru",
        "ssdl+xml": "ssdl",
        "ssml+xml": "ssml",
        "tei+xml": [
            "tei",
            "teicorpus"
        ],
        "thraud+xml": "tfi",
        "timestamped-data": "tsd",
        "vnd.3gpp.pic-bw-large": "plb",
        "vnd.3gpp.pic-bw-small": "psb",
        "vnd.3gpp.pic-bw-var": "pvb",
        "vnd.3gpp2.tcap": "tcap",
        "vnd.3m.post-it-notes": "pwn",
        "vnd.accpac.simply.aso": "aso",
        "vnd.accpac.simply.imp": "imp",
        "vnd.acucobol": "acu",
        "vnd.acucorp": [
            "atc",
            "acutc"
        ],
        "vnd.adobe.air-application-installer-package+zip": "air",
        "vnd.adobe.formscentral.fcdt": "fcdt",
        "vnd.adobe.fxp": [
            "fxp",
            "fxpl"
        ],
        "vnd.adobe.xdp+xml": "xdp",
        "vnd.adobe.xfdf": "xfdf",
        "vnd.ahead.space": "ahead",
        "vnd.airzip.filesecure.azf": "azf",
        "vnd.airzip.filesecure.azs": "azs",
        "vnd.amazon.ebook": "azw",
        "vnd.americandynamics.acc": "acc",
        "vnd.amiga.ami": "ami",
        "vnd.anser-web-certificate-issue-initiation": "cii",
        "vnd.anser-web-funds-transfer-initiation": "fti",
        "vnd.antix.game-component": "atx",
        "vnd.apple.installer+xml": "mpkg",
        "vnd.apple.mpegurl": "m3u8",
        "vnd.aristanetworks.swi": "swi",
        "vnd.astraea-software.iota": "iota",
        "vnd.audiograph": "aep",
        "vnd.blueice.multipass": "mpm",
        "vnd.bmi": "bmi",
        "vnd.businessobjects": "rep",
        "vnd.chemdraw+xml": "cdxml",
        "vnd.chipnuts.karaoke-mmd": "mmd",
        "vnd.claymore": "cla",
        "vnd.cloanto.rp9": "rp9",
        "vnd.clonk.c4group": [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ],
        "vnd.cluetrust.cartomobile-config": "c11amc",
        "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
        "vnd.commonspace": "csp",
        "vnd.contact.cmsg": "cdbcmsg",
        "vnd.cosmocaller": "cmc",
        "vnd.crick.clicker": "clkx",
        "vnd.crick.clicker.keyboard": "clkk",
        "vnd.crick.clicker.palette": "clkp",
        "vnd.crick.clicker.template": "clkt",
        "vnd.crick.clicker.wordbank": "clkw",
        "vnd.criticaltools.wbs+xml": "wbs",
        "vnd.ctc-posml": "pml",
        "vnd.cups-ppd": "ppd",
        "vnd.curl.car": "car",
        "vnd.curl.pcurl": "pcurl",
        "vnd.dart": "dart",
        "vnd.data-vision.rdz": "rdz",
        "vnd.dece.data": [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ],
        "vnd.dece.ttml+xml": [
            "uvt",
            "uvvt"
        ],
        "vnd.dece.unspecified": [
            "uvx",
            "uvvx"
        ],
        "vnd.dece.zip": [
            "uvz",
            "uvvz"
        ],
        "vnd.denovo.fcselayout-link": "fe_launch",
        "vnd.dna": "dna",
        "vnd.dolby.mlp": "mlp",
        "vnd.dpgraph": "dpg",
        "vnd.dreamfactory": "dfac",
        "vnd.ds-keypoint": "kpxx",
        "vnd.dvb.ait": "ait",
        "vnd.dvb.service": "svc",
        "vnd.dynageo": "geo",
        "vnd.ecowin.chart": "mag",
        "vnd.enliven": "nml",
        "vnd.epson.esf": "esf",
        "vnd.epson.msf": "msf",
        "vnd.epson.quickanime": "qam",
        "vnd.epson.salt": "slt",
        "vnd.epson.ssf": "ssf",
        "vnd.eszigno3+xml": [
            "es3",
            "et3"
        ],
        "vnd.ezpix-album": "ez2",
        "vnd.ezpix-package": "ez3",
        "vnd.fdf": "fdf",
        "vnd.fdsn.mseed": "mseed",
        "vnd.fdsn.seed": [
            "seed",
            "dataless"
        ],
        "vnd.flographit": "gph",
        "vnd.fluxtime.clip": "ftc",
        "vnd.framemaker": [
            "fm",
            "frame",
            "maker",
            "book"
        ],
        "vnd.frogans.fnc": "fnc",
        "vnd.frogans.ltf": "ltf",
        "vnd.fsc.weblaunch": "fsc",
        "vnd.fujitsu.oasys": "oas",
        "vnd.fujitsu.oasys2": "oa2",
        "vnd.fujitsu.oasys3": "oa3",
        "vnd.fujitsu.oasysgp": "fg5",
        "vnd.fujitsu.oasysprs": "bh2",
        "vnd.fujixerox.ddd": "ddd",
        "vnd.fujixerox.docuworks": "xdw",
        "vnd.fujixerox.docuworks.binder": "xbd",
        "vnd.fuzzysheet": "fzs",
        "vnd.genomatix.tuxedo": "txd",
        "vnd.geogebra.file": "ggb",
        "vnd.geogebra.tool": "ggt",
        "vnd.geometry-explorer": [
            "gex",
            "gre"
        ],
        "vnd.geonext": "gxt",
        "vnd.geoplan": "g2w",
        "vnd.geospace": "g3w",
        "vnd.gmx": "gmx",
        "vnd.grafeq": [
            "gqf",
            "gqs"
        ],
        "vnd.groove-account": "gac",
        "vnd.groove-help": "ghf",
        "vnd.groove-identity-message": "gim",
        "vnd.groove-injector": "grv",
        "vnd.groove-tool-message": "gtm",
        "vnd.groove-tool-template": "tpl",
        "vnd.groove-vcard": "vcg",
        "vnd.hal+xml": "hal",
        "vnd.handheld-entertainment+xml": "zmm",
        "vnd.hbci": "hbci",
        "vnd.hhe.lesson-player": "les",
        "vnd.hp-hpgl": "hpgl",
        "vnd.hp-hpid": "hpid",
        "vnd.hp-hps": "hps",
        "vnd.hp-jlyt": "jlt",
        "vnd.hp-pcl": "pcl",
        "vnd.hp-pclxl": "pclxl",
        "vnd.hydrostatix.sof-data": "sfd-hdstx",
        "vnd.ibm.minipay": "mpy",
        "vnd.ibm.modcap": [
            "afp",
            "listafp",
            "list3820"
        ],
        "vnd.ibm.rights-management": "irm",
        "vnd.ibm.secure-container": "sc",
        "vnd.iccprofile": [
            "icc",
            "icm"
        ],
        "vnd.igloader": "igl",
        "vnd.immervision-ivp": "ivp",
        "vnd.immervision-ivu": "ivu",
        "vnd.insors.igm": "igm",
        "vnd.intercon.formnet": [
            "xpw",
            "xpx"
        ],
        "vnd.intergeo": "i2g",
        "vnd.intu.qbo": "qbo",
        "vnd.intu.qfx": "qfx",
        "vnd.ipunplugged.rcprofile": "rcprofile",
        "vnd.irepository.package+xml": "irp",
        "vnd.is-xpr": "xpr",
        "vnd.isac.fcs": "fcs",
        "vnd.jam": "jam",
        "vnd.jcp.javame.midlet-rms": "rms",
        "vnd.jisp": "jisp",
        "vnd.joost.joda-archive": "joda",
        "vnd.kahootz": [
            "ktz",
            "ktr"
        ],
        "vnd.kde.karbon": "karbon",
        "vnd.kde.kchart": "chrt",
        "vnd.kde.kformula": "kfo",
        "vnd.kde.kivio": "flw",
        "vnd.kde.kontour": "kon",
        "vnd.kde.kpresenter": [
            "kpr",
            "kpt"
        ],
        "vnd.kde.kspread": "ksp",
        "vnd.kde.kword": [
            "kwd",
            "kwt"
        ],
        "vnd.kenameaapp": "htke",
        "vnd.kidspiration": "kia",
        "vnd.kinar": [
            "kne",
            "knp"
        ],
        "vnd.koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "vnd.kodak-descriptor": "sse",
        "vnd.las.las+xml": "lasxml",
        "vnd.llamagraphics.life-balance.desktop": "lbd",
        "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
        "vnd.lotus-1-2-3": "123",
        "vnd.lotus-approach": "apr",
        "vnd.lotus-freelance": "pre",
        "vnd.lotus-notes": "nsf",
        "vnd.lotus-organizer": "org",
        "vnd.lotus-screencam": "scm",
        "vnd.lotus-wordpro": "lwp",
        "vnd.macports.portpkg": "portpkg",
        "vnd.mcd": "mcd",
        "vnd.medcalcdata": "mc1",
        "vnd.mediastation.cdkey": "cdkey",
        "vnd.mfer": "mwf",
        "vnd.mfmp": "mfm",
        "vnd.micrografx.flo": "flo",
        "vnd.micrografx.igx": "igx",
        "vnd.mif": "mif",
        "vnd.mobius.daf": "daf",
        "vnd.mobius.dis": "dis",
        "vnd.mobius.mbk": "mbk",
        "vnd.mobius.mqy": "mqy",
        "vnd.mobius.msl": "msl",
        "vnd.mobius.plc": "plc",
        "vnd.mobius.txf": "txf",
        "vnd.mophun.application": "mpn",
        "vnd.mophun.certificate": "mpc",
        "vnd.ms-artgalry": "cil",
        "vnd.ms-cab-compressed": "cab",
        "vnd.ms-excel.addin.macroenabled.12": "xlam",
        "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
        "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
        "vnd.ms-excel.template.macroenabled.12": "xltm",
        "vnd.ms-fontobject": "eot",
        "vnd.ms-htmlhelp": "chm",
        "vnd.ms-ims": "ims",
        "vnd.ms-lrm": "lrm",
        "vnd.ms-officetheme": "thmx",
        "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
        "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
        "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
        "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
        "vnd.ms-powerpoint.template.macroenabled.12": "potm",
        "vnd.ms-project": [
            "mpp",
            "mpt"
        ],
        "vnd.ms-word.document.macroenabled.12": "docm",
        "vnd.ms-word.template.macroenabled.12": "dotm",
        "vnd.ms-works": [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ],
        "vnd.ms-wpl": "wpl",
        "vnd.ms-xpsdocument": "xps",
        "vnd.mseq": "mseq",
        "vnd.musician": "mus",
        "vnd.muvee.style": "msty",
        "vnd.mynfc": "taglet",
        "vnd.neurolanguage.nlu": "nlu",
        "vnd.nitf": [
            "ntf",
            "nitf"
        ],
        "vnd.noblenet-directory": "nnd",
        "vnd.noblenet-sealer": "nns",
        "vnd.noblenet-web": "nnw",
        "vnd.nokia.n-gage.data": "ngdat",
        "vnd.nokia.n-gage.symbian.install": "n-gage",
        "vnd.nokia.radio-preset": "rpst",
        "vnd.nokia.radio-presets": "rpss",
        "vnd.novadigm.edm": "edm",
        "vnd.novadigm.edx": "edx",
        "vnd.novadigm.ext": "ext",
        "vnd.oasis.opendocument.chart-template": "otc",
        "vnd.oasis.opendocument.formula-template": "odft",
        "vnd.oasis.opendocument.image-template": "oti",
        "vnd.olpc-sugar": "xo",
        "vnd.oma.dd2+xml": "dd2",
        "vnd.openofficeorg.extension": "oxt",
        "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
        "vnd.osgeo.mapguide.package": "mgp",
        "vnd.osgi.dp": "dp",
        "vnd.osgi.subsystem": "esa",
        "vnd.palm": [
            "pdb",
            "pqa",
            "oprc"
        ],
        "vnd.pawaafile": "paw",
        "vnd.pg.format": "str",
        "vnd.pg.osasli": "ei6",
        "vnd.picsel": "efif",
        "vnd.pmi.widget": "wg",
        "vnd.pocketlearn": "plf",
        "vnd.powerbuilder6": "pbd",
        "vnd.previewsystems.box": "box",
        "vnd.proteus.magazine": "mgz",
        "vnd.publishare-delta-tree": "qps",
        "vnd.pvi.ptid1": "ptid",
        "vnd.quark.quarkxpress": [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ],
        "vnd.realvnc.bed": "bed",
        "vnd.recordare.musicxml": "mxl",
        "vnd.recordare.musicxml+xml": "musicxml",
        "vnd.rig.cryptonote": "cryptonote",
        "vnd.rn-realmedia": "rm",
        "vnd.rn-realmedia-vbr": "rmvb",
        "vnd.route66.link66+xml": "link66",
        "vnd.sailingtracker.track": "st",
        "vnd.seemail": "see",
        "vnd.sema": "sema",
        "vnd.semd": "semd",
        "vnd.semf": "semf",
        "vnd.shana.informed.formdata": "ifm",
        "vnd.shana.informed.formtemplate": "itp",
        "vnd.shana.informed.interchange": "iif",
        "vnd.shana.informed.package": "ipk",
        "vnd.simtech-mindmapper": [
            "twd",
            "twds"
        ],
        "vnd.smart.teacher": "teacher",
        "vnd.solent.sdkm+xml": [
            "sdkm",
            "sdkd"
        ],
        "vnd.spotfire.dxp": "dxp",
        "vnd.spotfire.sfs": "sfs",
        "vnd.stepmania.package": "smzip",
        "vnd.stepmania.stepchart": "sm",
        "vnd.sus-calendar": [
            "sus",
            "susp"
        ],
        "vnd.svd": "svd",
        "vnd.syncml+xml": "xsm",
        "vnd.syncml.dm+wbxml": "bdm",
        "vnd.syncml.dm+xml": "xdm",
        "vnd.tao.intent-module-archive": "tao",
        "vnd.tcpdump.pcap": [
            "pcap",
            "cap",
            "dmp"
        ],
        "vnd.tmobile-livetv": "tmo",
        "vnd.trid.tpt": "tpt",
        "vnd.triscape.mxs": "mxs",
        "vnd.trueapp": "tra",
        "vnd.ufdl": [
            "ufd",
            "ufdl"
        ],
        "vnd.uiq.theme": "utz",
        "vnd.umajin": "umj",
        "vnd.unity": "unityweb",
        "vnd.uoml+xml": "uoml",
        "vnd.vcx": "vcx",
        "vnd.visionary": "vis",
        "vnd.vsf": "vsf",
        "vnd.webturbo": "wtb",
        "vnd.wolfram.player": "nbp",
        "vnd.wqd": "wqd",
        "vnd.wt.stf": "stf",
        "vnd.xara": "xar",
        "vnd.xfdl": "xfdl",
        "vnd.yamaha.hv-dic": "hvd",
        "vnd.yamaha.hv-script": "hvs",
        "vnd.yamaha.hv-voice": "hvp",
        "vnd.yamaha.openscoreformat": "osf",
        "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
        "vnd.yamaha.smaf-audio": "saf",
        "vnd.yamaha.smaf-phrase": "spf",
        "vnd.yellowriver-custom-menu": "cmp",
        "vnd.zul": [
            "zir",
            "zirz"
        ],
        "vnd.zzazz.deck+xml": "zaz",
        "voicexml+xml": "vxml",
        "widget": "wgt",
        "winhlp": "hlp",
        "wsdl+xml": "wsdl",
        "wspolicy+xml": "wspolicy",
        "x-ace-compressed": "ace",
        "x-authorware-bin": [
            "aab",
            "x32",
            "u32",
            "vox"
        ],
        "x-authorware-map": "aam",
        "x-authorware-seg": "aas",
        "x-blorb": [
            "blb",
            "blorb"
        ],
        "x-bzip": "bz",
        "x-bzip2": [
            "bz2",
            "boz"
        ],
        "x-cfs-compressed": "cfs",
        "x-chat": "chat",
        "x-conference": "nsc",
        "x-dgc-compressed": "dgc",
        "x-dtbncx+xml": "ncx",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-eva": "eva",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": [
            "ttf",
            "ttc"
        ],
        "x-font-type1": [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ],
        "x-font-woff": "woff",
        "x-freearc": "arc",
        "x-gca-compressed": "gca",
        "x-glulx": "ulx",
        "x-gramps-xml": "gramps",
        "x-install-instructions": "install",
        "x-lzh-compressed": [
            "lzh",
            "lha"
        ],
        "x-mie": "mie",
        "x-mobipocket-ebook": [
            "prc",
            "mobi"
        ],
        "x-ms-application": "application",
        "x-ms-shortcut": "lnk",
        "x-ms-xbap": "xbap",
        "x-msbinder": "obd",
        "x-mscardfile": "crd",
        "x-msclip": "clp",
        "x-msdownload": [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ],
        "x-msmediaview": [
            "mvb",
            "m13",
            "m14"
        ],
        "x-msmetafile": [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ],
        "x-msmoney": "mny",
        "x-mspublisher": "pub",
        "x-msschedule": "scd",
        "x-msterminal": "trm",
        "x-mswrite": "wri",
        "x-nzb": "nzb",
        "x-pkcs12": [
            "p12",
            "pfx"
        ],
        "x-pkcs7-certificates": [
            "p7b",
            "spc"
        ],
        "x-research-info-systems": "ris",
        "x-silverlight-app": "xap",
        "x-sql": "sql",
        "x-stuffitx": "sitx",
        "x-subrip": "srt",
        "x-t3vm-image": "t3",
        "x-tads": "gam",
        "x-tex": "tex",
        "x-tex-tfm": "tfm",
        "x-tgif": "obj",
        "x-xliff+xml": "xlf",
        "x-xz": "xz",
        "x-zmachine": [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ],
        "xaml+xml": "xaml",
        "xcap-diff+xml": "xdf",
        "xenc+xml": "xenc",
        "xml-dtd": "dtd",
        "xop+xml": "xop",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "xv+xml": [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ],
        "yang": "yang",
        "yin+xml": "yin",
        "envoy": "evy",
        "fractals": "fif",
        "internet-property-stream": "acx",
        "olescript": "axs",
        "vnd.ms-outlook": "msg",
        "vnd.ms-pkicertstore": "sst",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz",
        "x-perfmon": [
            "pma",
            "pmc",
            "pml",
            "pmr",
            "pmw"
        ],
        "x-pkcs7-mime": [
            "p7c",
            "p7m"
        ],
        "ynd.ms-pkipko": "pko"
    },
    "audio": {
        "amr": "amr",
        "amr-wb": "awb",
        "annodex": "axa",
        "basic": [
            "au",
            "snd"
        ],
        "flac": "flac",
        "midi": [
            "mid",
            "midi",
            "kar",
            "rmi"
        ],
        "mpeg": [
            "mpga",
            "mpega",
            "mp2",
            "mp3",
            "m4a",
            "mp2a",
            "m2a",
            "m3a"
        ],
        "mpegurl": "m3u",
        "ogg": [
            "oga",
            "ogg",
            "spx"
        ],
        "prs.sid": "sid",
        "x-aiff": [
            "aif",
            "aiff",
            "aifc"
        ],
        "x-gsm": "gsm",
        "x-ms-wma": "wma",
        "x-ms-wax": "wax",
        "x-pn-realaudio": "ram",
        "x-realaudio": "ra",
        "x-sd2": "sd2",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "s3m": "s3m",
        "silk": "sil",
        "vnd.dece.audio": [
            "uva",
            "uvva"
        ],
        "vnd.digital-winds": "eol",
        "vnd.dra": "dra",
        "vnd.dts": "dts",
        "vnd.dts.hd": "dtshd",
        "vnd.lucent.voice": "lvp",
        "vnd.ms-playready.media.pya": "pya",
        "vnd.nuera.ecelp4800": "ecelp4800",
        "vnd.nuera.ecelp7470": "ecelp7470",
        "vnd.nuera.ecelp9600": "ecelp9600",
        "vnd.rip": "rip",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": [
            "mid",
            "rmi"
        ]
    },
    "chemical": {
        "x-alchemy": "alc",
        "x-cache": [
            "cac",
            "cache"
        ],
        "x-cache-csf": "csf",
        "x-cactvs-binary": [
            "cbin",
            "cascii",
            "ctab"
        ],
        "x-cdx": "cdx",
        "x-chem3d": "c3d",
        "x-cif": "cif",
        "x-cmdf": "cmdf",
        "x-cml": "cml",
        "x-compass": "cpa",
        "x-crossfire": "bsd",
        "x-csml": [
            "csml",
            "csm"
        ],
        "x-ctx": "ctx",
        "x-cxf": [
            "cxf",
            "cef"
        ],
        "x-embl-dl-nucleotide": [
            "emb",
            "embl"
        ],
        "x-gamess-input": [
            "inp",
            "gam",
            "gamin"
        ],
        "x-gaussian-checkpoint": [
            "fch",
            "fchk"
        ],
        "x-gaussian-cube": "cub",
        "x-gaussian-input": [
            "gau",
            "gjc",
            "gjf"
        ],
        "x-gaussian-log": "gal",
        "x-gcg8-sequence": "gcg",
        "x-genbank": "gen",
        "x-hin": "hin",
        "x-isostar": [
            "istr",
            "ist"
        ],
        "x-jcamp-dx": [
            "jdx",
            "dx"
        ],
        "x-kinemage": "kin",
        "x-macmolecule": "mcm",
        "x-macromodel-input": [
            "mmd",
            "mmod"
        ],
        "x-mdl-molfile": "mol",
        "x-mdl-rdfile": "rd",
        "x-mdl-rxnfile": "rxn",
        "x-mdl-sdfile": [
            "sd",
            "sdf"
        ],
        "x-mdl-tgf": "tgf",
        "x-mmcif": "mcif",
        "x-mol2": "mol2",
        "x-molconn-Z": "b",
        "x-mopac-graph": "gpt",
        "x-mopac-input": [
            "mop",
            "mopcrt",
            "mpc",
            "zmt"
        ],
        "x-mopac-out": "moo",
        "x-ncbi-asn1": "asn",
        "x-ncbi-asn1-ascii": [
            "prt",
            "ent"
        ],
        "x-ncbi-asn1-binary": [
            "val",
            "aso"
        ],
        "x-pdb": [
            "pdb",
            "ent"
        ],
        "x-rosdal": "ros",
        "x-swissprot": "sw",
        "x-vamas-iso14976": "vms",
        "x-vmd": "vmd",
        "x-xtel": "xtel",
        "x-xyz": "xyz"
    },
    "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": [
            "jpeg",
            "jpg",
            "jpe"
        ],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": [
            "svg",
            "svgz"
        ],
        "tiff": [
            "tiff",
            "tif"
        ],
        "vnd.djvu": [
            "djvu",
            "djv"
        ],
        "vnd.wap.wbmp": "wbmp",
        "x-canon-cr2": "cr2",
        "x-canon-crw": "crw",
        "x-cmu-raster": "ras",
        "x-coreldraw": "cdr",
        "x-coreldrawpattern": "pat",
        "x-coreldrawtemplate": "cdt",
        "x-corelphotopaint": "cpt",
        "x-epson-erf": "erf",
        "x-icon": "ico",
        "x-jg": "art",
        "x-jng": "jng",
        "x-nikon-nef": "nef",
        "x-olympus-orf": "orf",
        "x-photoshop": "psd",
        "x-portable-anymap": "pnm",
        "x-portable-bitmap": "pbm",
        "x-portable-graymap": "pgm",
        "x-portable-pixmap": "ppm",
        "x-rgb": "rgb",
        "x-xbitmap": "xbm",
        "x-xpixmap": "xpm",
        "x-xwindowdump": "xwd",
        "bmp": "bmp",
        "cgm": "cgm",
        "g3fax": "g3",
        "ktx": "ktx",
        "prs.btif": "btif",
        "sgi": "sgi",
        "vnd.dece.graphic": [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ],
        "vnd.dwg": "dwg",
        "vnd.dxf": "dxf",
        "vnd.fastbidsheet": "fbs",
        "vnd.fpx": "fpx",
        "vnd.fst": "fst",
        "vnd.fujixerox.edmics-mmr": "mmr",
        "vnd.fujixerox.edmics-rlc": "rlc",
        "vnd.ms-modi": "mdi",
        "vnd.ms-photo": "wdp",
        "vnd.net-fpx": "npx",
        "vnd.xiff": "xif",
        "webp": "webp",
        "x-3ds": "3ds",
        "x-cmx": "cmx",
        "x-freehand": [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ],
        "x-pict": [
            "pic",
            "pct"
        ],
        "x-tga": "tga",
        "cis-cod": "cod",
        "pipeg": "jfif"
    },
    "message": {
        "rfc822": [
            "eml",
            "mime",
            "mht",
            "mhtml",
            "nws"
        ]
    },
    "model": {
        "iges": [
            "igs",
            "iges"
        ],
        "mesh": [
            "msh",
            "mesh",
            "silo"
        ],
        "vrml": [
            "wrl",
            "vrml"
        ],
        "x3d+vrml": [
            "x3dv",
            "x3dvz"
        ],
        "x3d+xml": [
            "x3d",
            "x3dz"
        ],
        "x3d+binary": [
            "x3db",
            "x3dbz"
        ],
        "vnd.collada+xml": "dae",
        "vnd.dwf": "dwf",
        "vnd.gdl": "gdl",
        "vnd.gtw": "gtw",
        "vnd.mts": "mts",
        "vnd.vtu": "vtu"
    },
    "text": {
        "cache-manifest": [
            "manifest",
            "appcache"
        ],
        "calendar": [
            "ics",
            "icz",
            "ifb"
        ],
        "css": "css",
        "csv": "csv",
        "h323": "323",
        "html": [
            "html",
            "htm",
            "shtml",
            "stm"
        ],
        "iuls": "uls",
        "mathml": "mml",
        "plain": [
            "txt",
            "text",
            "brf",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "bas"
        ],
        "richtext": "rtx",
        "scriptlet": [
            "sct",
            "wsc"
        ],
        "texmacs": [
            "tm",
            "ts"
        ],
        "tab-separated-values": "tsv",
        "vnd.sun.j2me.app-descriptor": "jad",
        "vnd.wap.wml": "wml",
        "vnd.wap.wmlscript": "wmls",
        "x-bibtex": "bib",
        "x-boo": "boo",
        "x-c++hdr": [
            "h++",
            "hpp",
            "hxx",
            "hh"
        ],
        "x-c++src": [
            "c++",
            "cpp",
            "cxx",
            "cc"
        ],
        "x-component": "htc",
        "x-dsrc": "d",
        "x-diff": [
            "diff",
            "patch"
        ],
        "x-haskell": "hs",
        "x-java": "java",
        "x-literate-haskell": "lhs",
        "x-moc": "moc",
        "x-pascal": [
            "p",
            "pas"
        ],
        "x-pcs-gcd": "gcd",
        "x-perl": [
            "pl",
            "pm"
        ],
        "x-python": "py",
        "x-scala": "scala",
        "x-setext": "etx",
        "x-tcl": [
            "tcl",
            "tk"
        ],
        "x-tex": [
            "tex",
            "ltx",
            "sty",
            "cls"
        ],
        "x-vcalendar": "vcs",
        "x-vcard": "vcf",
        "n3": "n3",
        "prs.lines.tag": "dsc",
        "sgml": [
            "sgml",
            "sgm"
        ],
        "troff": [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ],
        "turtle": "ttl",
        "uri-list": [
            "uri",
            "uris",
            "urls"
        ],
        "vcard": "vcard",
        "vnd.curl": "curl",
        "vnd.curl.dcurl": "dcurl",
        "vnd.curl.scurl": "scurl",
        "vnd.curl.mcurl": "mcurl",
        "vnd.dvb.subtitle": "sub",
        "vnd.fly": "fly",
        "vnd.fmi.flexstor": "flx",
        "vnd.graphviz": "gv",
        "vnd.in3d.3dml": "3dml",
        "vnd.in3d.spot": "spot",
        "x-asm": [
            "s",
            "asm"
        ],
        "x-c": [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ],
        "x-fortran": [
            "f",
            "for",
            "f77",
            "f90"
        ],
        "x-opml": "opml",
        "x-nfo": "nfo",
        "x-sfv": "sfv",
        "x-uuencode": "uu",
        "webviewhtml": "htt"
    },
    "video": {
        "avif": ".avif",
        "3gpp": "3gp",
        "annodex": "axv",
        "dl": "dl",
        "dv": [
            "dif",
            "dv"
        ],
        "fli": "fli",
        "gl": "gl",
        "mpeg": [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v",
            "mp2",
            "mpa",
            "mpv2"
        ],
        "mp4": [
            "mp4",
            "mp4v",
            "mpg4"
        ],
        "quicktime": [
            "qt",
            "mov"
        ],
        "ogg": "ogv",
        "vnd.mpegurl": [
            "mxu",
            "m4u"
        ],
        "x-flv": "flv",
        "x-la-asf": [
            "lsf",
            "lsx"
        ],
        "x-mng": "mng",
        "x-ms-asf": [
            "asf",
            "asx",
            "asr"
        ],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": [
            "mpv",
            "mkv",
            "mk3d",
            "mks"
        ],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": [
            "jpm",
            "jpgm"
        ],
        "mj2": [
            "mj2",
            "mjp2"
        ],
        "vnd.dece.hd": [
            "uvh",
            "uvvh"
        ],
        "vnd.dece.mobile": [
            "uvm",
            "uvvm"
        ],
        "vnd.dece.pd": [
            "uvp",
            "uvvp"
        ],
        "vnd.dece.sd": [
            "uvs",
            "uvvs"
        ],
        "vnd.dece.video": [
            "uvv",
            "uvvv"
        ],
        "vnd.dvb.file": "dvb",
        "vnd.fvt": "fvt",
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": [
            "uvu",
            "uvvu"
        ],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
    },
    "x-conference": {
        "x-cooltalk": "ice"
    },
    "x-world": {
        "x-vrml": [
            "vrm",
            "vrml",
            "wrl",
            "flr",
            "wrz",
            "xaf",
            "xof"
        ]
    }
};
const mimeTypes = (()=>{
    const mimeTypes = {
    };
    for(let type in table){
        if (table.hasOwnProperty(type)) {
            for(let subtype in table[type]){
                if (table[type].hasOwnProperty(subtype)) {
                    const value = table[type][subtype];
                    if (typeof value == "string") {
                        mimeTypes[value] = type + "/" + subtype;
                    } else {
                        for(let indexMimeType = 0; indexMimeType < value.length; indexMimeType++){
                            mimeTypes[value[indexMimeType]] = type + "/" + subtype;
                        }
                    }
                }
            }
        }
    }
    return mimeTypes;
})();
const table1 = [];
for(let i1 = 0; i1 < 256; i1++){
    let t = i1;
    for(let j = 0; j < 8; j++){
        if (t & 1) {
            t = t >>> 1 ^ 3988292384;
        } else {
            t = t >>> 1;
        }
    }
    table1[i1] = t;
}
class Crc32 {
    constructor(crc){
        this.crc = crc || -1;
    }
    append(data) {
        let crc = this.crc | 0;
        for(let offset = 0, length = data.length | 0; offset < length; offset++){
            crc = crc >>> 8 ^ table1[(crc ^ data[offset]) & 255];
        }
        this.crc = crc;
    }
    get() {
        return ~this.crc;
    }
}
const bitArray = {
    concat (a1, a2) {
        if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
        }
        const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
        if (shift === 32) {
            return a1.concat(a2);
        } else {
            return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
        }
    },
    bitLength (a) {
        const l = a.length;
        if (l === 0) {
            return 0;
        }
        const x = a[l - 1];
        return (l - 1) * 32 + bitArray.getPartial(x);
    },
    clamp (a, len) {
        if (a.length * 32 < len) {
            return a;
        }
        a = a.slice(0, Math.ceil(len / 32));
        const l = a.length;
        len = len & 31;
        if (l > 0 && len) {
            a[l - 1] = bitArray.partial(len, a[l - 1] & 2147483648 >> len - 1, 1);
        }
        return a;
    },
    partial (len, x, _end) {
        if (len === 32) {
            return x;
        }
        return (_end ? x | 0 : x << 32 - len) + len * 1099511627776;
    },
    getPartial (x) {
        return Math.round(x / 1099511627776) || 32;
    },
    _shiftRight (a, shift, carry, out) {
        if (out === undefined) {
            out = [];
        }
        for(; shift >= 32; shift -= 32){
            out.push(carry);
            carry = 0;
        }
        if (shift === 0) {
            return out.concat(a);
        }
        for(let i = 0; i < a.length; i++){
            out.push(carry | a[i] >>> shift);
            carry = a[i] << 32 - shift;
        }
        const last2 = a.length ? a[a.length - 1] : 0;
        const shift2 = bitArray.getPartial(last2);
        out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
        return out;
    }
};
const codec = {
    bytes: {
        fromBits (arr) {
            const bl = bitArray.bitLength(arr);
            const byteLength = bl / 8;
            const out = new Uint8Array(byteLength);
            let tmp;
            for(let i = 0; i < byteLength; i++){
                if ((i & 3) === 0) {
                    tmp = arr[i / 4];
                }
                out[i] = tmp >>> 24;
                tmp <<= 8;
            }
            return out;
        },
        toBits (bytes) {
            const out = [];
            let i;
            let tmp = 0;
            for(i = 0; i < bytes.length; i++){
                tmp = tmp << 8 | bytes[i];
                if ((i & 3) === 3) {
                    out.push(tmp);
                    tmp = 0;
                }
            }
            if (i & 3) {
                out.push(bitArray.partial(8 * (i & 3), tmp));
            }
            return out;
        }
    }
};
const hash = {
};
hash.sha1 = function(hash) {
    if (hash) {
        this._h = hash._h.slice(0);
        this._buffer = hash._buffer.slice(0);
        this._length = hash._length;
    } else {
        this.reset();
    }
};
hash.sha1.prototype = {
    blockSize: 512,
    reset: function() {
        const sha1 = this;
        sha1._h = this._init.slice(0);
        sha1._buffer = [];
        sha1._length = 0;
        return sha1;
    },
    update: function(data) {
        const sha1 = this;
        if (typeof data === "string") {
            data = codec.utf8String.toBits(data);
        }
        const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
        const ol = sha1._length;
        const nl = sha1._length = ol + bitArray.bitLength(data);
        if (nl > 9007199254740991) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        const c = new Uint32Array(b);
        let j = 0;
        for(let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize){
            sha1._block(c.subarray(16 * j, 16 * (j + 1)));
            j += 1;
        }
        b.splice(0, 16 * j);
        return sha1;
    },
    finalize: function() {
        const sha1 = this;
        let b = sha1._buffer;
        const h = sha1._h;
        b = bitArray.concat(b, [
            bitArray.partial(1, 1)
        ]);
        for(let i = b.length + 2; i & 15; i++){
            b.push(0);
        }
        b.push(Math.floor(sha1._length / 4294967296));
        b.push(sha1._length | 0);
        while(b.length){
            sha1._block(b.splice(0, 16));
        }
        sha1.reset();
        return h;
    },
    _init: [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ],
    _key: [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ],
    _f: function(t, b, c, d) {
        if (t <= 19) {
            return b & c | ~b & d;
        } else if (t <= 39) {
            return b ^ c ^ d;
        } else if (t <= 59) {
            return b & c | b & d | c & d;
        } else if (t <= 79) {
            return b ^ c ^ d;
        }
    },
    _S: function(n, x) {
        return x << n | x >>> 32 - n;
    },
    _block: function(words) {
        const sha1 = this;
        const h = sha1._h;
        const w = Array(80);
        for(let j = 0; j < 16; j++){
            w[j] = words[j];
        }
        let a = h[0];
        let b = h[1];
        let c = h[2];
        let d = h[3];
        let e = h[4];
        for(let t = 0; t <= 79; t++){
            if (t >= 16) {
                w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
            }
            const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] + sha1._key[Math.floor(t / 20)] | 0;
            e = d;
            d = c;
            c = sha1._S(30, b);
            b = a;
            a = tmp;
        }
        h[0] = h[0] + a | 0;
        h[1] = h[1] + b | 0;
        h[2] = h[2] + c | 0;
        h[3] = h[3] + d | 0;
        h[4] = h[4] + e | 0;
    }
};
const cipher = {
};
cipher.aes = class {
    constructor(key1){
        const aes = this;
        aes._tables = [
            [
                [],
                [],
                [],
                [],
                []
            ],
            [
                [],
                [],
                [],
                [],
                []
            ]
        ];
        if (!aes._tables[0][0][0]) {
            aes._precompute();
        }
        const sbox = aes._tables[0][4];
        const decTable = aes._tables[1];
        const keyLen = key1.length;
        let i2, encKey, decKey, rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error("invalid aes key size");
        }
        aes._key = [
            encKey = key1.slice(0),
            decKey = []
        ];
        for(i2 = keyLen; i2 < 4 * keyLen + 28; i2++){
            let tmp = encKey[i2 - 1];
            if (i2 % keyLen === 0 || keyLen === 8 && i2 % keyLen === 4) {
                tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                if (i2 % keyLen === 0) {
                    tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                    rcon = rcon << 1 ^ (rcon >> 7) * 283;
                }
            }
            encKey[i2] = encKey[i2 - keyLen] ^ tmp;
        }
        for(let j = 0; i2; j++, i2--){
            const tmp = encKey[j & 3 ? i2 : i2 - 4];
            if (i2 <= 4 || j < 4) {
                decKey[j] = tmp;
            } else {
                decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
            }
        }
    }
    encrypt(data) {
        return this._crypt(data, 0);
    }
    decrypt(data) {
        return this._crypt(data, 1);
    }
    _precompute() {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        const d = [];
        const th = [];
        let xInv, x2, x4, x8;
        for(let i = 0; i < 256; i++){
            th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
        }
        for(let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1){
            let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
            s = s >> 8 ^ s & 255 ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;
            x8 = d[x4 = d[x2 = d[x]]];
            let tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            let tEnc = d[s] * 257 ^ s * 16843008;
            for(let i = 0; i < 4; i++){
                encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
            }
        }
        for(let i3 = 0; i3 < 5; i3++){
            encTable[i3] = encTable[i3].slice(0);
            decTable[i3] = decTable[i3].slice(0);
        }
    }
    _crypt(input, dir) {
        if (input.length !== 4) {
            throw new Error("invalid aes block size");
        }
        const key = this._key[dir];
        const nInnerRounds = key.length / 4 - 2;
        const out = [
            0,
            0,
            0,
            0
        ];
        const table = this._tables[dir];
        const t0 = table[0];
        const t1 = table[1];
        const t2 = table[2];
        const t3 = table[3];
        const sbox = table[4];
        let a = input[0] ^ key[0];
        let b = input[dir ? 3 : 1] ^ key[1];
        let c = input[2] ^ key[2];
        let d = input[dir ? 1 : 3] ^ key[3];
        let kIndex = 4;
        let a2, b2, c2;
        for(let i = 0; i < nInnerRounds; i++){
            a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
        }
        for(let i3 = 0; i3 < 4; i3++){
            out[dir ? 3 & -i3 : i3] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
        }
        return out;
    }
};
const mode = {
};
mode.ctrGladman = class {
    constructor(prf, iv){
        this._prf = prf;
        this._initIv = iv;
        this._iv = iv;
    }
    reset() {
        this._iv = this._initIv;
    }
    update(data) {
        return this.calculate(this._prf, data, this._iv);
    }
    incWord(word) {
        if ((word >> 24 & 255) === 255) {
            let b1 = word >> 16 & 255;
            let b2 = word >> 8 & 255;
            let b3 = word & 255;
            if (b1 === 255) {
                b1 = 0;
                if (b2 === 255) {
                    b2 = 0;
                    if (b3 === 255) {
                        b3 = 0;
                    } else {
                        ++b3;
                    }
                } else {
                    ++b2;
                }
            } else {
                ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
        } else {
            word += 1 << 24;
        }
        return word;
    }
    incCounter(counter) {
        if ((counter[0] = this.incWord(counter[0])) === 0) {
            counter[1] = this.incWord(counter[1]);
        }
    }
    calculate(prf, data, iv) {
        let l;
        if (!(l = data.length)) {
            return [];
        }
        const bl = bitArray.bitLength(data);
        for(let i = 0; i < l; i += 4){
            this.incCounter(iv);
            const e = prf.encrypt(iv);
            data[i] ^= e[0];
            data[i + 1] ^= e[1];
            data[i + 2] ^= e[2];
            data[i + 3] ^= e[3];
        }
        return bitArray.clamp(data, bl);
    }
};
const misc = {
};
misc.hmacSha1 = class {
    constructor(key2){
        const hmac = this;
        const Hash1 = hmac._hash = hash.sha1;
        const exKey = [
            [],
            []
        ];
        const bs = Hash1.prototype.blockSize / 32;
        hmac._baseHash = [
            new Hash1(),
            new Hash1()
        ];
        if (key2.length > bs) {
            key2 = Hash1.hash(key2);
        }
        for(let i3 = 0; i3 < bs; i3++){
            exKey[0][i3] = key2[i3] ^ 909522486;
            exKey[1][i3] = key2[i3] ^ 1549556828;
        }
        hmac._baseHash[0].update(exKey[0]);
        hmac._baseHash[1].update(exKey[1]);
        hmac._resultHash = new Hash1(hmac._baseHash[0]);
    }
    reset() {
        const hmac = this;
        hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
        hmac._updated = false;
    }
    update(data) {
        const hmac = this;
        hmac._updated = true;
        hmac._resultHash.update(data);
    }
    digest() {
        const hmac = this;
        const w = hmac._resultHash.finalize();
        const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
        hmac.reset();
        return result;
    }
};
const ERR_INVALID_PASSWORD = "Invalid pasword";
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = {
    name: "PBKDF2"
};
const HASH_ALGORITHM = {
    name: "HMAC"
};
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({
    hash: HASH_ALGORITHM
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({
    iterations: 1000,
    hash: {
        name: HASH_FUNCTION
    }
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = [
    "deriveBits"
];
const SALT_LENGTH = [
    8,
    12,
    16
];
const KEY_LENGTH = [
    16,
    24,
    32
];
const COUNTER_DEFAULT_VALUE = [
    0,
    0,
    0,
    0
];
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;
class AESDecrypt {
    constructor(password, signed, strength){
        Object.assign(this, {
            password,
            signed,
            strength: strength - 1,
            pendingInput: new Uint8Array(0)
        });
    }
    async append(input) {
        const aesCrypto = this;
        if (aesCrypto.password) {
            const preamble = subarray(input, 0, SALT_LENGTH[aesCrypto.strength] + 2);
            await createDecryptionKeys(aesCrypto, preamble, aesCrypto.password);
            aesCrypto.password = null;
            aesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
            aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
            input = subarray(input, SALT_LENGTH[aesCrypto.strength] + 2);
        }
        const output = new Uint8Array(input.length - 10 - (input.length - 10) % 16);
        return append(aesCrypto, input, output, 0, 10, true);
    }
    flush() {
        const aesCrypto = this;
        const pendingInput = aesCrypto.pendingInput;
        const chunkToDecrypt = subarray(pendingInput, 0, pendingInput.length - 10);
        const originalSignature = subarray(pendingInput, pendingInput.length - 10);
        let decryptedChunkArray = new Uint8Array(0);
        if (chunkToDecrypt.length) {
            const encryptedChunk = codecBytes.toBits(chunkToDecrypt);
            aesCrypto.hmac.update(encryptedChunk);
            const decryptedChunk = aesCrypto.aesCtrGladman.update(encryptedChunk);
            decryptedChunkArray = codecBytes.fromBits(decryptedChunk);
        }
        let valid = true;
        if (aesCrypto.signed) {
            const signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, 10);
            for(let indexSignature = 0; indexSignature < 10; indexSignature++){
                if (signature[indexSignature] != originalSignature[indexSignature]) {
                    valid = false;
                }
            }
        }
        return {
            valid,
            data: decryptedChunkArray
        };
    }
}
class AESEncrypt {
    constructor(password1, strength1){
        Object.assign(this, {
            password: password1,
            strength: strength1 - 1,
            pendingInput: new Uint8Array(0)
        });
    }
    async append(input) {
        const aesCrypto = this;
        let preamble = new Uint8Array(0);
        if (aesCrypto.password) {
            preamble = await createEncryptionKeys(aesCrypto, aesCrypto.password);
            aesCrypto.password = null;
            aesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
            aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
        }
        const output = new Uint8Array(preamble.length + input.length - input.length % 16);
        output.set(preamble, 0);
        return append(aesCrypto, input, output, preamble.length, 0);
    }
    flush() {
        const aesCrypto = this;
        let encryptedChunkArray = new Uint8Array(0);
        if (aesCrypto.pendingInput.length) {
            const encryptedChunk = aesCrypto.aesCtrGladman.update(codecBytes.toBits(aesCrypto.pendingInput));
            aesCrypto.hmac.update(encryptedChunk);
            encryptedChunkArray = codecBytes.fromBits(encryptedChunk);
        }
        const signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, 10);
        return {
            data: concat(encryptedChunkArray, signature),
            signature
        };
    }
}
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
    const inputLength = input.length - paddingEnd;
    if (aesCrypto.pendingInput.length) {
        input = concat(aesCrypto.pendingInput, input);
        output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
    }
    let offset;
    for(offset = 0; offset <= inputLength - 16; offset += BLOCK_LENGTH){
        const inputChunk = codecBytes.toBits(subarray(input, offset, offset + 16));
        if (verifySignature) {
            aesCrypto.hmac.update(inputChunk);
        }
        const outputChunk = aesCrypto.aesCtrGladman.update(inputChunk);
        if (!verifySignature) {
            aesCrypto.hmac.update(outputChunk);
        }
        output.set(codecBytes.fromBits(outputChunk), offset + paddingStart);
    }
    aesCrypto.pendingInput = subarray(input, offset);
    return output;
}
async function createDecryptionKeys(decrypt, preambleArray, password) {
    await createKeys1(decrypt, password, subarray(preambleArray, 0, SALT_LENGTH[decrypt.strength]));
    const passwordVerification = subarray(preambleArray, SALT_LENGTH[decrypt.strength]);
    const passwordVerificationKey = decrypt.keys.passwordVerification;
    if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
        throw new Error(ERR_INVALID_PASSWORD);
    }
}
async function createEncryptionKeys(encrypt, password) {
    const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH[encrypt.strength]));
    await createKeys1(encrypt, password, salt);
    return concat(salt, encrypt.keys.passwordVerification);
}
async function createKeys1(target, password, salt) {
    const encodedPassword = new TextEncoder().encode(password);
    const basekey = await crypto.subtle.importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
    const derivedBits = await crypto.subtle.deriveBits(Object.assign({
        salt
    }, DERIVED_BITS_ALGORITHM), basekey, 8 * (KEY_LENGTH[target.strength] * 2 + 2));
    const compositeKey = new Uint8Array(derivedBits);
    target.keys = {
        key: codecBytes.toBits(subarray(compositeKey, 0, KEY_LENGTH[target.strength])),
        authentication: codecBytes.toBits(subarray(compositeKey, KEY_LENGTH[target.strength], KEY_LENGTH[target.strength] * 2)),
        passwordVerification: subarray(compositeKey, KEY_LENGTH[target.strength] * 2)
    };
}
function concat(leftArray, rightArray) {
    let array = leftArray;
    if (leftArray.length + rightArray.length) {
        array = new Uint8Array(leftArray.length + rightArray.length);
        array.set(leftArray, 0);
        array.set(rightArray, leftArray.length);
    }
    return array;
}
function expand(inputArray, length) {
    if (length && length > inputArray.length) {
        const array = inputArray;
        inputArray = new Uint8Array(length);
        inputArray.set(array, 0);
    }
    return inputArray;
}
function subarray(array, begin, end) {
    return array.subarray(begin, end);
}
const HEADER_LENGTH = 12;
class ZipCryptoDecrypt {
    constructor(password2, passwordVerification){
        const zipCrypto = this;
        Object.assign(zipCrypto, {
            password: password2,
            passwordVerification
        });
        createKeys2(zipCrypto, password2);
    }
    append(input) {
        const zipCrypto = this;
        if (zipCrypto.password) {
            const decryptedHeader = decrypt(zipCrypto, input.subarray(0, 12));
            zipCrypto.password = null;
            if (decryptedHeader[12 - 1] != zipCrypto.passwordVerification) {
                throw new Error(ERR_INVALID_PASSWORD);
            }
            input = input.subarray(HEADER_LENGTH);
        }
        return decrypt(zipCrypto, input);
    }
    flush() {
        return {
            valid: true,
            data: new Uint8Array(0)
        };
    }
}
class ZipCryptoEncrypt {
    constructor(password3, passwordVerification1){
        const zipCrypto1 = this;
        Object.assign(zipCrypto1, {
            password: password3,
            passwordVerification: passwordVerification1
        });
        createKeys2(zipCrypto1, password3);
    }
    append(input) {
        const zipCrypto = this;
        let output;
        let offset;
        if (zipCrypto.password) {
            zipCrypto.password = null;
            const header = crypto.getRandomValues(new Uint8Array(12));
            header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
            output = new Uint8Array(input.length + header.length);
            output.set(encrypt(zipCrypto, header), 0);
            offset = HEADER_LENGTH;
        } else {
            output = new Uint8Array(input.length);
            offset = 0;
        }
        output.set(encrypt(zipCrypto, input), offset);
        return output;
    }
    flush() {
        return {
            data: new Uint8Array(0)
        };
    }
}
function decrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, output[index]);
    }
    return output;
}
function encrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, input[index]);
    }
    return output;
}
function createKeys2(target, password) {
    target.keys = [
        305419896,
        591751049,
        878082192
    ];
    target.crcKey0 = new Crc32(target.keys[0]);
    target.crcKey2 = new Crc32(target.keys[2]);
    for(let index = 0; index < password.length; index++){
        updateKeys(target, password.charCodeAt(index));
    }
}
function updateKeys(target, __byte) {
    target.crcKey0.append([
        __byte
    ]);
    target.keys[0] = ~target.crcKey0.get();
    target.keys[1] = getInt32(target.keys[1] + getInt8(target.keys[0]));
    target.keys[1] = getInt32(Math.imul(target.keys[1], 134775813) + 1);
    target.crcKey2.append([
        target.keys[1] >>> 24
    ]);
    target.keys[2] = ~target.crcKey2.get();
}
function getByte(target) {
    const temp = target.keys[2] | 2;
    return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
    return number & 255;
}
function getInt32(number) {
    return number & 4294967295;
}
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
const ERR_INVALID_SIGNATURE = "Invalid signature";
class Inflate1 {
    constructor(codecConstructor, { signature , password: password4 , signed: signed1 , compressed , zipCrypto: zipCrypto2 , passwordVerification: passwordVerification2 , encryptionStrength  }, { chunkSize  }){
        const encrypted = Boolean(password4);
        Object.assign(this, {
            signature,
            encrypted,
            signed: signed1,
            compressed,
            inflate: compressed && new codecConstructor({
                chunkSize
            }),
            crc32: signed1 && new Crc32(),
            zipCrypto: zipCrypto2,
            decrypt: encrypted && zipCrypto2 ? new ZipCryptoDecrypt(password4, passwordVerification2) : new AESDecrypt(password4, signed1, encryptionStrength)
        });
    }
    async append(data) {
        const codec = this;
        if (codec.encrypted && data.length) {
            data = await codec.decrypt.append(data);
        }
        if (codec.compressed && data.length) {
            data = await codec.inflate.append(data);
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed && data.length) {
            codec.crc32.append(data);
        }
        return data;
    }
    async flush() {
        const codec = this;
        let signature;
        let data = new Uint8Array(0);
        if (codec.encrypted) {
            const result = codec.decrypt.flush();
            if (!result.valid) {
                throw new Error(ERR_INVALID_SIGNATURE);
            }
            data = result.data;
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed) {
            const dataViewSignature = new DataView(new Uint8Array(4).buffer);
            signature = codec.crc32.get();
            dataViewSignature.setUint32(0, signature);
            if (codec.signature != dataViewSignature.getUint32(0, false)) {
                throw new Error(ERR_INVALID_SIGNATURE);
            }
        }
        if (codec.compressed) {
            data = await codec.inflate.append(data) || new Uint8Array(0);
            await codec.inflate.flush();
        }
        return {
            data,
            signature
        };
    }
}
class Deflate1 {
    constructor(codecConstructor1, { encrypted: encrypted1 , signed: signed2 , compressed: compressed1 , level , zipCrypto: zipCrypto3 , password: password5 , passwordVerification: passwordVerification3 , encryptionStrength: encryptionStrength1  }, { chunkSize: chunkSize1  }){
        Object.assign(this, {
            encrypted: encrypted1,
            signed: signed2,
            compressed: compressed1,
            deflate: compressed1 && new codecConstructor1({
                level: level || 5,
                chunkSize: chunkSize1
            }),
            crc32: signed2 && new Crc32(),
            zipCrypto: zipCrypto3,
            encrypt: encrypted1 && zipCrypto3 ? new ZipCryptoEncrypt(password5, passwordVerification3) : new AESEncrypt(password5, encryptionStrength1)
        });
    }
    async append(inputData) {
        const codec = this;
        let data = inputData;
        if (codec.compressed && inputData.length) {
            data = await codec.deflate.append(inputData);
        }
        if (codec.encrypted && data.length) {
            data = await codec.encrypt.append(data);
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed && inputData.length) {
            codec.crc32.append(inputData);
        }
        return data;
    }
    async flush() {
        const codec = this;
        let signature;
        let data = new Uint8Array(0);
        if (codec.compressed) {
            data = await codec.deflate.flush() || new Uint8Array(0);
        }
        if (codec.encrypted) {
            data = await codec.encrypt.append(data);
            const result = codec.encrypt.flush();
            signature = result.signature;
            const newData = new Uint8Array(data.length + result.data.length);
            newData.set(data, 0);
            newData.set(result.data, data.length);
            data = newData;
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed) {
            signature = codec.crc32.get();
        }
        return {
            data,
            signature
        };
    }
}
function createCodec(codecConstructor, options, config) {
    if (options.codecType.startsWith(CODEC_DEFLATE)) {
        return new Deflate1(codecConstructor, options, config);
    } else if (options.codecType.startsWith(CODEC_INFLATE)) {
        return new Inflate1(codecConstructor, options, config);
    }
}
const importMeta1 = {
    url: "https://deno.land/x/zipjs@v2.3.17/lib/core/codecs/codec-pool-worker.js",
    main: false
};
const MESSAGE_INIT = "init";
const MESSAGE_APPEND = "append";
const MESSAGE_FLUSH = "flush";
const MESSAGE_EVENT_TYPE = "message";
let classicWorkersSupported = true;
function createWorkerInterface(workerData, config) {
    const interfaceCodec = createCodec(workerData.codecConstructor, workerData.options, config);
    return {
        async append (data) {
            try {
                return await interfaceCodec.append(data);
            } catch (error) {
                workerData.onTaskFinished();
                throw error;
            }
        },
        async flush () {
            try {
                return await interfaceCodec.flush();
            } finally{
                workerData.onTaskFinished();
            }
        }
    };
}
function createWebWorkerInterface(workerData, config) {
    let messageTask;
    const moduleType = {
        type: "module"
    };
    if (!workerData.interface) {
        if (!classicWorkersSupported) {
            workerData.worker = getWorker(moduleType);
        } else {
            try {
                workerData.worker = getWorker();
            } catch (error) {
                classicWorkersSupported = false;
                workerData.worker = getWorker(moduleType);
            }
        }
        workerData.worker.addEventListener(MESSAGE_EVENT_TYPE, onMessage, false);
        workerData.interface = {
            append (data) {
                return initAndSendMessage({
                    type: MESSAGE_APPEND,
                    data
                });
            },
            flush () {
                return initAndSendMessage({
                    type: MESSAGE_FLUSH
                });
            }
        };
    }
    return workerData.interface;
    function getWorker(options = {
    }) {
        return new Worker(new URL(workerData.scripts[0], importMeta1.url), options);
    }
    async function initAndSendMessage(message) {
        if (!messageTask) {
            const options = workerData.options;
            const scripts = workerData.scripts.slice(1);
            await sendMessage({
                scripts,
                type: MESSAGE_INIT,
                options,
                config: {
                    chunkSize: config.chunkSize
                }
            });
        }
        return sendMessage(message);
    }
    function sendMessage(message) {
        const worker = workerData.worker;
        const result = new Promise((resolve, reject)=>messageTask = {
                resolve,
                reject
            }
        );
        try {
            if (message.data) {
                try {
                    message.data = message.data.buffer;
                    worker.postMessage(message, [
                        message.data
                    ]);
                } catch (error) {
                    worker.postMessage(message);
                }
            } else {
                worker.postMessage(message);
            }
        } catch (error) {
            messageTask.reject(error);
            messageTask = null;
            workerData.onTaskFinished();
        }
        return result;
    }
    function onMessage(event) {
        const message = event.data;
        if (messageTask) {
            const reponseError = message.error;
            const type = message.type;
            if (reponseError) {
                const error = new Error(reponseError.message);
                error.stack = reponseError.stack;
                messageTask.reject(error);
                messageTask = null;
                workerData.onTaskFinished();
            } else if (type == MESSAGE_INIT || type == MESSAGE_FLUSH || type == MESSAGE_APPEND) {
                const data = message.data;
                if (type == MESSAGE_FLUSH) {
                    messageTask.resolve({
                        data: new Uint8Array(data),
                        signature: message.signature
                    });
                    messageTask = null;
                    workerData.onTaskFinished();
                } else {
                    messageTask.resolve(data && new Uint8Array(data));
                }
            }
        }
    }
}
const __default6 = (workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts)=>{
    Object.assign(workerData, {
        busy: true,
        codecConstructor,
        options: Object.assign({
        }, options),
        scripts,
        terminate () {
            if (workerData.worker && !workerData.busy) {
                workerData.worker.terminate();
                workerData.interface = null;
            }
        },
        onTaskFinished () {
            workerData.busy = false;
            onTaskFinished(workerData);
        }
    });
    return webWorker ? createWebWorkerInterface(workerData, config) : createWorkerInterface(workerData, config);
};
let pool = [];
let pendingRequests = [];
function createCodec1(codecConstructor, options, config) {
    const streamCopy = !options.compressed && !options.signed && !options.encrypted;
    const webWorker = !streamCopy && (options.useWebWorkers || options.useWebWorkers === undefined && config.useWebWorkers);
    const scripts = webWorker && config.workerScripts ? config.workerScripts[options.codecType] : [];
    if (pool.length < config.maxWorkers) {
        const workerData = {
        };
        pool.push(workerData);
        return __default6(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts);
    } else {
        const workerData = pool.find((workerData)=>!workerData.busy
        );
        if (workerData) {
            clearTerminateTimeout(workerData);
            return __default6(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts);
        } else {
            return new Promise((resolve)=>pendingRequests.push({
                    resolve,
                    codecConstructor,
                    options,
                    webWorker,
                    scripts
                })
            );
        }
    }
    function onTaskFinished(workerData) {
        if (pendingRequests.length) {
            const [{ resolve , codecConstructor , options , webWorker , scripts  }] = pendingRequests.splice(0, 1);
            resolve(__default6(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts));
        } else if (workerData.worker) {
            clearTerminateTimeout(workerData);
            if (Number.isFinite(config.terminateWorkerTimeout) && config.terminateWorkerTimeout >= 0) {
                workerData.terminateTimeout = setTimeout(()=>{
                    pool = pool.filter((data)=>data != workerData
                    );
                    workerData.terminate();
                }, config.terminateWorkerTimeout);
            }
        } else {
            pool = pool.filter((data)=>data != workerData
            );
        }
    }
}
function clearTerminateTimeout(workerData) {
    if (workerData.terminateTimeout) {
        clearTimeout(workerData.terminateTimeout);
        workerData.terminateTimeout = null;
    }
}
const __default7 = ()=>{
    if ("function" == typeof URL.createObjectURL) {
        const e = '\n\t\t\t\n\nconst t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n;}class e{constructor(t){this.crc=t||-1;}append(e){let n=0|this.crc;for(let i=0,a=0|e.length;i<a;i++)n=n>>>8^t[255&(n^e[i])];this.crc=n;}get(){return ~this.crc}}const n={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const i=t[t.length-1],a=n.getPartial(i);return 32===a?t.concat(e):n._shiftRight(e,a,0|i,t.slice(0,t.length-1))},bitLength(t){const e=t.length;if(0===e)return 0;const i=t[e-1];return 32*(e-1)+n.getPartial(i)},clamp(t,e){if(32*t.length<e)return t;const i=(t=t.slice(0,Math.ceil(e/32))).length;return e&=31,i>0&&e&&(t[i-1]=n.partial(e,t[i-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>Math.round(t/1099511627776)||32,_shiftRight(t,e,i,a){for(void 0===a&&(a=[]);e>=32;e-=32)a.push(i),i=0;if(0===e)return a.concat(t);for(let n=0;n<t.length;n++)a.push(i|t[n]>>>e),i=t[n]<<32-e;const r=t.length?t[t.length-1]:0,s=n.getPartial(r);return a.push(n.partial(e+s&31,e+s>32?i:a.pop(),1)),a}},i={bytes:{fromBits(t){const e=n.bitLength(t)/8,i=new Uint8Array(e);let a;for(let n=0;n<e;n++)0==(3&n)&&(a=t[n/4]),i[n]=a>>>24,a<<=8;return i},toBits(t){const e=[];let i,a=0;for(i=0;i<t.length;i++)a=a<<8|t[i],3==(3&i)&&(e.push(a),a=0);return 3&i&&e.push(n.partial(8*(3&i),a)),e}}},a={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset();}};a.sha1.prototype={blockSize:512,reset:function(){const t=this;return t._h=this._init.slice(0),t._buffer=[],t._length=0,t},update:function(t){const e=this;"string"==typeof t&&(t=i.utf8String.toBits(t));const a=e._buffer=n.concat(e._buffer,t),r=e._length,s=e._length=r+n.bitLength(t);if(s>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const o=new Uint32Array(a);let l=0;for(let t=e.blockSize+r-(e.blockSize+r&e.blockSize-1);t<=s;t+=e.blockSize)e._block(o.subarray(16*l,16*(l+1))),l+=1;return a.splice(0,16*l),e},finalize:function(){const t=this;let e=t._buffer;const i=t._h;e=n.concat(e,[n.partial(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(Math.floor(t._length/4294967296)),e.push(0|t._length);e.length;)t._block(e.splice(0,16));return t.reset(),i},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:function(t,e,n,i){return t<=19?e&n|~e&i:t<=39?e^n^i:t<=59?e&n|e&i|n&i:t<=79?e^n^i:void 0},_S:function(t,e){return e<<t|e>>>32-t},_block:function(t){const e=this,n=e._h,i=Array(80);for(let e=0;e<16;e++)i[e]=t[e];let a=n[0],r=n[1],s=n[2],o=n[3],l=n[4];for(let t=0;t<=79;t++){t>=16&&(i[t]=e._S(1,i[t-3]^i[t-8]^i[t-14]^i[t-16]));const n=e._S(5,a)+e._f(t,r,s,o)+l+i[t]+e._key[Math.floor(t/20)]|0;l=o,o=s,s=e._S(30,r),r=a,a=n;}n[0]=n[0]+a|0,n[1]=n[1]+r|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0;}};const r={aes:class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const n=e._tables[0][4],i=e._tables[1],a=t.length;let r,s,o,l=1;if(4!==a&&6!==a&&8!==a)throw new Error("invalid aes key size");for(e._key=[s=t.slice(0),o=[]],r=a;r<4*a+28;r++){let t=s[r-1];(r%a==0||8===a&&r%a==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],r%a==0&&(t=t<<8^t>>>24^l<<24,l=l<<1^283*(l>>7))),s[r]=s[r-a]^t;}for(let t=0;r;t++,r--){const e=s[3&t?r:r-4];o[t]=r<=4||t<4?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]];}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const t=this._tables[0],e=this._tables[1],n=t[4],i=e[4],a=[],r=[];let s,o,l,_;for(let t=0;t<256;t++)r[(a[t]=t<<1^283*(t>>7))^t]=t;for(let d=s=0;!n[d];d^=o||1,s=r[s]||1){let r=s^s<<1^s<<2^s<<3^s<<4;r=r>>8^255&r^99,n[d]=r,i[r]=d,_=a[l=a[o=a[d]]];let c=16843009*_^65537*l^257*o^16843008*d,f=257*a[r]^16843008*r;for(let n=0;n<4;n++)t[n][d]=f=f<<24^f>>>8,e[n][r]=c=c<<24^c>>>8;}for(let n=0;n<5;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0);}_crypt(t,e){if(4!==t.length)throw new Error("invalid aes block size");const n=this._key[e],i=n.length/4-2,a=[0,0,0,0],r=this._tables[e],s=r[0],o=r[1],l=r[2],_=r[3],d=r[4];let c,f,u,h=t[0]^n[0],b=t[e?3:1]^n[1],w=t[2]^n[2],p=t[e?1:3]^n[3],x=4;for(let t=0;t<i;t++)c=s[h>>>24]^o[b>>16&255]^l[w>>8&255]^_[255&p]^n[x],f=s[b>>>24]^o[w>>16&255]^l[p>>8&255]^_[255&h]^n[x+1],u=s[w>>>24]^o[p>>16&255]^l[h>>8&255]^_[255&b]^n[x+2],p=s[p>>>24]^o[h>>16&255]^l[b>>8&255]^_[255&w]^n[x+3],x+=4,h=c,b=f,w=u;for(let t=0;t<4;t++)a[e?3&-t:t]=d[h>>>24]<<24^d[b>>16&255]<<16^d[w>>8&255]<<8^d[255&p]^n[x++],c=h,h=b,b=w,w=p,p=c;return a}}},s={ctrGladman:class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e;}reset(){this._iv=this._initIv;}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,i=255&t;255===e?(e=0,255===n?(n=0,255===i?i=0:++i):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=i;}else t+=1<<24;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]));}calculate(t,e,i){let a;if(!(a=e.length))return [];const r=n.bitLength(e);for(let n=0;n<a;n+=4){this.incCounter(i);const a=t.encrypt(i);e[n]^=a[0],e[n+1]^=a[1],e[n+2]^=a[2],e[n+3]^=a[3];}return n.clamp(e,r)}}},o={hmacSha1:class{constructor(t){const e=this,n=e._hash=a.sha1,i=[[],[]],r=n.prototype.blockSize/32;e._baseHash=[new n,new n],t.length>r&&(t=n.hash(t));for(let e=0;e<r;e++)i[0][e]=909522486^t[e],i[1][e]=1549556828^t[e];e._baseHash[0].update(i[0]),e._baseHash[1].update(i[1]),e._resultHash=new n(e._baseHash[0]);}reset(){const t=this;t._resultHash=new t._hash(t._baseHash[0]),t._updated=!1;}update(t){this._updated=!0,this._resultHash.update(t);}digest(){const t=this,e=t._resultHash.finalize(),n=new t._hash(t._baseHash[1]).update(e).finalize();return t.reset(),n}}},l={name:"PBKDF2"},_=Object.assign({hash:{name:"HMAC"}},l),d=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},l),c=["deriveBits"],f=[8,12,16],u=[16,24,32],h=[0,0,0,0],b=i.bytes,w=r.aes,p=s.ctrGladman,x=o.hmacSha1;class g{constructor(t,e,n){Object.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;if(e.password){const n=A(t,0,f[e.strength]+2);await async function(t,e,n){await k(t,n,A(e,0,f[t.strength]));const i=A(e,f[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error("Invalid pasword")}(e,n,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication),t=A(t,f[e.strength]+2);}return m(e,t,new Uint8Array(t.length-10-(t.length-10)%16),0,10,!0)}flush(){const t=this,e=t.pendingInput,n=A(e,0,e.length-10),i=A(e,e.length-10);let a=new Uint8Array(0);if(n.length){const e=b.toBits(n);t.hmac.update(e);const i=t.aesCtrGladman.update(e);a=b.fromBits(i);}let r=!0;if(t.signed){const e=A(b.fromBits(t.hmac.digest()),0,10);for(let t=0;t<10;t++)e[t]!=i[t]&&(r=!1);}return {valid:r,data:a}}}class y{constructor(t,e){Object.assign(this,{password:t,strength:e-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;let n=new Uint8Array(0);e.password&&(n=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(f[t.strength]));return await k(t,e,n),v(n,t.keys.passwordVerification)}(e,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication));const i=new Uint8Array(n.length+t.length-t.length%16);return i.set(n,0),m(e,t,i,n.length,0)}flush(){const t=this;let e=new Uint8Array(0);if(t.pendingInput.length){const n=t.aesCtrGladman.update(b.toBits(t.pendingInput));t.hmac.update(n),e=b.fromBits(n);}const n=A(b.fromBits(t.hmac.digest()),0,10);return {data:v(e,n),signature:n}}}function m(t,e,n,i,a,r){const s=e.length-a;let o;for(t.pendingInput.length&&(e=v(t.pendingInput,e),n=function(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0);}return t}(n,s-s%16)),o=0;o<=s-16;o+=16){const a=b.toBits(A(e,o,o+16));r&&t.hmac.update(a);const s=t.aesCtrGladman.update(a);r||t.hmac.update(s),n.set(b.fromBits(s),o+i);}return t.pendingInput=A(e,o),n}async function k(t,e,n){const i=(new TextEncoder).encode(e),a=await crypto.subtle.importKey("raw",i,_,!1,c),r=await crypto.subtle.deriveBits(Object.assign({salt:n},d),a,8*(2*u[t.strength]+2)),s=new Uint8Array(r);t.keys={key:b.toBits(A(s,0,u[t.strength])),authentication:b.toBits(A(s,u[t.strength],2*u[t.strength])),passwordVerification:A(s,2*u[t.strength])};}function v(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function A(t,e,n){return t.subarray(e,n)}class U{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;if(e.password){const n=z(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new Error("Invalid pasword");t=t.subarray(12);}return z(e,t)}flush(){return {valid:!0,data:new Uint8Array(0)}}}class S{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;let n,i;if(e.password){e.password=null;const a=crypto.getRandomValues(new Uint8Array(12));a[11]=e.passwordVerification,n=new Uint8Array(t.length+a.length),n.set(I(e,a),0),i=12;}else n=new Uint8Array(t.length),i=0;return n.set(I(e,t),i),n}flush(){return {data:new Uint8Array(0)}}}function z(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,n[i]);return n}function I(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,e[i]);return n}function E(t,n){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<n.length;e++)C(t,n.charCodeAt(e));}function C(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=H(t.keys[1]+B(t.keys[0])),t.keys[1]=H(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get();}function M(t){const e=2|t.keys[2];return B(Math.imul(e,1^e)>>>8)}function B(t){return 255&t}function H(t){return 4294967295&t}class V{constructor(t,{signature:n,password:i,signed:a,compressed:r,zipCrypto:s,passwordVerification:o,encryptionStrength:l},{chunkSize:_}){const d=Boolean(i);Object.assign(this,{signature:n,encrypted:d,signed:a,compressed:r,inflate:r&&new t({chunkSize:_}),crc32:a&&new e,zipCrypto:s,decrypt:d&&s?new U(i,o):new g(i,a,l)});}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new Error("Invalid signature");n=e.data;}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new DataView(new Uint8Array(4).buffer);if(e=t.crc32.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new Error("Invalid signature")}return t.compressed&&(n=await t.inflate.append(n)||new Uint8Array(0),await t.inflate.flush()),{data:n,signature:e}}}class D{constructor(t,{encrypted:n,signed:i,compressed:a,level:r,zipCrypto:s,password:o,passwordVerification:l,encryptionStrength:_},{chunkSize:d}){Object.assign(this,{encrypted:n,signed:i,compressed:a,deflate:a&&new t({level:r||5,chunkSize:d}),crc32:i&&new e,zipCrypto:s,encrypt:n&&s?new S(o,l):new y(o,_)});}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.compressed&&(n=await t.deflate.flush()||new Uint8Array(0)),t.encrypted){n=await t.encrypt.append(n);const i=t.encrypt.flush();e=i.signature;const a=new Uint8Array(n.length+i.data.length);a.set(n,0),a.set(i.data,n.length),n=a;}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const j={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate),O=function(t,e,n){return e.codecType.startsWith("deflate")?new D(t,e,n):e.codecType.startsWith("inflate")?new V(t,e,n):void 0}(n,e,t.config);},append:async t=>({data:await O.append(t.data)}),flush:()=>O.flush()};let O;addEventListener("message",(async t=>{const e=t.data,n=e.type,i=j[n];if(i)try{e.data&&(e.data=new Uint8Array(e.data));const t=await i(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data]);}catch(e){postMessage(t);}else postMessage(t);}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}});}}));function P(t){return K(t.map((([t,e])=>new Array(t).fill(e,0,t))))}function K(t){return t.reduce(((t,e)=>t.concat(Array.isArray(e)?K(e):e)),[])}const G=[0,1,2,3].concat(...P([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function W(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1;}while(--e>0);return n>>>1}t.build_tree=function(n){const i=t.dyn_tree,a=t.stat_desc.static_tree,r=t.stat_desc.elems;let s,o,l,_=-1;for(n.heap_len=0,n.heap_max=573,s=0;s<r;s++)0!==i[2*s]?(n.heap[++n.heap_len]=_=s,n.depth[s]=0):i[2*s+1]=0;for(;n.heap_len<2;)l=n.heap[++n.heap_len]=_<2?++_:0,i[2*l]=1,n.depth[l]=0,n.opt_len--,a&&(n.static_len-=a[2*l+1]);for(t.max_code=_,s=Math.floor(n.heap_len/2);s>=1;s--)n.pqdownheap(i,s);l=r;do{s=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(i,1),o=n.heap[1],n.heap[--n.heap_max]=s,n.heap[--n.heap_max]=o,i[2*l]=i[2*s]+i[2*o],n.depth[l]=Math.max(n.depth[s],n.depth[o])+1,i[2*s+1]=i[2*o+1]=l,n.heap[1]=l++,n.pqdownheap(i,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(e){const n=t.dyn_tree,i=t.stat_desc.static_tree,a=t.stat_desc.extra_bits,r=t.stat_desc.extra_base,s=t.stat_desc.max_length;let o,l,_,d,c,f,u=0;for(d=0;d<=15;d++)e.bl_count[d]=0;for(n[2*e.heap[e.heap_max]+1]=0,o=e.heap_max+1;o<573;o++)l=e.heap[o],d=n[2*n[2*l+1]+1]+1,d>s&&(d=s,u++),n[2*l+1]=d,l>t.max_code||(e.bl_count[d]++,c=0,l>=r&&(c=a[l-r]),f=n[2*l],e.opt_len+=f*(d+c),i&&(e.static_len+=f*(i[2*l+1]+c)));if(0!==u){do{for(d=s-1;0===e.bl_count[d];)d--;e.bl_count[d]--,e.bl_count[d+1]+=2,e.bl_count[s]--,u-=2;}while(u>0);for(d=s;0!==d;d--)for(l=e.bl_count[d];0!==l;)_=e.heap[--o],_>t.max_code||(n[2*_+1]!=d&&(e.opt_len+=(d-n[2*_+1])*n[2*_],n[2*_+1]=d),l--);}}(n),function(t,n,i){const a=[];let r,s,o,l=0;for(r=1;r<=15;r++)a[r]=l=l+i[r-1]<<1;for(s=0;s<=n;s++)o=t[2*s+1],0!==o&&(t[2*s]=e(a[o]++,o));}(i,t.max_code,n.bl_count);};}function L(t,e,n,i,a){const r=this;r.static_tree=t,r.extra_bits=e,r.extra_base=n,r.elems=i,r.max_length=a;}W._length_code=[0,1,2,3,4,5,6,7].concat(...P([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),W.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],W.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],W.d_code=function(t){return t<256?G[t]:G[256+(t>>>7)]},W.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],W.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],W.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],W.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],L.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],L.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],L.static_l_desc=new L(L.static_ltree,W.extra_lbits,257,286,15),L.static_d_desc=new L(L.static_dtree,W.extra_dbits,0,30,15),L.static_bl_desc=new L(null,W.extra_blbits,0,19,7);function T(t,e,n,i,a){const r=this;r.good_length=t,r.max_lazy=e,r.nice_length=n,r.max_chain=i,r.func=a;}const q=[new T(0,0,0,0,0),new T(4,4,8,4,1),new T(4,5,16,8,1),new T(4,6,32,32,1),new T(4,4,16,16,2),new T(8,16,32,32,2),new T(8,16,128,128,2),new T(8,32,128,256,2),new T(32,128,258,1024,2),new T(32,258,258,4096,2)],R=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function F(t,e,n,i){const a=t[2*e],r=t[2*n];return a<r||a==r&&i[e]<=i[n]}function J(){const t=this;let e,n,i,a,r,s,o,l,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v,A,U,S,z,I,E,C,M,B,H;const V=new W,D=new W,j=new W;let O,P,K,G,T,J,N,Q;function X(){let e;for(e=0;e<286;e++)M[2*e]=0;for(e=0;e<30;e++)B[2*e]=0;for(e=0;e<19;e++)H[2*e]=0;M[512]=1,t.opt_len=t.static_len=0,K=T=0;}function Y(t,e){let n,i=-1,a=t[1],r=0,s=7,o=4;0===a&&(s=138,o=3),t[2*(e+1)+1]=65535;for(let l=0;l<=e;l++)n=a,a=t[2*(l+1)+1],++r<s&&n==a||(r<o?H[2*n]+=r:0!==n?(n!=i&&H[2*n]++,H[32]++):r<=10?H[34]++:H[36]++,r=0,i=n,0===a?(s=138,o=3):n==a?(s=6,o=3):(s=7,o=4));}function Z(e){t.pending_buf[t.pending++]=e;}function $(t){Z(255&t),Z(t>>>8&255);}function tt(t,e){let n;const i=e;Q>16-i?(n=t,N|=n<<Q&65535,$(N),N=n>>>16-Q,Q+=i-16):(N|=t<<Q&65535,Q+=i);}function et(t,e){const n=2*t;tt(65535&e[n],65535&e[n+1]);}function nt(t,e){let n,i,a=-1,r=t[1],s=0,o=7,l=4;for(0===r&&(o=138,l=3),n=0;n<=e;n++)if(i=r,r=t[2*(n+1)+1],!(++s<o&&i==r)){if(s<l)do{et(i,H);}while(0!=--s);else 0!==i?(i!=a&&(et(i,H),s--),et(16,H),tt(s-3,2)):s<=10?(et(17,H),tt(s-3,3)):(et(18,H),tt(s-11,7));s=0,a=i,0===r?(o=138,l=3):i==r?(o=6,l=3):(o=7,l=4);}}function it(){16==Q?($(N),N=0,Q=0):Q>=8&&(Z(255&N),N>>>=8,Q-=8);}function at(e,n){let i,a,r;if(t.pending_buf[G+2*K]=e>>>8&255,t.pending_buf[G+2*K+1]=255&e,t.pending_buf[O+K]=255&n,K++,0===e?M[2*n]++:(T++,e--,M[2*(W._length_code[n]+256+1)]++,B[2*W.d_code(e)]++),0==(8191&K)&&z>2){for(i=8*K,a=m-p,r=0;r<30;r++)i+=B[2*r]*(5+W.extra_dbits[r]);if(i>>>=3,T<Math.floor(K/2)&&i<Math.floor(a/2))return !0}return K==P-1}function rt(e,n){let i,a,r,s,o=0;if(0!==K)do{i=t.pending_buf[G+2*o]<<8&65280|255&t.pending_buf[G+2*o+1],a=255&t.pending_buf[O+o],o++,0===i?et(a,e):(r=W._length_code[a],et(r+256+1,e),s=W.extra_lbits[r],0!==s&&(a-=W.base_length[r],tt(a,s)),i--,r=W.d_code(i),et(r,n),s=W.extra_dbits[r],0!==s&&(i-=W.base_dist[r],tt(i,s)));}while(o<K);et(256,e),J=e[513];}function st(){Q>8?$(N):Q>0&&Z(255&N),N=0,Q=0;}function ot(e,n,i){tt(0+(i?1:0),3),function(e,n,i){st(),J=8,i&&($(n),$(~n)),t.pending_buf.set(l.subarray(e,e+n),t.pending),t.pending+=n;}(e,n,!0);}function lt(e,n,i){let a,r,s=0;z>0?(V.build_tree(t),D.build_tree(t),s=function(){let e;for(Y(M,V.max_code),Y(B,D.max_code),j.build_tree(t),e=18;e>=3&&0===H[2*W.bl_order[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(),a=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=a&&(a=r)):a=r=n+5,n+4<=a&&-1!=e?ot(e,n,i):r==a?(tt(2+(i?1:0),3),rt(L.static_ltree,L.static_dtree)):(tt(4+(i?1:0),3),function(t,e,n){let i;for(tt(t-257,5),tt(e-1,5),tt(n-4,4),i=0;i<n;i++)tt(H[2*W.bl_order[i]+1],3);nt(M,t-1),nt(B,e-1);}(V.max_code+1,D.max_code+1,s+1),rt(M,B)),X(),i&&st();}function _t(t){lt(p>=0?p:-1,m-p,t),p=m,e.flush_pending();}function dt(){let t,n,i,a;do{if(a=_-v-m,0===a&&0===m&&0===v)a=r;else if(-1==a)a--;else if(m>=r+r-262){l.set(l.subarray(r,r+r),0),k-=r,m-=r,p-=r,t=u,i=t;do{n=65535&c[--i],c[i]=n>=r?n-r:0;}while(0!=--t);t=r,i=t;do{n=65535&d[--i],d[i]=n>=r?n-r:0;}while(0!=--t);a+=r;}if(0===e.avail_in)return;t=e.read_buf(l,m+v,a),v+=t,v>=3&&(f=255&l[m],f=(f<<w^255&l[m+1])&b);}while(v<262&&0!==e.avail_in)}function ct(t){let e,n,i=U,a=m,s=A;const _=m>r-262?m-(r-262):0;let c=C;const f=o,u=m+258;let h=l[a+s-1],b=l[a+s];A>=E&&(i>>=2),c>v&&(c=v);do{if(e=t,l[e+s]==b&&l[e+s-1]==h&&l[e]==l[a]&&l[++e]==l[a+1]){a+=2,e++;do{}while(l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&a<u);if(n=258-(u-a),a=u-258,n>s){if(k=t,s=n,n>=c)break;h=l[a+s-1],b=l[a+s];}}}while((t=65535&d[t&f])>_&&0!=--i);return s<=v?s:v}function ft(e){return e.total_in=e.total_out=0,e.msg=null,t.pending=0,t.pending_out=0,n=113,a=0,V.dyn_tree=M,V.stat_desc=L.static_l_desc,D.dyn_tree=B,D.stat_desc=L.static_d_desc,j.dyn_tree=H,j.stat_desc=L.static_bl_desc,N=0,Q=0,J=8,X(),function(){_=2*r,c[u-1]=0;for(let t=0;t<u-1;t++)c[t]=0;S=q[z].max_lazy,E=q[z].good_length,C=q[z].nice_length,U=q[z].max_chain,m=0,p=0,v=0,x=A=2,y=0,f=0;}(),0}t.depth=[],t.bl_count=[],t.heap=[],M=[],B=[],H=[],t.pqdownheap=function(e,n){const i=t.heap,a=i[n];let r=n<<1;for(;r<=t.heap_len&&(r<t.heap_len&&F(e,i[r+1],i[r],t.depth)&&r++,!F(e,a,i[r],t.depth));)i[n]=i[r],n=r,r<<=1;i[n]=a;},t.deflateInit=function(e,n,a,_,f,p){return _||(_=8),f||(f=8),p||(p=0),e.msg=null,-1==n&&(n=6),f<1||f>9||8!=_||a<9||a>15||n<0||n>9||p<0||p>2?-2:(e.dstate=t,s=a,r=1<<s,o=r-1,h=f+7,u=1<<h,b=u-1,w=Math.floor((h+3-1)/3),l=new Uint8Array(2*r),d=[],c=[],P=1<<f+6,t.pending_buf=new Uint8Array(4*P),i=4*P,G=Math.floor(P/2),O=3*P,z=n,I=p,ft(e))},t.deflateEnd=function(){return 42!=n&&113!=n&&666!=n?-2:(t.pending_buf=null,c=null,d=null,l=null,t.dstate=null,113==n?-3:0)},t.deflateParams=function(t,e,n){let i=0;return -1==e&&(e=6),e<0||e>9||n<0||n>2?-2:(q[z].func!=q[e].func&&0!==t.total_in&&(i=t.deflate(1)),z!=e&&(z=e,S=q[z].max_lazy,E=q[z].good_length,C=q[z].nice_length,U=q[z].max_chain),I=n,i)},t.deflateSetDictionary=function(t,e,i){let a,s=i,_=0;if(!e||42!=n)return -2;if(s<3)return 0;for(s>r-262&&(s=r-262,_=i-s),l.set(e.subarray(_,_+s),0),m=s,p=s,f=255&l[0],f=(f<<w^255&l[1])&b,a=0;a<=s-3;a++)f=(f<<w^255&l[a+2])&b,d[a&o]=c[f],c[f]=a;return 0},t.deflate=function(_,h){let U,E,C,M,B;if(h>4||h<0)return -2;if(!_.next_out||!_.next_in&&0!==_.avail_in||666==n&&4!=h)return _.msg=R[4],-2;if(0===_.avail_out)return _.msg=R[7],-5;var H;if(e=_,M=a,a=h,42==n&&(E=8+(s-8<<4)<<8,C=(z-1&255)>>1,C>3&&(C=3),E|=C<<6,0!==m&&(E|=32),E+=31-E%31,n=113,Z((H=E)>>8&255),Z(255&H)),0!==t.pending){if(e.flush_pending(),0===e.avail_out)return a=-1,0}else if(0===e.avail_in&&h<=M&&4!=h)return e.msg=R[7],-5;if(666==n&&0!==e.avail_in)return _.msg=R[7],-5;if(0!==e.avail_in||0!==v||0!=h&&666!=n){switch(B=-1,q[z].func){case 0:B=function(t){let n,a=65535;for(a>i-5&&(a=i-5);;){if(v<=1){if(dt(),0===v&&0==t)return 0;if(0===v)break}if(m+=v,v=0,n=p+a,(0===m||m>=n)&&(v=m-n,m=n,_t(!1),0===e.avail_out))return 0;if(m-p>=r-262&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 1:B=function(t){let n,i=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m),0!==i&&(m-i&65535)<=r-262&&2!=I&&(x=ct(i)),x>=3)if(n=at(m-k,x-3),v-=x,x<=S&&v>=3){x--;do{m++,f=(f<<w^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m;}while(0!=--x);m++;}else m+=x,x=0,f=255&l[m],f=(f<<w^255&l[m+1])&b;else n=at(0,255&l[m]),v--,m++;if(n&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 2:B=function(t){let n,i,a=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m),A=x,g=k,x=2,0!==a&&A<S&&(m-a&65535)<=r-262&&(2!=I&&(x=ct(a)),x<=5&&(1==I||3==x&&m-k>4096)&&(x=2)),A>=3&&x<=A){i=m+v-3,n=at(m-1-g,A-3),v-=A-1,A-=2;do{++m<=i&&(f=(f<<w^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m);}while(0!=--A);if(y=0,x=2,m++,n&&(_t(!1),0===e.avail_out))return 0}else if(0!==y){if(n=at(0,255&l[m-1]),n&&_t(!1),m++,v--,0===e.avail_out)return 0}else y=1,m++,v--;}return 0!==y&&(n=at(0,255&l[m-1]),y=0),_t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);}if(2!=B&&3!=B||(n=666),0==B||2==B)return 0===e.avail_out&&(a=-1),0;if(1==B){if(1==h)tt(2,3),et(256,L.static_ltree),it(),1+J+10-Q<9&&(tt(2,3),et(256,L.static_ltree),it()),J=7;else if(ot(0,0,!1),3==h)for(U=0;U<u;U++)c[U]=0;if(e.flush_pending(),0===e.avail_out)return a=-1,0}}return 4!=h?0:1};}function N(){const t=this;t.next_in_index=0,t.next_out_index=0,t.avail_in=0,t.total_in=0,t.avail_out=0,t.total_out=0;}function Q(t){const e=new N,n=(i=t&&t.chunkSize?t.chunkSize:65536)+5*(Math.floor(i/16383)+1);var i;const a=new Uint8Array(n);let r=t?t.level:-1;void 0===r&&(r=-1),e.deflateInit(r),e.next_out=a,this.append=function(t,i){let r,s,o=0,l=0,_=0;const d=[];if(t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,r=e.deflate(0),0!=r)throw new Error("deflating: "+e.msg);e.next_out_index&&(e.next_out_index==n?d.push(new Uint8Array(a)):d.push(a.slice(0,e.next_out_index))),_+=e.next_out_index,i&&e.next_in_index>0&&e.next_in_index!=o&&(i(e.next_in_index),o=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return d.length>1?(s=new Uint8Array(_),d.forEach((function(t){s.set(t,l),l+=t.length;}))):s=d[0]||new Uint8Array(0),s}},this.flush=function(){let t,i,r=0,s=0;const o=[];do{if(e.next_out_index=0,e.avail_out=n,t=e.deflate(4),1!=t&&0!=t)throw new Error("deflating: "+e.msg);n-e.avail_out>0&&o.push(a.slice(0,e.next_out_index)),s+=e.next_out_index;}while(e.avail_in>0||0===e.avail_out);return e.deflateEnd(),i=new Uint8Array(s),o.forEach((function(t){i.set(t,r),r+=t.length;})),i};}N.prototype={deflateInit:function(t,e){const n=this;return n.dstate=new J,e||(e=15),n.dstate.deflateInit(n,t,e)},deflate:function(t){const e=this;return e.dstate?e.dstate.deflate(e,t):-2},deflateEnd:function(){const t=this;if(!t.dstate)return -2;const e=t.dstate.deflateEnd();return t.dstate=null,e},deflateParams:function(t,e){const n=this;return n.dstate?n.dstate.deflateParams(n,t,e):-2},deflateSetDictionary:function(t,e){const n=this;return n.dstate?n.dstate.deflateSetDictionary(n,t,e):-2},read_buf:function(t,e,n){const i=this;let a=i.avail_in;return a>n&&(a=n),0===a?0:(i.avail_in-=a,t.set(i.next_in.subarray(i.next_in_index,i.next_in_index+a),e),i.next_in_index+=a,i.total_in+=a,a)},flush_pending:function(){const t=this;let e=t.dstate.pending;e>t.avail_out&&(e=t.avail_out),0!==e&&(t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out,t.dstate.pending_out+e),t.next_out_index),t.next_out_index+=e,t.dstate.pending_out+=e,t.total_out+=e,t.avail_out-=e,t.dstate.pending-=e,0===t.dstate.pending&&(t.dstate.pending_out=0));}};const X=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],Y=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],Z=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],$=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],tt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],et=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],nt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function it(){let t,e,n,i,a,r;function s(t,e,s,o,l,_,d,c,f,u,h){let b,w,p,x,g,y,m,k,v,A,U,S,z,I,E;A=0,g=s;do{n[t[e+A]]++,A++,g--;}while(0!==g);if(n[0]==s)return d[0]=-1,c[0]=0,0;for(k=c[0],y=1;y<=15&&0===n[y];y++);for(m=y,k<y&&(k=y),g=15;0!==g&&0===n[g];g--);for(p=g,k>g&&(k=g),c[0]=k,I=1<<y;y<g;y++,I<<=1)if((I-=n[y])<0)return -3;if((I-=n[g])<0)return -3;for(n[g]+=I,r[1]=y=0,A=1,z=2;0!=--g;)r[z]=y+=n[A],z++,A++;g=0,A=0;do{0!==(y=t[e+A])&&(h[r[y]++]=g),A++;}while(++g<s);for(s=r[p],r[0]=g=0,A=0,x=-1,S=-k,a[0]=0,U=0,E=0;m<=p;m++)for(b=n[m];0!=b--;){for(;m>S+k;){if(x++,S+=k,E=p-S,E=E>k?k:E,(w=1<<(y=m-S))>b+1&&(w-=b+1,z=m,y<E))for(;++y<E&&!((w<<=1)<=n[++z]);)w-=n[z];if(E=1<<y,u[0]+E>1440)return -3;a[x]=U=u[0],u[0]+=E,0!==x?(r[x]=g,i[0]=y,i[1]=k,y=g>>>S-k,i[2]=U-a[x-1]-y,f.set(i,3*(a[x-1]+y))):d[0]=U;}for(i[1]=m-S,A>=s?i[0]=192:h[A]<o?(i[0]=h[A]<256?0:96,i[2]=h[A++]):(i[0]=_[h[A]-o]+16+64,i[2]=l[h[A++]-o]),w=1<<m-S,y=g>>>S;y<E;y+=w)f.set(i,3*(U+y));for(y=1<<m-1;0!=(g&y);y>>>=1)g^=y;for(g^=y,v=(1<<S)-1;(g&v)!=r[x];)x--,S-=k,v=(1<<S)-1;}return 0!==I&&1!=p?-5:0}function o(s){let o;for(t||(t=[],e=[],n=new Int32Array(16),i=[],a=new Int32Array(15),r=new Int32Array(16)),e.length<s&&(e=[]),o=0;o<s;o++)e[o]=0;for(o=0;o<16;o++)n[o]=0;for(o=0;o<3;o++)i[o]=0;a.set(n.subarray(0,15),0),r.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,a,r,l){let _;return o(19),t[0]=0,_=s(n,0,19,19,null,null,a,i,r,t,e),-3==_?l.msg="oversubscribed dynamic bit lengths tree":-5!=_&&0!==i[0]||(l.msg="incomplete dynamic bit lengths tree",_=-3),_},this.inflate_trees_dynamic=function(n,i,a,r,l,_,d,c,f){let u;return o(288),t[0]=0,u=s(a,0,n,257,$,tt,_,r,c,t,e),0!=u||0===r[0]?(-3==u?f.msg="oversubscribed literal/length tree":-4!=u&&(f.msg="incomplete literal/length tree",u=-3),u):(o(288),u=s(a,n,i,0,et,nt,d,l,c,t,e),0!=u||0===l[0]&&n>257?(-3==u?f.msg="oversubscribed distance tree":-5==u?(f.msg="incomplete distance tree",u=-3):-4!=u&&(f.msg="empty distance tree with lengths",u=-3),u):0)};}it.inflate_trees_fixed=function(t,e,n,i){return t[0]=9,e[0]=5,n[0]=Y,i[0]=Z,0};function at(){const t=this;let e,n,i,a,r=0,s=0,o=0,l=0,_=0,d=0,c=0,f=0,u=0,h=0;function b(t,e,n,i,a,r,s,o){let l,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v;h=o.next_in_index,b=o.avail_in,f=s.bitb,u=s.bitk,w=s.write,p=w<s.read?s.read-w-1:s.end-w,x=X[t],g=X[e];do{for(;u<20;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(l=f&x,_=n,d=i,v=3*(d+l),0!==(c=_[v]))for(;;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15,y=_[v+2]+(f&X[c]),f>>=c,u-=c;u<15;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;for(l=f&g,_=a,d=r,v=3*(d+l),c=_[v];;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15;u<c;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(m=_[v+2]+(f&X[c]),f>>=c,u-=c,p-=y,w>=m)k=w-m,w-k>0&&2>w-k?(s.window[w++]=s.window[k++],s.window[w++]=s.window[k++],y-=2):(s.window.set(s.window.subarray(k,k+2),w),w+=2,k+=2,y-=2);else {k=w-m;do{k+=s.end;}while(k<0);if(c=s.end-k,y>c){if(y-=c,w-k>0&&c>w-k)do{s.window[w++]=s.window[k++];}while(0!=--c);else s.window.set(s.window.subarray(k,k+c),w),w+=c,k+=c,c=0;k=0;}}if(w-k>0&&y>w-k)do{s.window[w++]=s.window[k++];}while(0!=--y);else s.window.set(s.window.subarray(k,k+y),w),w+=y,k+=y,y=0;break}if(0!=(64&c))return o.msg="invalid distance code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,-3;l+=_[v+2],l+=f&X[c],v=3*(d+l),c=_[v];}break}if(0!=(64&c))return 0!=(32&c)?(y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,1):(o.msg="invalid literal/length code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,-3);if(l+=_[v+2],l+=f&X[c],v=3*(d+l),0===(c=_[v])){f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;break}}else f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;}while(p>=258&&b>=10);return y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,0}t.init=function(t,r,s,o,l,_){e=0,c=t,f=r,i=s,u=o,a=l,h=_,n=null;},t.proc=function(t,w,p){let x,g,y,m,k,v,A,U=0,S=0,z=0;for(z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k;;)switch(e){case 0:if(v>=258&&m>=10&&(t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,p=b(c,f,i,u,a,h,t,w),z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k,0!=p)){e=1==p?7:9;break}o=c,n=i,s=u,e=1;case 1:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>>=n[g+1],S-=n[g+1],y=n[g],0===y){l=n[g+2],e=6;break}if(0!=(16&y)){_=15&y,r=n[g+2],e=2;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}if(0!=(32&y)){e=7;break}return e=9,w.msg="invalid literal/length code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 2:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}r+=U&X[x],U>>=x,S-=x,o=f,n=a,s=h,e=3;case 3:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>=n[g+1],S-=n[g+1],y=n[g],0!=(16&y)){_=15&y,d=n[g+2],e=4;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}return e=9,w.msg="invalid distance code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 4:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}d+=U&X[x],U>>=x,S-=x,e=5;case 5:for(A=k-d;A<0;)A+=t.end;for(;0!==r;){if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);t.window[k++]=t.window[A++],v--,A==t.end&&(A=0),r--;}e=0;break;case 6:if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,t.window[k++]=l,v--,e=0;break;case 7:if(S>7&&(S-=8,m++,z--),t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,t.read!=t.write)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);e=8;case 8:return p=1,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 9:return p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);default:return p=-2,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p)}},t.free=function(){};}const rt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function st(t,e){const n=this;let i,a=0,r=0,s=0,o=0;const l=[0],_=[0],d=new at;let c=0,f=new Int32Array(4320);const u=new it;n.bitk=0,n.bitb=0,n.window=new Uint8Array(e),n.end=e,n.read=0,n.write=0,n.reset=function(t,e){e&&(e[0]=0),6==a&&d.free(t),a=0,n.bitk=0,n.bitb=0,n.read=n.write=0;},n.reset(t,null),n.inflate_flush=function(t,e){let i,a,r;return a=t.next_out_index,r=n.read,i=(r<=n.write?n.write:n.end)-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i,r==n.end&&(r=0,n.write==n.end&&(n.write=0),i=n.write-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i),t.next_out_index=a,n.read=r,e},n.proc=function(t,e){let h,b,w,p,x,g,y,m;for(p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g;;){let k,v,A,U,S,z,I,E;switch(a){case 0:for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}switch(h=7&b,c=1&h,h>>>1){case 0:b>>>=3,w-=3,h=7&w,b>>>=h,w-=h,a=1;break;case 1:k=[],v=[],A=[[]],U=[[]],it.inflate_trees_fixed(k,v,A,U),d.init(k[0],v[0],A[0],0,U[0],0),b>>>=3,w-=3,a=6;break;case 2:b>>>=3,w-=3,a=3;break;case 3:return b>>>=3,w-=3,a=9,t.msg="invalid block type",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}break;case 1:for(;w<32;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if((~b>>>16&65535)!=(65535&b))return a=9,t.msg="invalid stored block lengths",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);r=65535&b,b=w=0,a=0!==r?2:0!==c?7:0;break;case 2:if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(0===y&&(g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y&&(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y)))return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(e=0,h=r,h>x&&(h=x),h>y&&(h=y),n.window.set(t.read_buf(p,h),g),p+=h,x-=h,g+=h,y-=h,0!=(r-=h))break;a=0!==c?7:0;break;case 3:for(;w<14;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(s=h=16383&b,(31&h)>29||(h>>5&31)>29)return a=9,t.msg="too many length or distance symbols",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(h=258+(31&h)+(h>>5&31),!i||i.length<h)i=[];else for(m=0;m<h;m++)i[m]=0;b>>>=14,w-=14,o=0,a=4;case 4:for(;o<4+(s>>>10);){for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}i[rt[o++]]=7&b,b>>>=3,w-=3;}for(;o<19;)i[rt[o++]]=0;if(l[0]=7,h=u.inflate_trees_bits(i,l,_,f,t),0!=h)return -3==(e=h)&&(i=null,a=9),n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);o=0,a=5;case 5:for(;h=s,!(o>=258+(31&h)+(h>>5&31));){let r,d;for(h=l[0];w<h;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(h=f[3*(_[0]+(b&X[h]))+1],d=f[3*(_[0]+(b&X[h]))+2],d<16)b>>>=h,w-=h,i[o++]=d;else {for(m=18==d?7:d-14,r=18==d?11:3;w<h+m;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(b>>>=h,w-=h,r+=b&X[m],b>>>=m,w-=m,m=o,h=s,m+r>258+(31&h)+(h>>5&31)||16==d&&m<1)return i=null,a=9,t.msg="invalid bit length repeat",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d=16==d?i[m-1]:0;do{i[m++]=d;}while(0!=--r);o=m;}}if(_[0]=-1,S=[],z=[],I=[],E=[],S[0]=9,z[0]=6,h=s,h=u.inflate_trees_dynamic(257+(31&h),1+(h>>5&31),i,S,z,I,E,f,t),0!=h)return -3==h&&(i=null,a=9),e=h,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d.init(S[0],z[0],f,I[0],f,E[0]),a=6;case 6:if(n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,1!=(e=d.proc(n,t,e)))return n.inflate_flush(t,e);if(e=0,d.free(t),p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g,0===c){a=0;break}a=7;case 7:if(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);a=8;case 8:return e=1,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);case 9:return e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);default:return e=-2,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}}},n.free=function(t){n.reset(t,null),n.window=null,f=null;},n.set_dictionary=function(t,e,i){n.window.set(t.subarray(e,e+i),0),n.read=n.write=i;},n.sync_point=function(){return 1==a?1:0};}const ot=[0,0,255,255];function lt(){const t=this;function e(t){return t&&t.istate?(t.total_in=t.total_out=0,t.msg=null,t.istate.mode=7,t.istate.blocks.reset(t,null),0):-2}t.mode=0,t.method=0,t.was=[0],t.need=0,t.marker=0,t.wbits=0,t.inflateEnd=function(e){return t.blocks&&t.blocks.free(e),t.blocks=null,0},t.inflateInit=function(n,i){return n.msg=null,t.blocks=null,i<8||i>15?(t.inflateEnd(n),-2):(t.wbits=i,n.istate.blocks=new st(n,1<<i),e(n),0)},t.inflate=function(t,e){let n,i;if(!t||!t.istate||!t.next_in)return -2;const a=t.istate;for(e=4==e?-5:0,n=-5;;)switch(a.mode){case 0:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,8!=(15&(a.method=t.read_byte(t.next_in_index++)))){a.mode=13,t.msg="unknown compression method",a.marker=5;break}if(8+(a.method>>4)>a.wbits){a.mode=13,t.msg="invalid window size",a.marker=5;break}a.mode=1;case 1:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,i=255&t.read_byte(t.next_in_index++),((a.method<<8)+i)%31!=0){a.mode=13,t.msg="incorrect header check",a.marker=5;break}if(0==(32&i)){a.mode=7;break}a.mode=2;case 2:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need=(255&t.read_byte(t.next_in_index++))<<24&4278190080,a.mode=3;case 3:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<16&16711680,a.mode=4;case 4:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<8&65280,a.mode=5;case 5:return 0===t.avail_in?n:(n=e,t.avail_in--,t.total_in++,a.need+=255&t.read_byte(t.next_in_index++),a.mode=6,2);case 6:return a.mode=13,t.msg="need dictionary",a.marker=0,-2;case 7:if(n=a.blocks.proc(t,n),-3==n){a.mode=13,a.marker=0;break}if(0==n&&(n=e),1!=n)return n;n=e,a.blocks.reset(t,a.was),a.mode=12;case 12:return 1;case 13:return -3;default:return -2}},t.inflateSetDictionary=function(t,e,n){let i=0,a=n;if(!t||!t.istate||6!=t.istate.mode)return -2;const r=t.istate;return a>=1<<r.wbits&&(a=(1<<r.wbits)-1,i=n-a),r.blocks.set_dictionary(e,i,a),r.mode=7,0},t.inflateSync=function(t){let n,i,a,r,s;if(!t||!t.istate)return -2;const o=t.istate;if(13!=o.mode&&(o.mode=13,o.marker=0),0===(n=t.avail_in))return -5;for(i=t.next_in_index,a=o.marker;0!==n&&a<4;)t.read_byte(i)==ot[a]?a++:a=0!==t.read_byte(i)?0:4-a,i++,n--;return t.total_in+=i-t.next_in_index,t.next_in_index=i,t.avail_in=n,o.marker=a,4!=a?-3:(r=t.total_in,s=t.total_out,e(t),t.total_in=r,t.total_out=s,o.mode=7,0)},t.inflateSyncPoint=function(t){return t&&t.istate&&t.istate.blocks?t.istate.blocks.sync_point():-2};}function _t(){}function dt(t){const e=new _t,n=t&&t.chunkSize?Math.floor(2*t.chunkSize):131072,i=new Uint8Array(n);let a=!1;e.inflateInit(),e.next_out=i,this.append=function(t,r){const s=[];let o,l,_=0,d=0,c=0;if(0!==t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,0!==e.avail_in||a||(e.next_in_index=0,a=!0),o=e.inflate(0),a&&-5===o){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==o&&1!==o)throw new Error("inflating: "+e.msg);if((a||1===o)&&e.avail_in===t.length)throw new Error("inflating: bad input");e.next_out_index&&(e.next_out_index===n?s.push(new Uint8Array(i)):s.push(i.slice(0,e.next_out_index))),c+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=_&&(r(e.next_in_index),_=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return s.length>1?(l=new Uint8Array(c),s.forEach((function(t){l.set(t,d),d+=t.length;}))):l=s[0]||new Uint8Array(0),l}},this.flush=function(){e.inflateEnd();};}_t.prototype={inflateInit:function(t){const e=this;return e.istate=new lt,t||(t=15),e.istate.inflateInit(e,t)},inflate:function(t){const e=this;return e.istate?e.istate.inflate(e,t):-2},inflateEnd:function(){const t=this;if(!t.istate)return -2;const e=t.istate.inflateEnd(t);return t.istate=null,e},inflateSync:function(){const t=this;return t.istate?t.istate.inflateSync(t):-2},inflateSetDictionary:function(t,e){const n=this;return n.istate?n.istate.inflateSetDictionary(n,t,e):-2},read_byte:function(t){return this.next_in[t]},read_buf:function(t,e){return this.next_in.subarray(t,t+e)}},self.initCodec=()=>{self.Deflate=Q,self.Inflate=dt;};\n\n\t\t', n = URL.createObjectURL(new Blob([
            e
        ], {
            type: "text/javascript"
        }));
        configure({
            workerScripts: {
                inflate: [
                    n
                ],
                deflate: [
                    n
                ]
            }
        });
    }
};
const __default8 = (library, options = {
}, registerDataHandler)=>{
    return {
        Deflate: createCodecClass(library.Deflate, options.deflate, registerDataHandler),
        Inflate: createCodecClass(library.Inflate, options.inflate, registerDataHandler)
    };
};
function createCodecClass(constructor, constructorOptions, registerDataHandler) {
    return class {
        constructor(options){
            const codecAdapter = this;
            const onData = (data)=>{
                if (codecAdapter.pendingData) {
                    const pendingData = codecAdapter.pendingData;
                    codecAdapter.pendingData = new Uint8Array(pendingData.length + data.length);
                    codecAdapter.pendingData.set(pendingData, 0);
                    codecAdapter.pendingData.set(data, pendingData.length);
                } else {
                    codecAdapter.pendingData = new Uint8Array(data);
                }
            };
            codecAdapter.codec = new constructor(Object.assign({
            }, constructorOptions, options));
            registerDataHandler(codecAdapter.codec, onData);
        }
        async append(data) {
            this.codec.push(data);
            return getResponse(this);
        }
        async flush() {
            this.codec.push(new Uint8Array(0), true);
            return getResponse(this);
        }
    };
    function getResponse(codec) {
        if (codec.pendingData) {
            const output = codec.pendingData;
            codec.pendingData = null;
            return output;
        } else {
            return new Uint8Array(0);
        }
    }
}
const ERR_HTTP_STATUS = "HTTP error ";
const ERR_HTTP_RANGE = "HTTP Range not supported";
const CONTENT_TYPE_TEXT_PLAIN = "text/plain";
const HTTP_HEADER_CONTENT_LENGTH = "Content-Length";
const HTTP_HEADER_ACCEPT_RANGES = "Accept-Ranges";
const HTTP_HEADER_RANGE = "Range";
const HTTP_METHOD_HEAD = "HEAD";
const HTTP_METHOD_GET = "GET";
const HTTP_RANGE_UNIT = "bytes";
class Stream {
    constructor(){
        this.size = 0;
    }
    init() {
        this.initialized = true;
    }
}
class Reader extends Stream {
}
class Writer extends Stream {
    writeUint8Array(array) {
        this.size += array.length;
    }
}
class TextReader extends Reader {
    constructor(text){
        super();
        this.blobReader = new BlobReader(new Blob([
            text
        ], {
            type: CONTENT_TYPE_TEXT_PLAIN
        }));
    }
    async init() {
        super.init();
        this.blobReader.init();
        this.size = this.blobReader.size;
    }
    async readUint8Array(offset, length) {
        return this.blobReader.readUint8Array(offset, length);
    }
}
class TextWriter extends Writer {
    constructor(encoding){
        super();
        this.encoding = encoding;
        this.blob = new Blob([], {
            type: CONTENT_TYPE_TEXT_PLAIN
        });
    }
    async writeUint8Array(array) {
        super.writeUint8Array(array);
        this.blob = new Blob([
            this.blob,
            array.buffer
        ], {
            type: CONTENT_TYPE_TEXT_PLAIN
        });
    }
    getData() {
        const reader = new FileReader();
        return new Promise((resolve, reject)=>{
            reader.onload = (event)=>resolve(event.target.result)
            ;
            reader.onerror = ()=>reject(reader.error)
            ;
            reader.readAsText(this.blob, this.encoding);
        });
    }
}
class Data64URIReader extends Reader {
    constructor(dataURI){
        super();
        this.dataURI = dataURI;
        let dataEnd = dataURI.length;
        while(dataURI.charAt(dataEnd - 1) == "="){
            dataEnd--;
        }
        this.dataStart = dataURI.indexOf(",") + 1;
        this.size = Math.floor((dataEnd - this.dataStart) * 0.75);
    }
    async readUint8Array(offset, length) {
        const dataArray = new Uint8Array(length);
        const start = Math.floor(offset / 3) * 4;
        const bytes = atob(this.dataURI.substring(start + this.dataStart, Math.ceil((offset + length) / 3) * 4 + this.dataStart));
        const delta = offset - Math.floor(start / 4) * 3;
        for(let indexByte = delta; indexByte < delta + length; indexByte++){
            dataArray[indexByte - delta] = bytes.charCodeAt(indexByte);
        }
        return dataArray;
    }
}
class Data64URIWriter extends Writer {
    constructor(contentType){
        super();
        this.data = "data:" + (contentType || "") + ";base64,";
        this.pending = [];
    }
    async writeUint8Array(array) {
        super.writeUint8Array(array);
        let indexArray = 0;
        let dataString = this.pending;
        const delta = this.pending.length;
        this.pending = "";
        for(indexArray = 0; indexArray < Math.floor((delta + array.length) / 3) * 3 - delta; indexArray++){
            dataString += String.fromCharCode(array[indexArray]);
        }
        for(; indexArray < array.length; indexArray++){
            this.pending += String.fromCharCode(array[indexArray]);
        }
        if (dataString.length > 2) {
            this.data += btoa(dataString);
        } else {
            this.pending = dataString;
        }
    }
    getData() {
        return this.data + btoa(this.pending);
    }
}
class BlobReader extends Reader {
    constructor(blob){
        super();
        this.blob = blob;
        this.size = blob.size;
    }
    async readUint8Array(offset, length) {
        const reader = new FileReader();
        return new Promise((resolve, reject)=>{
            reader.onload = (event)=>resolve(new Uint8Array(event.target.result))
            ;
            reader.onerror = ()=>reject(reader.error)
            ;
            reader.readAsArrayBuffer(this.blob.slice(offset, offset + length));
        });
    }
}
class BlobWriter extends Writer {
    constructor(contentType1){
        super();
        this.contentType = contentType1;
        this.arrayBuffers = [];
    }
    async writeUint8Array(array) {
        super.writeUint8Array(array);
        this.arrayBuffers.push(array.buffer);
    }
    getData() {
        if (!this.blob) {
            this.blob = new Blob(this.arrayBuffers, {
                type: this.contentType
            });
        }
        return this.blob;
    }
}
class FetchReader extends Reader {
    constructor(url, options9){
        super();
        this.url = url;
        this.preventHeadRequest = options9.preventHeadRequest;
        this.useRangeHeader = options9.useRangeHeader;
        this.forceRangeRequests = options9.forceRangeRequests;
        this.options = Object.assign({
        }, options9);
        delete this.options.preventHeadRequest;
        delete this.options.useRangeHeader;
        delete this.options.forceRangeRequests;
        delete this.options.useXHR;
    }
    async init() {
        super.init();
        if (isHttpFamily(this.url) && !this.preventHeadRequest) {
            const response = await sendFetchRequest(HTTP_METHOD_HEAD, this.url, this.options);
            this.size = Number(response.headers.get(HTTP_HEADER_CONTENT_LENGTH));
            if (!this.forceRangeRequests && this.useRangeHeader && response.headers.get(HTTP_HEADER_ACCEPT_RANGES) != HTTP_RANGE_UNIT) {
                throw new Error(ERR_HTTP_RANGE);
            } else if (this.size === undefined) {
                await getFetchData(this, this.options);
            }
        } else {
            await getFetchData(this, this.options);
        }
    }
    async readUint8Array(index, length) {
        if (this.useRangeHeader) {
            const response = await sendFetchRequest(HTTP_METHOD_GET, this.url, this.options, Object.assign({
            }, this.options.headers, {
                [HTTP_HEADER_RANGE]: HTTP_RANGE_UNIT + "=" + index + "-" + (index + length - 1)
            }));
            if (response.status != 206) {
                throw new Error(ERR_HTTP_RANGE);
            }
            return new Uint8Array(await response.arrayBuffer());
        } else {
            if (!this.data) {
                await getFetchData(this, this.options);
            }
            return new Uint8Array(this.data.subarray(index, index + length));
        }
    }
}
async function getFetchData(httpReader, options) {
    const response = await sendFetchRequest(HTTP_METHOD_GET, httpReader.url, options);
    httpReader.data = new Uint8Array(await response.arrayBuffer());
    if (!httpReader.size) {
        httpReader.size = httpReader.data.length;
    }
}
async function sendFetchRequest(method, url, options, headers) {
    headers = Object.assign({
    }, options.headers, headers);
    const response = await fetch(url, Object.assign({
    }, options, {
        method,
        headers
    }));
    if (response.status < 400) {
        return response;
    } else {
        throw new Error(ERR_HTTP_STATUS + (response.statusText || response.status));
    }
}
class XHRReader extends Reader {
    constructor(url1, options10){
        super();
        this.url = url1;
        this.preventHeadRequest = options10.preventHeadRequest;
        this.useRangeHeader = options10.useRangeHeader;
        this.forceRangeRequests = options10.forceRangeRequests;
    }
    async init() {
        super.init();
        if (isHttpFamily(this.url) && !this.preventHeadRequest) {
            return new Promise((resolve, reject)=>sendXHR(HTTP_METHOD_HEAD, this.url, (request)=>{
                    this.size = Number(request.getResponseHeader(HTTP_HEADER_CONTENT_LENGTH));
                    if (this.useRangeHeader) {
                        if (this.forceRangeRequests || request.getResponseHeader(HTTP_HEADER_ACCEPT_RANGES) == HTTP_RANGE_UNIT) {
                            resolve();
                        } else {
                            reject(new Error(ERR_HTTP_RANGE));
                        }
                    } else if (this.size === undefined) {
                        getXHRData(this, this.url).then(()=>resolve()
                        ).catch(reject);
                    } else {
                        resolve();
                    }
                }, reject)
            );
        } else {
            await getXHRData(this, this.url);
        }
    }
    async readUint8Array(index, length) {
        if (this.useRangeHeader) {
            const request = await new Promise((resolve, reject)=>sendXHR(HTTP_METHOD_GET, this.url, (request)=>resolve(request)
                , reject, [
                    [
                        HTTP_HEADER_RANGE,
                        HTTP_RANGE_UNIT + "=" + index + "-" + (index + length - 1)
                    ]
                ])
            );
            if (request.status != 206) {
                throw new Error(ERR_HTTP_RANGE);
            }
            return new Uint8Array(request.response);
        } else {
            if (!this.data) {
                await getXHRData(this, this.url);
            }
            return new Uint8Array(this.data.subarray(index, index + length));
        }
    }
}
function getXHRData(httpReader, url) {
    return new Promise((resolve, reject)=>sendXHR(HTTP_METHOD_GET, url, (request)=>{
            httpReader.data = new Uint8Array(request.response);
            if (!httpReader.size) {
                httpReader.size = httpReader.data.length;
            }
            resolve();
        }, reject)
    );
}
function sendXHR(method, url, onload, onerror, headers = []) {
    const request = new XMLHttpRequest();
    request.addEventListener("load", ()=>{
        if (request.status < 400) {
            onload(request);
        } else {
            onerror(ERR_HTTP_STATUS + (request.statusText || request.status));
        }
    }, false);
    request.addEventListener("error", onerror, false);
    request.open(method, url);
    headers.forEach((header)=>request.setRequestHeader(header[0], header[1])
    );
    request.responseType = "arraybuffer";
    request.send();
    return request;
}
class HttpReader extends Reader {
    constructor(url2, options11 = {
    }){
        super();
        this.url = url2;
        if (options11.useXHR) {
            this.reader = new XHRReader(url2, options11);
        } else {
            this.reader = new FetchReader(url2, options11);
        }
    }
    set size(value) {
    }
    get size() {
        return this.reader.size;
    }
    async init() {
        super.init();
        await this.reader.init();
    }
    async readUint8Array(index, length) {
        return this.reader.readUint8Array(index, length);
    }
}
class HttpRangeReader extends HttpReader {
    constructor(url3, options12 = {
    }){
        options12.useRangeHeader = true;
        super(url3, options12);
    }
}
class Uint8ArrayReader extends Reader {
    constructor(array){
        super();
        this.array = array;
        this.size = array.length;
    }
    async readUint8Array(index, length) {
        return this.array.slice(index, index + length);
    }
}
class Uint8ArrayWriter extends Writer {
    constructor(){
        super();
        this.array = new Uint8Array(0);
    }
    async writeUint8Array(array) {
        super.writeUint8Array(array);
        const previousArray = this.array;
        this.array = new Uint8Array(previousArray.length + array.length);
        this.array.set(previousArray);
        this.array.set(array, previousArray.length);
    }
    getData() {
        return this.array;
    }
}
function isHttpFamily(url) {
    if (typeof document != "undefined") {
        const anchor = document.createElement("a");
        anchor.href = url;
        return anchor.protocol == "http:" || anchor.protocol == "https:";
    } else {
        return /^https?:\/\//i.test(url);
    }
}
const MAX_32_BITS = 4294967295;
const MAX_16_BITS = 65535;
const COMPRESSION_METHOD_DEFLATE = 8;
const COMPRESSION_METHOD_AES = 99;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = 22 + 20 + 56;
const BITFLAG_ENCRYPTED = 1;
const BITFLAG_DATA_DESCRIPTOR = 8;
const VERSION_ZIP64 = 45;
const VERSION_AES = 51;
const DIRECTORY_SIGNATURE = "/";
const MAX_DATE = new Date(2107, 11, 31);
const MIN_DATE = new Date(1980, 0, 1);
const CP437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split("");
const __default9 = (stringValue)=>{
    let result = "";
    for(let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++){
        result += CP437[stringValue[indexCharacter]];
    }
    return result;
};
const ERR_ABORT = "Abort error";
async function processData(codec, reader, writer, offset, inputLength, config, options) {
    const chunkSize = Math.max(config.chunkSize, 64);
    return processChunk();
    async function processChunk(chunkOffset = 0, outputLength = 0) {
        const signal = options.signal;
        if (chunkOffset < inputLength) {
            testAborted(signal, codec);
            const inputData = await reader.readUint8Array(chunkOffset + offset, Math.min(chunkSize, inputLength - chunkOffset));
            const chunkLength = inputData.length;
            testAborted(signal, codec);
            const data = await codec.append(inputData);
            testAborted(signal, codec);
            outputLength += await writeData(writer, data);
            if (options.onprogress) {
                try {
                    options.onprogress(chunkOffset + chunkLength, inputLength);
                } catch (error) {
                }
            }
            return processChunk(chunkOffset + chunkSize, outputLength);
        } else {
            const result = await codec.flush();
            outputLength += await writeData(writer, result.data);
            return {
                signature: result.signature,
                length: outputLength
            };
        }
    }
}
function testAborted(signal, codec) {
    if (signal && signal.aborted) {
        codec.flush();
        throw new Error(ERR_ABORT);
    }
}
async function writeData(writer, data) {
    if (data.length) {
        await writer.writeUint8Array(data);
    }
    return data.length;
}
const PROPERTY_NAMES = [
    "filename",
    "rawFilename",
    "directory",
    "encrypted",
    "compressedSize",
    "uncompressedSize",
    "lastModDate",
    "rawLastModDate",
    "comment",
    "rawComment",
    "signature",
    "extraField",
    "rawExtraField",
    "bitFlag",
    "extraFieldZip64",
    "extraFieldUnicodePath",
    "extraFieldUnicodeComment",
    "extraFieldAES",
    "filenameUTF8",
    "commentUTF8",
    "offset",
    "zip64",
    "compressionMethod",
    "extraFieldNTFS",
    "lastAccessDate",
    "creationDate",
    "extraFieldExtendedTimestamp",
    "version",
    "versionMadeBy",
    "msDosCompatible",
    "internalFileAttribute",
    "externalFileAttribute"
];
class Entry {
    constructor(data1){
        PROPERTY_NAMES.forEach((name)=>this[name] = data1[name]
        );
    }
}
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const CHARSET_UTF8 = "utf-8";
const ZIP64_PROPERTIES = [
    "uncompressedSize",
    "compressedSize",
    "offset"
];
class ZipReader {
    constructor(reader2, options13 = {
    }){
        Object.assign(this, {
            reader: reader2,
            options: options13,
            config: getConfiguration()
        });
    }
    async getEntries(options = {
    }) {
        const zipReader = this;
        const reader = zipReader.reader;
        if (!reader.initialized) {
            await reader.init();
        }
        if (reader.size < 22) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const endOfDirectoryInfo = await seekSignature(reader, 101010256, reader.size, 22, 65535 * 16);
        if (!endOfDirectoryInfo) {
            throw new Error(ERR_EOCDR_NOT_FOUND);
        }
        const endOfDirectoryView = getDataView(endOfDirectoryInfo);
        let directoryDataLength = getUint32(endOfDirectoryView, 12);
        let directoryDataOffset = getUint32(endOfDirectoryView, 16);
        let filesLength = getUint16(endOfDirectoryView, 8);
        let prependedDataLength = 0;
        if (directoryDataOffset == 4294967295 || directoryDataLength == 4294967295 || filesLength == 65535) {
            const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - 20, 20);
            const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
            if (getUint32(endOfDirectoryLocatorView, 0) != 117853008) {
                throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
            }
            directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
            let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, 56);
            let endOfDirectoryView = getDataView(endOfDirectoryArray);
            const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - 20 - 56;
            if (getUint32(endOfDirectoryView, 0) != 101075792 && directoryDataOffset != expectedDirectoryDataOffset) {
                const originalDirectoryDataOffset = directoryDataOffset;
                directoryDataOffset = expectedDirectoryDataOffset;
                prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
                endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);
                endOfDirectoryView = getDataView(endOfDirectoryArray);
            }
            if (getUint32(endOfDirectoryView, 0) != 101075792) {
                throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
            }
            filesLength = getBigUint64(endOfDirectoryView, 32);
            directoryDataLength = getBigUint64(endOfDirectoryView, 40);
            directoryDataOffset -= directoryDataLength;
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        let offset = 0;
        let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
        let directoryView = getDataView(directoryArray);
        const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
        if (getUint32(directoryView, offset) != 33639248 && directoryDataOffset != expectedDirectoryDataOffset) {
            const originalDirectoryDataOffset = directoryDataOffset;
            directoryDataOffset = expectedDirectoryDataOffset;
            prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
            directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
            directoryView = getDataView(directoryArray);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const entries = [];
        for(let indexFile = 0; indexFile < filesLength; indexFile++){
            const fileEntry = new ZipEntry(reader, zipReader.config, zipReader.options);
            if (getUint32(directoryView, offset) != 33639248) {
                throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
            }
            readCommonHeader(fileEntry, directoryView, offset + 6);
            const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
            const filenameOffset = offset + 46;
            const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
            const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
            const versionMadeBy = getUint16(directoryView, offset + 4);
            const msDosCompatible = (versionMadeBy & 0) == 0;
            Object.assign(fileEntry, {
                versionMadeBy,
                msDosCompatible,
                compressedSize: 0,
                uncompressedSize: 0,
                commentLength: getUint16(directoryView, offset + 32),
                directory: msDosCompatible && (getUint8(directoryView, offset + 38) & 16) == 16,
                offset: getUint32(directoryView, offset + 42) + prependedDataLength,
                internalFileAttribute: getUint32(directoryView, offset + 34),
                externalFileAttribute: getUint32(directoryView, offset + 38),
                rawFilename: directoryArray.subarray(filenameOffset, extraFieldOffset),
                filenameUTF8: languageEncodingFlag,
                commentUTF8: languageEncodingFlag,
                rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
            });
            const endOffset = commentOffset + fileEntry.commentLength;
            fileEntry.rawComment = directoryArray.subarray(commentOffset, endOffset);
            fileEntry.filename = decodeString(fileEntry.rawFilename, fileEntry.filenameUTF8 ? CHARSET_UTF8 : getOptionValue(zipReader, options, "filenameEncoding"));
            fileEntry.comment = decodeString(fileEntry.rawComment, fileEntry.commentUTF8 ? CHARSET_UTF8 : getOptionValue(zipReader, options, "commentEncoding"));
            if (!fileEntry.directory && fileEntry.filename.endsWith(DIRECTORY_SIGNATURE)) {
                fileEntry.directory = true;
            }
            readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
            const entry = new Entry(fileEntry);
            entry.getData = (writer, options)=>fileEntry.getData(writer, entry, options)
            ;
            entries.push(entry);
            offset = endOffset;
            if (options.onprogress) {
                try {
                    options.onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
                } catch (error) {
                }
            }
        }
        return entries;
    }
    async close() {
    }
}
class ZipEntry {
    constructor(reader3, config1, options14){
        Object.assign(this, {
            reader: reader3,
            config: config1,
            options: options14
        });
    }
    async getData(writer, fileEntry, options = {
    }) {
        const zipEntry = this;
        const { reader , offset , extraFieldAES , compressionMethod , config , bitFlag , signature , rawLastModDate , compressedSize  } = zipEntry;
        const localDirectory = zipEntry.localDirectory = {
        };
        if (!reader.initialized) {
            await reader.init();
        }
        let dataArray = await readUint8Array(reader, offset, 30);
        const dataView = getDataView(dataArray);
        let password = getOptionValue(zipEntry, options, "password");
        password = password && password.length && password;
        if (extraFieldAES) {
            if (extraFieldAES.originalCompressionMethod != 99) {
                throw new Error(ERR_UNSUPPORTED_COMPRESSION);
            }
        }
        if (compressionMethod != 0 && compressionMethod != 8) {
            throw new Error(ERR_UNSUPPORTED_COMPRESSION);
        }
        if (getUint32(dataView, 0) != 67324752) {
            throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
        }
        readCommonHeader(localDirectory, dataView, 4);
        dataArray = await readUint8Array(reader, offset, 30 + localDirectory.filenameLength + localDirectory.extraFieldLength);
        localDirectory.rawExtraField = dataArray.subarray(30 + localDirectory.filenameLength);
        readCommonFooter(zipEntry, localDirectory, dataView, 4);
        fileEntry.lastAccessDate = localDirectory.lastAccessDate;
        fileEntry.creationDate = localDirectory.creationDate;
        const encrypted = zipEntry.encrypted && localDirectory.encrypted;
        const zipCrypto = encrypted && !extraFieldAES;
        if (encrypted) {
            if (!zipCrypto && extraFieldAES.strength === undefined) {
                throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
            } else if (!password) {
                throw new Error(ERR_ENCRYPTED);
            }
        }
        const codec = await createCodec1(config.Inflate, {
            codecType: CODEC_INFLATE,
            password,
            zipCrypto,
            encryptionStrength: extraFieldAES && extraFieldAES.strength,
            signed: getOptionValue(zipEntry, options, "checkSignature"),
            passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 255 : signature >>> 24 & 255),
            signature,
            compressed: compressionMethod != 0,
            encrypted,
            useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers")
        }, config);
        if (!writer.initialized) {
            await writer.init();
        }
        const signal = getOptionValue(zipEntry, options, "signal");
        const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
        await processData(codec, reader, writer, dataOffset, compressedSize, config, {
            onprogress: options.onprogress,
            signal
        });
        return writer.getData();
    }
}
function readCommonHeader(directory, dataView, offset) {
    const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
    const encrypted = (rawBitFlag & 1) == 1;
    const rawLastModDate = getUint32(dataView, offset + 6);
    Object.assign(directory, {
        encrypted,
        version: getUint16(dataView, offset),
        bitFlag: {
            level: (rawBitFlag & 6) >> 1,
            dataDescriptor: (rawBitFlag & 8) == 8,
            languageEncodingFlag: (rawBitFlag & 2048) == 2048
        },
        rawLastModDate,
        lastModDate: getDate(rawLastModDate),
        filenameLength: getUint16(dataView, offset + 22),
        extraFieldLength: getUint16(dataView, offset + 24)
    });
}
function readCommonFooter(fileEntry, directory, dataView, offset) {
    const rawExtraField = directory.rawExtraField;
    const extraField = directory.extraField = new Map();
    const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
    let offsetExtraField = 0;
    try {
        while(offsetExtraField < rawExtraField.length){
            const type = getUint16(rawExtraFieldView, offsetExtraField);
            const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
            extraField.set(type, {
                type,
                data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
            });
            offsetExtraField += 4 + size;
        }
    } catch (error) {
    }
    const compressionMethod = getUint16(dataView, offset + 4);
    directory.signature = getUint32(dataView, offset + 10);
    directory.uncompressedSize = getUint32(dataView, offset + 18);
    directory.compressedSize = getUint32(dataView, offset + 14);
    const extraFieldZip64 = extraField.get(1);
    if (extraFieldZip64) {
        readExtraFieldZip64(extraFieldZip64, directory);
        directory.extraFieldZip64 = extraFieldZip64;
    }
    const extraFieldUnicodePath = extraField.get(28789);
    if (extraFieldUnicodePath) {
        readExtraFieldUnicode(extraFieldUnicodePath, "filename", "rawFilename", directory, fileEntry);
        directory.extraFieldUnicodePath = extraFieldUnicodePath;
    }
    const extraFieldUnicodeComment = extraField.get(25461);
    if (extraFieldUnicodeComment) {
        readExtraFieldUnicode(extraFieldUnicodeComment, "comment", "rawComment", directory, fileEntry);
        directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
    }
    const extraFieldAES = extraField.get(39169);
    if (extraFieldAES) {
        readExtraFieldAES(extraFieldAES, directory, compressionMethod);
        directory.extraFieldAES = extraFieldAES;
    } else {
        directory.compressionMethod = compressionMethod;
    }
    const extraFieldNTFS = extraField.get(10);
    if (extraFieldNTFS) {
        readExtraFieldNTFS(extraFieldNTFS, directory);
        directory.extraFieldNTFS = extraFieldNTFS;
    }
    const extraFieldExtendedTimestamp = extraField.get(21589);
    if (extraFieldExtendedTimestamp) {
        readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);
        directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
    }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
    directory.zip64 = true;
    const extraFieldView = getDataView(extraFieldZip64.data);
    extraFieldZip64.values = [];
    for(let indexValue = 0; indexValue < Math.floor(extraFieldZip64.data.length / 8); indexValue++){
        extraFieldZip64.values.push(getBigUint64(extraFieldView, 0 + indexValue * 8));
    }
    const missingProperties = ZIP64_PROPERTIES.filter((propertyName)=>directory[propertyName] == 4294967295
    );
    for(let indexMissingProperty = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++){
        extraFieldZip64[missingProperties[indexMissingProperty]] = extraFieldZip64.values[indexMissingProperty];
    }
    ZIP64_PROPERTIES.forEach((propertyName)=>{
        if (directory[propertyName] == 4294967295) {
            if (extraFieldZip64[propertyName] !== undefined) {
                directory[propertyName] = extraFieldZip64[propertyName];
            } else {
                throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
            }
        }
    });
}
function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
    const extraFieldView = getDataView(extraFieldUnicode.data);
    extraFieldUnicode.version = getUint8(extraFieldView, 0);
    extraFieldUnicode.signature = getUint32(extraFieldView, 1);
    const crc32 = new Crc32();
    crc32.append(fileEntry[rawPropertyName]);
    const dataViewSignature = getDataView(new Uint8Array(4));
    dataViewSignature.setUint32(0, crc32.get(), true);
    extraFieldUnicode[propertyName] = new TextDecoder().decode(extraFieldUnicode.data.subarray(5));
    extraFieldUnicode.valid = !fileEntry.bitFlag.languageEncodingFlag && extraFieldUnicode.signature == getUint32(dataViewSignature, 0);
    if (extraFieldUnicode.valid) {
        directory[propertyName] = extraFieldUnicode[propertyName];
        directory[propertyName + "UTF8"] = true;
    }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
    const extraFieldView = getDataView(extraFieldAES.data);
    extraFieldAES.vendorVersion = getUint8(extraFieldView, 0);
    extraFieldAES.vendorId = getUint8(extraFieldView, 2);
    const strength = getUint8(extraFieldView, 4);
    extraFieldAES.strength = strength;
    extraFieldAES.originalCompressionMethod = compressionMethod;
    directory.compressionMethod = extraFieldAES.compressionMethod = getUint16(extraFieldView, 5);
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
    const extraFieldView = getDataView(extraFieldNTFS.data);
    let offsetExtraField = 4;
    let tag1Data;
    try {
        while(offsetExtraField < extraFieldNTFS.data.length && !tag1Data){
            const tagValue = getUint16(extraFieldView, offsetExtraField);
            const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
            if (tagValue == 1) {
                tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
            }
            offsetExtraField += 4 + attributeSize;
        }
    } catch (error) {
    }
    try {
        if (tag1Data && tag1Data.length == 24) {
            const tag1View = getDataView(tag1Data);
            const rawLastModDate = tag1View.getBigUint64(0, true);
            const rawLastAccessDate = tag1View.getBigUint64(8, true);
            const rawCreationDate = tag1View.getBigUint64(16, true);
            Object.assign(extraFieldNTFS, {
                rawLastModDate,
                rawLastAccessDate,
                rawCreationDate
            });
            const lastModDate = getDateNTFS(rawLastModDate);
            const lastAccessDate = getDateNTFS(rawLastAccessDate);
            const creationDate = getDateNTFS(rawCreationDate);
            const extraFieldData = {
                lastModDate,
                lastAccessDate,
                creationDate
            };
            Object.assign(extraFieldNTFS, extraFieldData);
            Object.assign(directory, extraFieldData);
        }
    } catch (error1) {
    }
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {
    const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
    const flags = getUint8(extraFieldView, 0);
    const timeProperties = [];
    const timeRawProperties = [];
    if ((flags & 1) == 1) {
        timeProperties.push("lastModDate");
        timeRawProperties.push("rawLastModDate");
    }
    if ((flags & 2) == 2) {
        timeProperties.push("lastAccessDate");
        timeRawProperties.push("rawLastAccessDate");
    }
    if ((flags & 4) == 4) {
        timeProperties.push("creationDate");
        timeRawProperties.push("rawCreationDate");
    }
    let offset = 1;
    timeProperties.forEach((propertyName, indexProperty)=>{
        if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
            const time = getUint32(extraFieldView, offset);
            directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
            const rawPropertyName = timeRawProperties[indexProperty];
            extraFieldExtendedTimestamp[rawPropertyName] = time;
        }
        offset += 4;
    });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
    const signatureArray = new Uint8Array(4);
    const signatureView = getDataView(signatureArray);
    setUint32(signatureView, 0, signature);
    const maximumBytes = minimumBytes + maximumLength;
    return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
    async function seek(length) {
        const offset = startOffset - length;
        const bytes = await readUint8Array(reader, offset, length);
        for(let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--){
            if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
                return {
                    offset: offset + indexByte,
                    buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
                };
            }
        }
    }
}
function getOptionValue(zipReader, options, name) {
    return options[name] === undefined ? zipReader.options[name] : options[name];
}
function decodeString(value, encoding) {
    if (!encoding || encoding.trim().toLowerCase() == "cp437") {
        return __default9(value);
    } else {
        return new TextDecoder(encoding).decode(value);
    }
}
function getDate(timeRaw) {
    const date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
    try {
        return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
    } catch (error) {
    }
}
function getDateNTFS(timeRaw) {
    return new Date(Number(timeRaw / BigInt(10000) - BigInt(11644473600000)));
}
function getUint8(view, offset) {
    return view.getUint8(offset);
}
function getUint16(view, offset) {
    return view.getUint16(offset, true);
}
function getUint32(view, offset) {
    return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
    return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
    view.setUint32(offset, value, true);
}
function getDataView(array) {
    return new DataView(array.buffer);
}
function readUint8Array(reader, offset, size) {
    return reader.readUint8Array(offset, size);
}
const ERR_DUPLICATED_NAME = "File already exists";
const ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
const ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
const ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
const ERR_INVALID_VERSION = "Version exceeds 65535";
const ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
const ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
const ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
const ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported";
const EXTRAFIELD_DATA_AES = new Uint8Array([
    7,
    0,
    2,
    0,
    65,
    69,
    3,
    0,
    0
]);
let workers = 0;
class ZipWriter {
    constructor(writer3, options15 = {
    }){
        Object.assign(this, {
            writer: writer3,
            options: options15,
            config: getConfiguration(),
            files: new Map(),
            offset: writer3.size,
            pendingCompressedSize: 0,
            pendingEntries: []
        });
    }
    async add(name = "", reader, options = {
    }) {
        const zipWriter = this;
        if (workers < zipWriter.config.maxWorkers) {
            workers++;
            try {
                return await addFile(zipWriter, name, reader, options);
            } finally{
                workers--;
                const pendingEntry = zipWriter.pendingEntries.shift();
                if (pendingEntry) {
                    zipWriter.add(pendingEntry.name, pendingEntry.reader, pendingEntry.options).then(pendingEntry.resolve).catch(pendingEntry.reject);
                }
            }
        } else {
            return new Promise((resolve, reject)=>zipWriter.pendingEntries.push({
                    name,
                    reader,
                    options,
                    resolve,
                    reject
                })
            );
        }
    }
    async close(comment = new Uint8Array(0), options = {
    }) {
        await closeFile(this, comment, options);
        return this.writer.getData();
    }
}
async function addFile(zipWriter, name, reader, options) {
    name = name.trim();
    if (options.directory && !name.endsWith(DIRECTORY_SIGNATURE)) {
        name += DIRECTORY_SIGNATURE;
    } else {
        options.directory = name.endsWith(DIRECTORY_SIGNATURE);
    }
    if (zipWriter.files.has(name)) {
        throw new Error(ERR_DUPLICATED_NAME);
    }
    const rawFilename = new TextEncoder().encode(name);
    if (rawFilename.length > 65535) {
        throw new Error(ERR_INVALID_ENTRY_NAME);
    }
    const comment = options.comment || "";
    const rawComment = new TextEncoder().encode(comment);
    if (rawComment.length > 65535) {
        throw new Error(ERR_INVALID_ENTRY_COMMENT);
    }
    const version = zipWriter.options.version || options.version || 0;
    if (version > 65535) {
        throw new Error(ERR_INVALID_VERSION);
    }
    const versionMadeBy = zipWriter.options.versionMadeBy || options.versionMadeBy || 20;
    if (versionMadeBy > 65535) {
        throw new Error(ERR_INVALID_VERSION);
    }
    const lastModDate = getOptionValue1(zipWriter, options, "lastModDate") || new Date();
    const lastAccessDate = getOptionValue1(zipWriter, options, "lastAccessDate");
    const creationDate = getOptionValue1(zipWriter, options, "creationDate");
    const password = getOptionValue1(zipWriter, options, "password");
    const encryptionStrength = getOptionValue1(zipWriter, options, "encryptionStrength") || 3;
    const zipCrypto = getOptionValue1(zipWriter, options, "zipCrypto");
    if (password !== undefined && encryptionStrength !== undefined && (encryptionStrength < 1 || encryptionStrength > 3)) {
        throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
    }
    let rawExtraField = new Uint8Array(0);
    const extraField = options.extraField;
    if (extraField) {
        let extraFieldSize = 0;
        let offset = 0;
        extraField.forEach((data)=>extraFieldSize += 4 + data.length
        );
        rawExtraField = new Uint8Array(extraFieldSize);
        extraField.forEach((data, type)=>{
            if (type > 65535) {
                throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
            }
            if (data.length > 65535) {
                throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
            }
            arraySet(rawExtraField, new Uint16Array([
                type
            ]), offset);
            arraySet(rawExtraField, new Uint16Array([
                data.length
            ]), offset + 2);
            arraySet(rawExtraField, data, offset + 4);
            offset += 4 + data.length;
        });
    }
    let extendedTimestamp = getOptionValue1(zipWriter, options, "extendedTimestamp");
    if (extendedTimestamp === undefined) {
        extendedTimestamp = true;
    }
    let maximumCompressedSize = 0;
    let keepOrder = getOptionValue1(zipWriter, options, "keepOrder");
    if (keepOrder === undefined) {
        keepOrder = true;
    }
    let uncompressedSize = 0;
    let msDosCompatible = getOptionValue1(zipWriter, options, "msDosCompatible");
    if (msDosCompatible === undefined) {
        msDosCompatible = true;
    }
    const internalFileAttribute = getOptionValue1(zipWriter, options, "internalFileAttribute") || 0;
    const externalFileAttribute = getOptionValue1(zipWriter, options, "externalFileAttribute") || 0;
    if (reader) {
        if (!reader.initialized) {
            await reader.init();
        }
        uncompressedSize = reader.size;
        maximumCompressedSize = getMaximumCompressedSize1(uncompressedSize);
    }
    let zip64 = options.zip64 || zipWriter.options.zip64 || false;
    if (zipWriter.offset + zipWriter.pendingCompressedSize >= 4294967295 || uncompressedSize >= 4294967295 || maximumCompressedSize >= 4294967295) {
        if (options.zip64 === false || zipWriter.options.zip64 === false || !keepOrder) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    zipWriter.pendingCompressedSize += maximumCompressedSize;
    await Promise.resolve();
    const level = getOptionValue1(zipWriter, options, "level");
    const useWebWorkers = getOptionValue1(zipWriter, options, "useWebWorkers");
    const bufferedWrite = getOptionValue1(zipWriter, options, "bufferedWrite");
    let dataDescriptor = getOptionValue1(zipWriter, options, "dataDescriptor");
    let dataDescriptorSignature = getOptionValue1(zipWriter, options, "dataDescriptorSignature");
    const signal = getOptionValue1(zipWriter, options, "signal");
    if (dataDescriptor === undefined) {
        dataDescriptor = true;
    }
    if (dataDescriptor && dataDescriptorSignature === undefined) {
        dataDescriptorSignature = true;
    }
    const fileEntry = await getFileEntry(zipWriter, name, reader, Object.assign({
    }, options, {
        rawFilename,
        rawComment,
        version,
        versionMadeBy,
        lastModDate,
        lastAccessDate,
        creationDate,
        rawExtraField,
        zip64,
        password,
        level,
        useWebWorkers,
        encryptionStrength,
        extendedTimestamp,
        zipCrypto,
        bufferedWrite,
        keepOrder,
        dataDescriptor,
        dataDescriptorSignature,
        signal,
        msDosCompatible,
        internalFileAttribute,
        externalFileAttribute
    }));
    if (maximumCompressedSize) {
        zipWriter.pendingCompressedSize -= maximumCompressedSize;
    }
    Object.assign(fileEntry, {
        name,
        comment,
        extraField
    });
    return new Entry(fileEntry);
}
async function getFileEntry(zipWriter, name, reader, options) {
    const files = zipWriter.files;
    const writer = zipWriter.writer;
    const previousFileEntry = Array.from(files.values()).pop();
    let fileEntry = {
    };
    let bufferedWrite;
    let resolveLockUnbufferedWrite;
    let resolveLockCurrentFileEntry;
    files.set(name, fileEntry);
    try {
        let lockPreviousFileEntry;
        let fileWriter;
        let lockCurrentFileEntry;
        if (options.keepOrder) {
            lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
        }
        fileEntry.lock = lockCurrentFileEntry = new Promise((resolve)=>resolveLockCurrentFileEntry = resolve
        );
        if (options.bufferedWrite || zipWriter.lockWrite || !options.dataDescriptor) {
            fileWriter = new BlobWriter();
            fileWriter.init();
            bufferedWrite = true;
        } else {
            zipWriter.lockWrite = new Promise((resolve)=>resolveLockUnbufferedWrite = resolve
            );
            if (!writer.initialized) {
                await writer.init();
            }
            fileWriter = writer;
        }
        fileEntry = await createFileEntry(reader, fileWriter, zipWriter.config, options);
        fileEntry.lock = lockCurrentFileEntry;
        files.set(name, fileEntry);
        fileEntry.filename = name;
        if (bufferedWrite) {
            let indexWrittenData = 0;
            const blob = fileWriter.getData();
            await Promise.all([
                zipWriter.lockWrite,
                lockPreviousFileEntry
            ]);
            let pendingFileEntry;
            do {
                pendingFileEntry = Array.from(files.values()).find((fileEntry)=>fileEntry.writingBufferedData
                );
                if (pendingFileEntry) {
                    await pendingFileEntry.lock;
                }
            }while (pendingFileEntry && pendingFileEntry.lock)
            fileEntry.writingBufferedData = true;
            if (!options.dataDescriptor) {
                const headerLength = 26;
                const arrayBuffer = await sliceAsArrayBuffer(blob, 0, 26);
                const arrayBufferView = new DataView(arrayBuffer);
                if (!fileEntry.encrypted || options.zipCrypto) {
                    setUint321(arrayBufferView, 14, fileEntry.signature);
                }
                if (fileEntry.zip64) {
                    setUint321(arrayBufferView, 18, 4294967295);
                    setUint321(arrayBufferView, 22, 4294967295);
                } else {
                    setUint321(arrayBufferView, 18, fileEntry.compressedSize);
                    setUint321(arrayBufferView, 22, fileEntry.uncompressedSize);
                }
                await writer.writeUint8Array(new Uint8Array(arrayBuffer));
                indexWrittenData = headerLength;
            }
            await writeBlob(writer, blob, indexWrittenData);
            delete fileEntry.writingBufferedData;
        }
        fileEntry.offset = zipWriter.offset;
        if (fileEntry.zip64) {
            const rawExtraFieldZip64View = getDataView1(fileEntry.rawExtraFieldZip64);
            setBigUint64(rawExtraFieldZip64View, 20, BigInt(fileEntry.offset));
        } else if (fileEntry.offset >= 4294967295) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        }
        zipWriter.offset += fileEntry.length;
        return fileEntry;
    } catch (error) {
        if (bufferedWrite && fileEntry.writingBufferedData || !bufferedWrite && fileEntry.dataWritten) {
            error.corruptedEntry = zipWriter.hasCorruptedEntries = true;
            if (fileEntry.uncompressedSize) {
                zipWriter.offset += fileEntry.uncompressedSize;
            }
        }
        files.delete(name);
        throw error;
    } finally{
        resolveLockCurrentFileEntry();
        if (resolveLockUnbufferedWrite) {
            resolveLockUnbufferedWrite();
        }
    }
}
async function createFileEntry(reader, writer, config, options) {
    const { rawFilename , lastAccessDate , creationDate , password , level , zip64 , zipCrypto , dataDescriptor , dataDescriptorSignature , directory , version , versionMadeBy , rawComment , rawExtraField , useWebWorkers , onprogress , signal , encryptionStrength , extendedTimestamp , msDosCompatible , internalFileAttribute , externalFileAttribute  } = options;
    const encrypted = Boolean(password && password.length);
    const compressed = level !== 0 && !directory;
    let rawExtraFieldAES;
    if (encrypted && !zipCrypto) {
        rawExtraFieldAES = new Uint8Array(EXTRAFIELD_DATA_AES.length + 2);
        const extraFieldAESView = getDataView1(rawExtraFieldAES);
        setUint16(extraFieldAESView, 0, 39169);
        arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
        setUint8(extraFieldAESView, 8, encryptionStrength);
    } else {
        rawExtraFieldAES = new Uint8Array(0);
    }
    let rawExtraFieldNTFS;
    let rawExtraFieldExtendedTimestamp;
    if (extendedTimestamp) {
        rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
        const extraFieldExtendedTimestampView = getDataView1(rawExtraFieldExtendedTimestamp);
        setUint16(extraFieldExtendedTimestampView, 0, 21589);
        setUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);
        const extraFieldExtendedTimestampFlag = 1 + (lastAccessDate ? 2 : 0) + (creationDate ? 4 : 0);
        setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
        setUint321(extraFieldExtendedTimestampView, 5, Math.floor(options.lastModDate.getTime() / 1000));
        if (lastAccessDate) {
            setUint321(extraFieldExtendedTimestampView, 9, Math.floor(lastAccessDate.getTime() / 1000));
        }
        if (creationDate) {
            setUint321(extraFieldExtendedTimestampView, 13, Math.floor(creationDate.getTime() / 1000));
        }
        try {
            rawExtraFieldNTFS = new Uint8Array(36);
            const extraFieldNTFSView = getDataView1(rawExtraFieldNTFS);
            const lastModTimeNTFS = getTimeNTFS(options.lastModDate);
            setUint16(extraFieldNTFSView, 0, 10);
            setUint16(extraFieldNTFSView, 2, 32);
            setUint16(extraFieldNTFSView, 8, 1);
            setUint16(extraFieldNTFSView, 10, 24);
            setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
        } catch (error) {
            rawExtraFieldNTFS = new Uint8Array(0);
        }
    } else {
        rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);
    }
    const fileEntry = {
        version: version || 20,
        versionMadeBy,
        zip64,
        directory: Boolean(directory),
        filenameUTF8: true,
        rawFilename,
        commentUTF8: true,
        rawComment,
        rawExtraFieldZip64: zip64 ? new Uint8Array(24 + 4) : new Uint8Array(0),
        rawExtraFieldExtendedTimestamp,
        rawExtraFieldNTFS,
        rawExtraFieldAES,
        rawExtraField,
        extendedTimestamp,
        msDosCompatible,
        internalFileAttribute,
        externalFileAttribute
    };
    let uncompressedSize = fileEntry.uncompressedSize = 0;
    let bitFlag = 2048;
    if (dataDescriptor) {
        bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;
    }
    let compressionMethod = 0;
    if (compressed) {
        compressionMethod = COMPRESSION_METHOD_DEFLATE;
    }
    if (zip64) {
        fileEntry.version = fileEntry.version > VERSION_ZIP64 ? fileEntry.version : VERSION_ZIP64;
    }
    if (encrypted) {
        bitFlag = bitFlag | BITFLAG_ENCRYPTED;
        if (!zipCrypto) {
            fileEntry.version = fileEntry.version > VERSION_AES ? fileEntry.version : VERSION_AES;
            compressionMethod = COMPRESSION_METHOD_AES;
            if (compressed) {
                fileEntry.rawExtraFieldAES[9] = COMPRESSION_METHOD_DEFLATE;
            }
        }
    }
    fileEntry.compressionMethod = compressionMethod;
    const headerArray = fileEntry.headerArray = new Uint8Array(26);
    const headerView = getDataView1(headerArray);
    setUint16(headerView, 0, fileEntry.version);
    setUint16(headerView, 2, bitFlag);
    setUint16(headerView, 4, compressionMethod);
    const dateArray = new Uint32Array(1);
    const dateView = getDataView1(dateArray);
    let lastModDate;
    if (options.lastModDate < MIN_DATE) {
        lastModDate = MIN_DATE;
    } else if (options.lastModDate > MAX_DATE) {
        lastModDate = MAX_DATE;
    } else {
        lastModDate = options.lastModDate;
    }
    setUint16(dateView, 0, (lastModDate.getHours() << 6 | lastModDate.getMinutes()) << 5 | lastModDate.getSeconds() / 2);
    setUint16(dateView, 2, (lastModDate.getFullYear() - 1980 << 4 | lastModDate.getMonth() + 1) << 5 | lastModDate.getDate());
    const rawLastModDate = dateArray[0];
    setUint321(headerView, 6, rawLastModDate);
    setUint16(headerView, 22, rawFilename.length);
    const extraFieldLength = rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + fileEntry.rawExtraField.length;
    setUint16(headerView, 24, extraFieldLength);
    const localHeaderArray = new Uint8Array(30 + rawFilename.length + extraFieldLength);
    const localHeaderView = getDataView1(localHeaderArray);
    setUint321(localHeaderView, 0, 67324752);
    arraySet(localHeaderArray, headerArray, 4);
    arraySet(localHeaderArray, rawFilename, 30);
    arraySet(localHeaderArray, rawExtraFieldAES, 30 + rawFilename.length);
    arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + rawFilename.length + rawExtraFieldAES.length);
    arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);
    arraySet(localHeaderArray, fileEntry.rawExtraField, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);
    let result;
    let compressedSize = 0;
    if (reader) {
        uncompressedSize = fileEntry.uncompressedSize = reader.size;
        const codec = await createCodec1(config.Deflate, {
            codecType: CODEC_DEFLATE,
            level,
            password,
            encryptionStrength,
            zipCrypto: encrypted && zipCrypto,
            passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & 255,
            signed: true,
            compressed,
            encrypted,
            useWebWorkers
        }, config);
        await writer.writeUint8Array(localHeaderArray);
        fileEntry.dataWritten = true;
        result = await processData(codec, reader, writer, 0, uncompressedSize, config, {
            onprogress,
            signal
        });
        compressedSize = result.length;
    } else {
        await writer.writeUint8Array(localHeaderArray);
        fileEntry.dataWritten = true;
    }
    let dataDescriptorArray = new Uint8Array(0);
    let dataDescriptorView, dataDescriptorOffset = 0;
    if (dataDescriptor) {
        dataDescriptorArray = new Uint8Array(zip64 ? dataDescriptorSignature ? 24 : 20 : dataDescriptorSignature ? 16 : 12);
        dataDescriptorView = getDataView1(dataDescriptorArray);
        if (dataDescriptorSignature) {
            dataDescriptorOffset = 4;
            setUint321(dataDescriptorView, 0, 134695760);
        }
    }
    if (reader) {
        const signature = result.signature;
        if ((!encrypted || zipCrypto) && signature !== undefined) {
            setUint321(headerView, 10, signature);
            fileEntry.signature = signature;
            if (dataDescriptor) {
                setUint321(dataDescriptorView, dataDescriptorOffset, signature);
            }
        }
        if (zip64) {
            const rawExtraFieldZip64View = getDataView1(fileEntry.rawExtraFieldZip64);
            setUint16(rawExtraFieldZip64View, 0, 1);
            setUint16(rawExtraFieldZip64View, 2, 24);
            setUint321(headerView, 14, 4294967295);
            setBigUint64(rawExtraFieldZip64View, 12, BigInt(compressedSize));
            setUint321(headerView, 18, 4294967295);
            setBigUint64(rawExtraFieldZip64View, 4, BigInt(uncompressedSize));
            if (dataDescriptor) {
                setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
                setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
            }
        } else {
            setUint321(headerView, 14, compressedSize);
            setUint321(headerView, 18, uncompressedSize);
            if (dataDescriptor) {
                setUint321(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
                setUint321(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
            }
        }
    }
    if (dataDescriptor) {
        await writer.writeUint8Array(dataDescriptorArray);
    }
    const length = localHeaderArray.length + compressedSize + dataDescriptorArray.length;
    Object.assign(fileEntry, {
        compressedSize,
        lastModDate,
        rawLastModDate,
        creationDate,
        lastAccessDate,
        encrypted,
        length
    });
    return fileEntry;
}
async function closeFile(zipWriter, comment, options) {
    const writer = zipWriter.writer;
    const files = zipWriter.files;
    let offset = 0;
    let directoryDataLength = 0;
    let directoryOffset = zipWriter.offset;
    let filesLength = files.size;
    for (const [, fileEntry] of files){
        directoryDataLength += 46 + fileEntry.rawFilename.length + fileEntry.rawComment.length + fileEntry.rawExtraFieldZip64.length + fileEntry.rawExtraFieldAES.length + fileEntry.rawExtraFieldExtendedTimestamp.length + fileEntry.rawExtraFieldNTFS.length + fileEntry.rawExtraField.length;
    }
    let zip64 = options.zip64 || zipWriter.options.zip64 || false;
    if (directoryOffset >= 4294967295 || directoryDataLength >= 4294967295 || filesLength >= 65535) {
        if (options.zip64 === false || zipWriter.options.zip64 === false) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    const directoryArray = new Uint8Array(directoryDataLength + (zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : 22));
    const directoryView = getDataView1(directoryArray);
    if (comment && comment.length) {
        if (comment.length <= 65535) {
            setUint16(directoryView, offset + 20, comment.length);
        } else {
            throw new Error(ERR_INVALID_COMMENT);
        }
    }
    for (const [indexFileEntry, fileEntry1] of Array.from(files.values()).entries()){
        const { rawFilename , rawExtraFieldZip64 , rawExtraFieldAES , rawExtraField , rawComment , versionMadeBy , headerArray , directory , zip64 , msDosCompatible , internalFileAttribute , externalFileAttribute  } = fileEntry1;
        let rawExtraFieldExtendedTimestamp;
        let rawExtraFieldNTFS;
        if (fileEntry1.extendedTimestamp) {
            rawExtraFieldNTFS = fileEntry1.rawExtraFieldNTFS;
            rawExtraFieldExtendedTimestamp = new Uint8Array(9);
            const extraFieldExtendedTimestampView = getDataView1(rawExtraFieldExtendedTimestamp);
            setUint16(extraFieldExtendedTimestampView, 0, 21589);
            setUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);
            setUint8(extraFieldExtendedTimestampView, 4, 1);
            setUint321(extraFieldExtendedTimestampView, 5, Math.floor(fileEntry1.lastModDate.getTime() / 1000));
        } else {
            rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);
        }
        const extraFieldLength = rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + rawExtraField.length;
        setUint321(directoryView, offset, 33639248);
        setUint16(directoryView, offset + 4, versionMadeBy);
        arraySet(directoryArray, headerArray, offset + 6);
        setUint16(directoryView, offset + 30, extraFieldLength);
        setUint16(directoryView, offset + 32, rawComment.length);
        setUint321(directoryView, offset + 34, internalFileAttribute);
        if (externalFileAttribute) {
            setUint321(directoryView, offset + 38, externalFileAttribute);
        } else if (directory && msDosCompatible) {
            setUint8(directoryView, offset + 38, 16);
        }
        if (zip64) {
            setUint321(directoryView, offset + 42, 4294967295);
        } else {
            setUint321(directoryView, offset + 42, fileEntry1.offset);
        }
        arraySet(directoryArray, rawFilename, offset + 46);
        arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + rawFilename.length);
        arraySet(directoryArray, rawExtraFieldAES, offset + 46 + rawFilename.length + rawExtraFieldZip64.length);
        arraySet(directoryArray, rawExtraFieldExtendedTimestamp, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length);
        arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);
        arraySet(directoryArray, rawExtraField, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);
        arraySet(directoryArray, rawComment, offset + 46 + rawFilename.length + extraFieldLength);
        offset += 46 + rawFilename.length + extraFieldLength + rawComment.length;
        if (options.onprogress) {
            try {
                options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry1));
            } catch (error) {
            }
        }
    }
    if (zip64) {
        setUint321(directoryView, offset, 101075792);
        setBigUint64(directoryView, offset + 4, BigInt(44));
        setUint16(directoryView, offset + 12, 45);
        setUint16(directoryView, offset + 14, 45);
        setBigUint64(directoryView, offset + 24, BigInt(filesLength));
        setBigUint64(directoryView, offset + 32, BigInt(filesLength));
        setBigUint64(directoryView, offset + 40, BigInt(directoryDataLength));
        setBigUint64(directoryView, offset + 48, BigInt(directoryOffset));
        setUint321(directoryView, offset + 56, 117853008);
        setBigUint64(directoryView, offset + 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
        setUint321(directoryView, offset + 72, 1);
        filesLength = MAX_16_BITS;
        directoryOffset = MAX_32_BITS;
        directoryDataLength = MAX_32_BITS;
        offset += 76;
    }
    setUint321(directoryView, offset, 101010256);
    setUint16(directoryView, offset + 8, filesLength);
    setUint16(directoryView, offset + 10, filesLength);
    setUint321(directoryView, offset + 12, directoryDataLength);
    setUint321(directoryView, offset + 16, directoryOffset);
    await writer.writeUint8Array(directoryArray);
    if (comment && comment.length) {
        await writer.writeUint8Array(comment);
    }
}
function sliceAsArrayBuffer(blob, start, end) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject)=>{
        fileReader.onload = (event)=>resolve(event.target.result)
        ;
        fileReader.onerror = ()=>reject(fileReader.error)
        ;
        fileReader.readAsArrayBuffer(start || end ? blob.slice(start, end) : blob);
    });
}
async function writeBlob(writer, blob, start = 0) {
    const blockSize = 512 * 1024 * 1024;
    await writeSlice();
    async function writeSlice() {
        if (start < blob.size) {
            const arrayBuffer = await sliceAsArrayBuffer(blob, start, start + blockSize);
            await writer.writeUint8Array(new Uint8Array(arrayBuffer));
            start += blockSize;
            await writeSlice();
        }
    }
}
function getTimeNTFS(date) {
    if (date) {
        return (BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000);
    }
}
function getOptionValue1(zipWriter, options, name) {
    return options[name] === undefined ? zipWriter.options[name] : options[name];
}
function getMaximumCompressedSize1(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
function setUint8(view, offset, value) {
    view.setUint8(offset, value);
}
function setUint16(view, offset, value) {
    view.setUint16(offset, value, true);
}
function setUint321(view, offset, value) {
    view.setUint32(offset, value, true);
}
function setBigUint64(view, offset, value) {
    view.setBigUint64(offset, value, true);
}
function arraySet(array, typedArray, offset) {
    array.set(typedArray, offset);
}
function getDataView1(array) {
    return new DataView(array.buffer);
}
const CHUNK_SIZE = 512 * 1024;
class ZipEntry1 {
    constructor(fs, name1, params, parent){
        const zipEntry = this;
        if (fs.root && parent && parent.getChildByName(name1)) {
            throw new Error("Entry filename already exists");
        }
        if (!params) {
            params = {
            };
        }
        Object.assign(zipEntry, {
            fs,
            name: name1,
            data: params.data,
            id: fs.entries.length,
            parent,
            children: [],
            uncompressedSize: 0
        });
        fs.entries.push(zipEntry);
        if (parent) {
            zipEntry.parent.children.push(zipEntry);
        }
    }
    moveTo(target) {
        const zipEntry = this;
        zipEntry.fs.move(zipEntry, target);
    }
    getFullname() {
        return this.getRelativeName();
    }
    getRelativeName(ancestor = this.fs.root) {
        const zipEntry = this;
        let relativeName = zipEntry.name;
        let entry = zipEntry.parent;
        while(entry && entry != ancestor){
            relativeName = (entry.name ? entry.name + "/" : "") + relativeName;
            entry = entry.parent;
        }
        return relativeName;
    }
    isDescendantOf(ancestor) {
        let entry = this.parent;
        while(entry && entry.id != ancestor.id){
            entry = entry.parent;
        }
        return Boolean(entry);
    }
}
class ZipFileEntry extends ZipEntry1 {
    constructor(fs1, name2, params1, parent1){
        super(fs1, name2, params1, parent1);
        const zipEntry1 = this;
        zipEntry1.Reader = params1.Reader;
        zipEntry1.Writer = params1.Writer;
        if (params1.getData) {
            zipEntry1.getData = params1.getData;
        }
    }
    async getData(writer, options = {
    }) {
        const zipEntry = this;
        if (!writer || writer.constructor == zipEntry.Writer && zipEntry.data) {
            return zipEntry.data;
        } else {
            zipEntry.reader = new zipEntry.Reader(zipEntry.data, options);
            await zipEntry.reader.init();
            if (!writer.initialized) {
                await writer.init();
            }
            zipEntry.uncompressedSize = zipEntry.reader.size;
            return pipe(zipEntry.reader, writer);
        }
    }
    getText(encoding, options) {
        return this.getData(new TextWriter(encoding), options);
    }
    getBlob(mimeType, options) {
        return this.getData(new BlobWriter(mimeType), options);
    }
    getData64URI(mimeType, options) {
        return this.getData(new Data64URIWriter(mimeType), options);
    }
    getUint8Array(options) {
        return this.getData(new Uint8ArrayWriter(), options);
    }
    replaceBlob(blob) {
        Object.assign(this, {
            data: blob,
            Reader: BlobReader,
            Writer: BlobWriter,
            reader: null
        });
    }
    replaceText(text) {
        Object.assign(this, {
            data: text,
            Reader: TextReader,
            Writer: TextWriter,
            reader: null
        });
    }
    replaceData64URI(dataURI) {
        Object.assign(this, {
            data: dataURI,
            Reader: Data64URIReader,
            Writer: Data64URIWriter,
            reader: null
        });
    }
    replaceUint8Array(array) {
        Object.assign(this, {
            data: array,
            Reader: Uint8ArrayReader,
            Writer: Uint8ArrayWriter,
            reader: null
        });
    }
}
class ZipDirectoryEntry extends ZipEntry1 {
    constructor(fs2, name3, params2, parent2){
        super(fs2, name3, params2, parent2);
        this.directory = true;
    }
    addDirectory(name) {
        return addChild(this, name, null, true);
    }
    addText(name, text) {
        return addChild(this, name, {
            data: text,
            Reader: TextReader,
            Writer: TextWriter
        });
    }
    addBlob(name, blob) {
        return addChild(this, name, {
            data: blob,
            Reader: BlobReader,
            Writer: BlobWriter
        });
    }
    addData64URI(name, dataURI) {
        return addChild(this, name, {
            data: dataURI,
            Reader: Data64URIReader,
            Writer: Data64URIWriter
        });
    }
    addUint8Array(name, array) {
        return addChild(this, name, {
            data: array,
            Reader: Uint8ArrayReader,
            Writer: Uint8ArrayWriter
        });
    }
    addHttpContent(name, url, options = {
    }) {
        return addChild(this, name, {
            data: url,
            Reader: class extends HttpReader {
                constructor(url4){
                    super(url4, options);
                }
            }
        });
    }
    async addFileSystemEntry(fileSystemEntry) {
        return addFileSystemEntry(this, fileSystemEntry);
    }
    async addData(name, params) {
        return addChild(this, name, params);
    }
    async importBlob(blob, options = {
    }) {
        await this.importZip(new BlobReader(blob), options);
    }
    async importData64URI(dataURI, options = {
    }) {
        await this.importZip(new Data64URIReader(dataURI), options);
    }
    async importUint8Array(array, options = {
    }) {
        await this.importZip(new Uint8ArrayReader(array), options);
    }
    async importHttpContent(url, options = {
    }) {
        await this.importZip(new HttpReader(url, options), options);
    }
    async exportBlob(options = {
    }) {
        return this.exportZip(new BlobWriter("application/zip"), options);
    }
    async exportData64URI(options = {
    }) {
        return this.exportZip(new Data64URIWriter("application/zip"), options);
    }
    async exportUint8Array(options = {
    }) {
        return this.exportZip(new Uint8ArrayWriter(), options);
    }
    async importZip(reader, options) {
        if (!reader.initialized) {
            await reader.init();
        }
        const zipReader = new ZipReader(reader, options);
        const entries = await zipReader.getEntries();
        entries.forEach((entry)=>{
            let parent = this;
            const path = entry.filename.split("/");
            const name = path.pop();
            path.forEach((pathPart)=>parent = parent.getChildByName(pathPart) || new ZipDirectoryEntry(this.fs, pathPart, null, parent)
            );
            if (!entry.directory) {
                addChild(parent, name, {
                    data: entry,
                    Reader: getZipBlobReader(Object.assign({
                    }, options))
                });
            }
        });
    }
    async exportZip(writer, options) {
        const zipEntry = this;
        await initReaders(zipEntry);
        await writer.init();
        const zipWriter = new ZipWriter(writer, options);
        await exportZip(zipWriter, zipEntry, getTotalSize([
            zipEntry
        ], "uncompressedSize"), options);
        await zipWriter.close();
        return writer.getData();
    }
    getChildByName(name) {
        const children = this.children;
        for(let childIndex = 0; childIndex < children.length; childIndex++){
            const child = children[childIndex];
            if (child.name == name) {
                return child;
            }
        }
    }
}
class FS {
    constructor(){
        resetFS(this);
    }
    get children() {
        return this.root.children;
    }
    remove(entry) {
        detach(entry);
        this.entries[entry.id] = null;
    }
    move(entry, destination) {
        if (entry == this.root) {
            throw new Error("Root directory cannot be moved");
        } else {
            if (destination.directory) {
                if (!destination.isDescendantOf(entry)) {
                    if (entry != destination) {
                        if (destination.getChildByName(entry.name)) {
                            throw new Error("Entry filename already exists");
                        }
                        detach(entry);
                        entry.parent = destination;
                        destination.children.push(entry);
                    }
                } else {
                    throw new Error("Entry is a ancestor of target entry");
                }
            } else {
                throw new Error("Target entry is not a directory");
            }
        }
    }
    find(fullname) {
        const path = fullname.split("/");
        let node = this.root;
        for(let index = 0; node && index < path.length; index++){
            node = node.getChildByName(path[index]);
        }
        return node;
    }
    getById(id) {
        return this.entries[id];
    }
    getChildByName(name) {
        return this.root.getChildByName(name);
    }
    addDirectory(name) {
        return this.root.addDirectory(name);
    }
    addText(name, text) {
        return this.root.addText(name, text);
    }
    addBlob(name, blob) {
        return this.root.addBlob(name, blob);
    }
    addData64URI(name, dataURI) {
        return this.root.addData64URI(name, dataURI);
    }
    addHttpContent(name, url, options) {
        return this.root.addHttpContent(name, url, options);
    }
    async addFileSystemEntry(fileSystemEntry) {
        return this.root.addFileSystemEntry(fileSystemEntry);
    }
    async addData(name, params) {
        return this.root.addData(name, params);
    }
    async importBlob(blob, options) {
        resetFS(this);
        await this.root.importBlob(blob, options);
    }
    async importData64URI(dataURI, options) {
        resetFS(this);
        await this.root.importData64URI(dataURI, options);
    }
    async importHttpContent(url, options) {
        resetFS(this);
        await this.root.importHttpContent(url, options);
    }
    async exportBlob(options) {
        return this.root.exportBlob(options);
    }
    async exportData64URI(options) {
        return this.root.exportData64URI(options);
    }
}
function getTotalSize(entries, propertyName) {
    let size = 0;
    entries.forEach(process);
    return size;
    function process(entry) {
        size += entry[propertyName];
        if (entry.children) {
            entry.children.forEach(process);
        }
    }
}
function getZipBlobReader(options) {
    return class extends Reader {
        constructor(entry, options16 = {
        }){
            super();
            this.entry = entry;
            this.options = options16;
        }
        async init() {
            const zipBlobReader = this;
            zipBlobReader.size = zipBlobReader.entry.uncompressedSize;
            const data = await zipBlobReader.entry.getData(new BlobWriter(), Object.assign({
            }, zipBlobReader.options, options));
            zipBlobReader.data = data;
            zipBlobReader.blobReader = new BlobReader(data);
        }
        async readUint8Array(index, length) {
            return this.blobReader.readUint8Array(index, length);
        }
    };
}
async function initReaders(entry) {
    if (entry.children.length) {
        for (const child of entry.children){
            if (child.directory) {
                await initReaders(child);
            } else {
                child.reader = new child.Reader(child.data);
                await child.reader.init();
                child.uncompressedSize = child.reader.size;
            }
        }
    }
}
function detach(entry) {
    const children = entry.parent.children;
    children.forEach((child, index)=>{
        if (child.id == entry.id) {
            children.splice(index, 1);
        }
    });
}
async function exportZip(zipWriter, entry, totalSize, options) {
    const selectedEntry = entry;
    const entryOffsets = new Map();
    await process(zipWriter, entry);
    async function process(zipWriter, entry) {
        await exportChild();
        async function exportChild() {
            if (options.bufferedWrite) {
                await Promise.all(entry.children.map(processChild));
            } else {
                for (const child of entry.children){
                    await processChild(child);
                }
            }
        }
        async function processChild(child) {
            const name = options.relativePath ? child.getRelativeName(selectedEntry) : child.getFullname();
            await zipWriter.add(name, child.reader, Object.assign({
                directory: child.directory
            }, Object.assign({
            }, options, {
                onprogress: (indexProgress)=>{
                    if (options.onprogress) {
                        entryOffsets.set(name, indexProgress);
                        try {
                            options.onprogress(Array.from(entryOffsets.values()).reduce((previousValue, currentValue)=>previousValue + currentValue
                            ), totalSize);
                        } catch (error) {
                        }
                    }
                }
            })));
            await process(zipWriter, child);
        }
    }
}
async function addFileSystemEntry(zipEntry, fileSystemEntry) {
    if (fileSystemEntry.isDirectory) {
        const entry = zipEntry.addDirectory(fileSystemEntry.name);
        await addDirectory(entry, fileSystemEntry);
        return entry;
    } else {
        return new Promise((resolve, reject)=>fileSystemEntry.file((file)=>resolve(zipEntry.addBlob(fileSystemEntry.name, file))
            , reject)
        );
    }
    async function addDirectory(zipEntry, fileEntry) {
        const children = await getChildren(fileEntry);
        for (const child of children){
            if (child.isDirectory) {
                await addDirectory(zipEntry.addDirectory(child.name), child);
            } else {
                await new Promise((resolve, reject)=>{
                    child.file((file)=>{
                        const childZipEntry = zipEntry.addBlob(child.name, file);
                        childZipEntry.uncompressedSize = file.size;
                        resolve(childZipEntry);
                    }, reject);
                });
            }
        }
    }
    function getChildren(fileEntry) {
        return new Promise((resolve, reject)=>{
            let entries = [];
            if (fileEntry.isDirectory) {
                readEntries(fileEntry.createReader());
            }
            if (fileEntry.isFile) {
                resolve(entries);
            }
            function readEntries(directoryReader) {
                directoryReader.readEntries((temporaryEntries)=>{
                    if (!temporaryEntries.length) {
                        resolve(entries);
                    } else {
                        entries = entries.concat(temporaryEntries);
                        readEntries(directoryReader);
                    }
                }, reject);
            }
        });
    }
}
function resetFS(fs) {
    fs.entries = [];
    fs.root = new ZipDirectoryEntry(fs);
}
async function pipe(reader, writer) {
    return copyChunk();
    async function copyChunk(chunkIndex = 0) {
        const index = chunkIndex * CHUNK_SIZE;
        if (index < reader.size) {
            const array = await reader.readUint8Array(index, Math.min(CHUNK_SIZE, reader.size - index));
            await writer.writeUint8Array(array);
            return copyChunk(chunkIndex + 1);
        } else {
            return writer.getData();
        }
    }
}
function addChild(parent, name, params, directory) {
    if (parent.directory) {
        return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new ZipFileEntry(parent.fs, name, params, parent);
    } else {
        throw new Error("Parent entry is not a directory");
    }
}
__default7();
configure({
    Deflate: ZipDeflate,
    Inflate: ZipInflate
});
async function ls(path) {
    const entries = [];
    for await (const entry of Deno.readDir(path)){
        entries.push(entry);
    }
    return entries.sort((e1, e2)=>e1.name.localeCompare(e2.name)
    );
}
async function fsToFolder(path, genSha1 = true) {
    const folder = {
        name: basename2(path),
        files: []
    };
    const entries = await ls(path);
    for (const entry of entries){
        if (entry.isDirectory) {
            folder.files.push(await fsToFolder(join2(path, entry.name), genSha1));
        } else {
            folder.files.push({
                name: entry.name,
                sha1: genSha1 ? await getSha1(join2(path, entry.name)) : ""
            });
        }
    }
    return folder;
}
async function getSha1(path) {
    const sha1Hash = createHash("sha1");
    const data = await Deno.readFile(path);
    sha1Hash.update(data);
    return sha1Hash.toString();
}
let ffmpegCommand = [];
async function checkCommand(cmd, exitCodeExpected) {
    try {
        const process = Deno.run({
            cmd,
            stdin: "null",
            stdout: "null",
            stderr: "null"
        });
        const status = await process.status();
        process.close();
        return status.code === exitCodeExpected;
    } catch (_e) {
        return false;
    }
}
async function getFfmpegCommand() {
    if (ffmpegCommand.length === 0) {
        if (Deno.build.os === "windows") {
            if (await checkCommand([
                "wsl",
                "ffmpeg",
                "-version"
            ], 0)) {
                ffmpegCommand = [
                    "wsl",
                    "ffmpeg"
                ];
            } else if (await checkCommand([
                "wsl2",
                "ffmpeg",
                "-version"
            ], 0)) {
                ffmpegCommand = [
                    "wsl2",
                    "ffmpeg"
                ];
            } else {
                console.error(`
Command ffmpeg not found,
use --skip-extract-image-from-mp3 to skip image item generation
or install ffmpeg :
       wsl  sudo apt install ffmpeg
    or wsl2 sudo apt install ffmpeg
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "ffmpeg",
                "-version"
            ], 0)) {
                ffmpegCommand = [
                    "ffmpeg"
                ];
            } else {
                console.error(`
Command ffmpeg (from ffmpeg) not found,
use --skip-image-item-gen to skip image item generation
or install ffmpeg : sudo apt install ffmpeg
`);
                Deno.exit(3);
            }
        }
    }
    return ffmpegCommand;
}
let pico2waveCommand = [];
async function getPico2waveCommand() {
    if (pico2waveCommand.length === 0) {
        if (Deno.build.os === "windows") {
            if (await checkCommand([
                "wsl",
                "pico2wave",
                "--version"
            ], 1)) {
                pico2waveCommand = [
                    "wsl",
                    "pico2wave"
                ];
            } else if (await checkCommand([
                "wsl2",
                "pico2wave",
                "--version"
            ], 1)) {
                pico2waveCommand = [
                    "wsl2",
                    "pico2wave"
                ];
            } else {
                console.error(`
Command pico2wave (from libttspico-utils) not found,
use --skip-audio-item-gen to skip audio item generation
or install pico2wave :
       wsl  sudo apt install libttspico-utils
    or wsl2 sudo apt install libttspico-utils
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "pico2wave",
                "--version"
            ], 1)) {
                pico2waveCommand = [
                    "pico2wave"
                ];
            } else {
                console.error(`
Command pico2wave (from libttspico-utils) not found,
use --skip-audio-item-gen to skip audio item generation
or install pico2wave : sudo apt install libttspico-utils
`);
                Deno.exit(3);
            }
        }
    }
    return pico2waveCommand;
}
let convertCommand = [];
async function getConvertCommand() {
    if (convertCommand.length === 0) {
        if (Deno.build.os === "windows") {
            if (await checkCommand([
                "wsl",
                "convert",
                "--version"
            ], 0)) {
                convertCommand = [
                    "wsl",
                    "convert"
                ];
            } else if (await checkCommand([
                "wsl2",
                "convert",
                "--version"
            ], 0)) {
                convertCommand = [
                    "wsl2",
                    "convert"
                ];
            } else {
                console.error(`
Command convert (from ImageMagick) not found,
use --skip-image-item-gen to skip image item generation
or install ImageMagick :
       wsl  sudo apt install imagemagick
    or wsl2 sudo apt install imagemagick
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "convert",
                "--version"
            ], 0)) {
                convertCommand = [
                    "convert"
                ];
            } else {
                console.error(`
Command convert (from ImageMagick) not found,
use --skip-image-item-gen to skip image item generation
or install ImageMagick : sudo apt install imagemagick
`);
                Deno.exit(3);
            }
        }
    }
    return convertCommand;
}
const extensionRegEx = /\.([^.]+)$/i;
const folderAudioItemRegEx = /^0-item\.(ogg|wav|mp3)$/i;
const folderImageItemRegEx = /^0-item\.(png|jpg|jpeg|bmp)$/i;
const fileAudioItemRegEx = /\.item\.(ogg|wav|mp3)$/i;
const fileImageItemRegEx = /\.item\.(png|jpg|jpeg|bmp)$/i;
const storyRegEx = /\.(ogg|wav|mp3)$/i;
const itemsRegEx = [
    folderAudioItemRegEx,
    folderImageItemRegEx,
    fileAudioItemRegEx,
    fileImageItemRegEx, 
];
function isFolder(f) {
    return !!f.files;
}
function isFile(f) {
    return !f.files;
}
function getNameWithoutExt(name) {
    return /(.*)\.[^.]+$/.test(name) ? /(.*)\.[^.]+$/.exec(name)[1] : name;
}
function getExtension(name) {
    return extensionRegEx.exec(name)?.[1] || "";
}
function getFolderAudioItem(folder) {
    const file = folder.files.find((f)=>folderAudioItemRegEx.test(f.name)
    );
    if (file) {
        return `${file.sha1}.${getExtension(file.name)}`;
    } else {
        return null;
    }
}
function getFolderImageItem(folder) {
    const file = folder.files.find((f)=>folderImageItemRegEx.test(f.name)
    );
    if (file) {
        return `${file.sha1}.${getExtension(file.name)}`;
    } else {
        return null;
    }
}
function getFileAudioItem(file, parent) {
    const nameWithoutExt = getNameWithoutExt(file.name);
    const audioItem = parent.files.find((f)=>f.name.startsWith(nameWithoutExt) && fileAudioItemRegEx.test(f.name)
    );
    if (audioItem) {
        return `${audioItem.sha1}.${getExtension(audioItem.name)}`;
    } else {
        return null;
    }
}
function getFileImageItem(file, parent) {
    const nameWithoutExt = getNameWithoutExt(file.name);
    const ImageItem = parent.files.find((f)=>f.name.startsWith(nameWithoutExt) && fileImageItemRegEx.test(f.name)
    );
    if (ImageItem) {
        return `${ImageItem.sha1}.${getExtension(ImageItem.name)}`;
    } else {
        return null;
    }
}
function getFileAudioStory(file) {
    return `${file.sha1}.${getExtension(file.name)}`;
}
function isStory(file) {
    return storyRegEx.test(file.name) && !itemsRegEx.some((regex)=>regex.test(file.name)
    );
}
function isAudioItem(file) {
    return fileAudioItemRegEx.test(file.name) || folderAudioItemRegEx.test(file.name);
}
function firstStoryFile(folder) {
    return folder.files.find((f)=>storyRegEx.test(f.name) && !itemsRegEx.some((regex)=>regex.test(f.name)
        )
    );
}
function convertPath(path) {
    return Deno.build.os === "windows" ? convWindowsWslPath(path) : path;
}
function convWindowsWslPath(path) {
    const groups = /(^.)(.*)$/.exec(path);
    return "/mnt/" + groups?.[1].toLowerCase() + groups?.[2].replace(/\\/g, "/").replace(/:/g, "");
}
function uniq(items) {
    return [
        ...new Set(items)
    ];
}
async function convertToImageItem(inputPath, outputPath) {
    console.log(bgBlue(`Try convert ${inputPath}  ${outputPath}`));
    const process = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            convertPath(inputPath),
            "-vf",
            "scale=320:240:force_original_aspect_ratio=decrease,pad='320:240:(ow-iw)/2:(oh-ih)/2'",
            convertPath(outputPath), 
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const status = await process.status();
    if (status.success) {
        console.log(bgGreen(" OK"));
    } else {
        const output = new TextDecoder().decode(await process.stderrOutput());
        console.log(bgRed(" KO : \n" + output));
    }
    process.close();
}
let runPermissionOk = false;
async function checkRunPermission() {
    if (!runPermissionOk) {
        if ((await Deno.permissions.query({
            name: "run"
        })).state !== "granted") {
            throw new Error(`Missing Deno run permission ! add "--allow-run"`);
        }
        runPermissionOk = true;
    }
}
async function extractImagesFromAudio(rootpath, folder) {
    await checkRunPermission();
    for (const file of folder.files){
        if (isFolder(file)) {
            await extractImagesFromAudio(join2(rootpath, file.name), file);
        } else {
            if (isStory(file)) {
                const imageItem = getFileImageItem(file, folder);
                if (!imageItem) {
                    const inputPath = join2(rootpath, file.name);
                    const outputPath = join2(rootpath, `${getNameWithoutExt(file.name)}.item.png`);
                    await convertToImageItem(inputPath, outputPath);
                }
            }
        }
    }
}
async function generateImage(title, outputPath) {
    console.log(bgGreen(`Generate image to ${outputPath}`));
    const process = await Deno.run({
        cmd: [
            ...await getConvertCommand(),
            "-background",
            "black",
            "-fill",
            "white",
            "-gravity",
            "center",
            "-size",
            "320x240",
            "-font",
            "Arial",
            `caption:${title}`,
            convertPath(outputPath), 
        ]
    });
    await process.status();
    process.close();
}
async function generateAudio(title, outputPath, lang) {
    console.log(bgBlue(`Generate audio to ${outputPath}`));
    const process = Deno.run({
        cmd: [
            ...await getPico2waveCommand(),
            "-l",
            lang,
            "-w",
            convertPath(outputPath),
            ` . ${title} . `, 
        ]
    });
    await process.status();
    process.close();
}
function getTitle(name) {
    if (/^[0-9]* *-? *$/.test(name)) {
        return name;
    } else {
        return /^[0-9]* *-? *(.*)$/.exec(name)?.[1].replace(/_/g, " ").trim();
    }
}
async function genMissingItems(rootpath, folder, genImage, genAudio, lang) {
    if (genImage || genAudio) {
        await checkRunPermission();
        if (genImage && !getFolderImageItem(folder)) {
            await generateImage(getTitle(folder.name), `${rootpath}/0-item.png`);
        }
        if (genAudio && !getFolderAudioItem(folder)) {
            await generateAudio(getTitle(folder.name), `${rootpath}/0-item.wav`, lang);
        }
        for (const file of folder.files){
            if (isFolder(file)) {
                await genMissingItems(join2(rootpath, file.name), file, genImage, genAudio, lang);
            } else if (isStory(file)) {
                if (genImage && !getFileImageItem(file, folder)) {
                    await generateImage(getTitle(getNameWithoutExt(file.name)), `${rootpath}/${getNameWithoutExt(file.name)}.item.png`);
                }
                if (genAudio && !getFileAudioItem(file, folder)) {
                    await generateAudio(getTitle(getNameWithoutExt(file.name)), `${rootpath}/${getNameWithoutExt(file.name)}.item.wav`, lang);
                }
            }
        }
    }
}
async function convertAudioOfFolder(rootpath, folder) {
    await checkRunPermission();
    for (const file of folder.files){
        if (isFolder(file)) {
            await convertAudioOfFolder(join2(rootpath, file.name), file);
        } else {
            if (isStory(file) || isAudioItem(file)) {
                const inputPath = join2(rootpath, file.name);
                const outPath = join2(rootpath, `${getNameWithoutExt(file.name)}.mp3`);
                const skipPath = `${outPath}__skip-convert`;
                if (!await exists(skipPath)) {
                    const maxDb = await getMaxVolumeOfFile(inputPath);
                    if (maxDb >= 1 || !await checkAudioFormat(inputPath)) {
                        await Deno.copyFile(inputPath, `${inputPath}.bak`);
                        const tmpPath = await Deno.makeTempFile({
                            dir: rootpath,
                            suffix: `.${getExtension(file.name)}`
                        });
                        await Deno.copyFile(inputPath, tmpPath);
                        await Deno.remove(inputPath);
                        await convertAudioFile(tmpPath, maxDb, outPath);
                        await Deno.remove(tmpPath);
                    } else {
                        console.log(bgGreen(" skip db<1"));
                    }
                    await Deno.writeTextFile(skipPath, "");
                }
            }
        }
    }
}
async function convertAudioFile(inputPath, maxDb, outputPath) {
    console.log(bgBlue(`Convert file ${inputPath}  ${outputPath}`));
    const process = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            convertPath(inputPath),
            "-af",
            `volume=${maxDb}dB,dynaudnorm`,
            "-ac",
            "1",
            "-ar",
            "44100",
            "-map_metadata",
            "-1",
            "-y",
            convertPath(outputPath), 
        ],
        stdout: "null",
        stdin: "null",
        stderr: "null"
    });
    const status = await process.status();
    process.close();
    if (status.success) {
        console.log(bgGreen(" OK"));
    } else {
        console.log(bgRed(" KO"));
    }
}
const maxVolumeRegex = /max_volume: -([0-9]+.[0-9]+) dB/;
async function getMaxVolumeOfFile(inputPath) {
    let maxDb = 0;
    console.log(bgBlue(`get max volume of file ${inputPath}`));
    const process = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            convertPath(inputPath),
            "-af",
            "volumedetect",
            "-vn",
            "-sn",
            "-dn",
            "-f",
            "null",
            "/dev/null", 
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const status = await process.status();
    const output = new TextDecoder().decode(await process.stderrOutput());
    process.close();
    if (status.success) {
        const maxVolLine = output.split("\\n").find((line)=>maxVolumeRegex.test(line)
        );
        if (maxVolLine) {
            maxDb = parseFloat(maxVolumeRegex.exec(maxVolLine)[1]);
        }
        console.log(bgGreen(` OK : ${maxDb} Db`));
    } else {
        console.log(bgRed(" KO"));
    }
    return maxDb;
}
async function checkAudioFormat(filePath) {
    const info = await getFfmpegInfo(filePath);
    const isOk = /^ *Stream #0:0: Audio: mp3, 44100 Hz, mono,.*$/m.test(info);
    console.log(bgBlue(`checkAudioFormat of ${filePath} : Format is ${isOk ? "OK" : "KO"}`));
    return isOk;
}
async function getFfmpegInfo(filePath) {
    console.log(bgBlue(`get info of file ${filePath}`));
    const process = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            convertPath(filePath),
            "-hide_banner",
            "-f",
            "null",
            "-", 
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const status = await process.status();
    const output = new TextDecoder().decode(await process.stderrOutput());
    process.close();
    let info = "";
    if (status.success) {
        info = output;
    }
    console.log(bgRed("info=" + info));
    return info;
}
function folderToPack(folder) {
    const firstSubFolder = folder.files.find((f)=>isFolder(f)
    );
    return {
        title: folder.name,
        description: "",
        format: "v1",
        version: 1,
        nightModeAvailable: false,
        entrypoint: {
            class: "StageNode-Entrypoint",
            name: "Cover node",
            image: getFolderImageItem(folder),
            audio: getFolderAudioItem(folder),
            okTransition: {
                class: "ActionNode",
                name: "Action node",
                options: [
                    firstSubFolder ? folderToMenu(firstSubFolder) : fileToStory(firstStoryFile(folder)), 
                ]
            }
        }
    };
}
function folderToMenu(folder) {
    return {
        class: "StageNode-Menu",
        image: getFolderImageItem(folder),
        audio: getFolderAudioItem(folder),
        name: folder.name,
        okTransition: {
            class: "ActionNode",
            name: folder.name + " ActionNode",
            options: folder.files.map((f)=>isFolder(f) ? folderToMenu(f) : !isStory(f) ? null : fileToStoryItem(f, folder)
            ).filter((f)=>f
            )
        }
    };
}
function fileToStoryItem(file, parent) {
    return {
        class: "StageNode-StoryItem",
        name: file.name + " item",
        audio: getFileAudioItem(file, parent),
        image: getFileImageItem(file, parent),
        okTransition: {
            name: file.name + " ActionNode",
            class: "ActionNode",
            options: [
                {
                    class: "StageNode-Story",
                    audio: getFileAudioStory(file),
                    image: null,
                    name: file.name + " Stage node",
                    okTransition: null
                }, 
            ]
        }
    };
}
function fileToStory(file) {
    return {
        class: "StageNode-Story",
        audio: `${file.sha1}.${getExtension(file.name)}`,
        image: null,
        name: file.name + " Stage node",
        okTransition: null
    };
}
function serializePack(pack) {
    const serialized = {
        title: pack.title,
        version: pack.version,
        description: pack.description,
        format: pack.format,
        nightModeAvailable: pack.nightModeAvailable,
        actionNodes: [],
        stageNodes: []
    };
    exploreStageNode(pack.entrypoint, serialized, undefined, []);
    serialized.actionNodes = serialized.actionNodes.reverse();
    serialized.stageNodes = serialized.stageNodes.reverse();
    return serialized;
}
function getControlSettings(stageNode, parent) {
    switch(stageNode.class){
        case "StageNode-Entrypoint":
            return {
                autoplay: true,
                home: true,
                ok: true,
                pause: false,
                wheel: true
            };
        case "StageNode-Menu":
            return {
                autoplay: !!parent?.options && parent?.options.length === 1,
                home: true,
                ok: true,
                pause: false,
                wheel: !!parent?.options && parent?.options.length > 1
            };
        case "StageNode-StoryItem":
            return {
                autoplay: false,
                home: true,
                ok: true,
                pause: false,
                wheel: true
            };
        case "StageNode-Story":
            return {
                autoplay: false,
                home: true,
                ok: false,
                pause: true,
                wheel: false
            };
    }
}
function exploreStageNode(stageNode, serialized, parent, actionHistory) {
    const uuid = crypto.randomUUID();
    const serializedStageNode = {
        audio: stageNode.audio,
        controlSettings: getControlSettings(stageNode, parent),
        homeTransition: actionHistory.length > 1 ? {
            actionNode: actionHistory[actionHistory.length - 2].id,
            optionIndex: actionHistory[actionHistory.length - 2].optionIndex
        } : null,
        image: stageNode.image,
        name: stageNode.name,
        okTransition: stageNode.okTransition ? {
            actionNode: exploreActionNode(stageNode.okTransition, serialized, actionHistory),
            optionIndex: 0
        } : null,
        position: {
            x: 0,
            y: 0
        },
        squareOne: stageNode.class === "StageNode-Entrypoint",
        type: stageNode.class === "StageNode-Entrypoint" ? "cover" : "stage",
        uuid
    };
    if (serializedStageNode.okTransition === null && stageNode.class === "StageNode-Story" && actionHistory.length > 1) {
        serializedStageNode.okTransition = {
            actionNode: actionHistory[actionHistory.length - 2].id,
            optionIndex: actionHistory[actionHistory.length - 2].optionIndex
        };
        serializedStageNode.controlSettings.autoplay = true;
    }
    serialized.stageNodes.push(serializedStageNode);
    return uuid;
}
function exploreActionNode(actionNode, serialized, actionHistory) {
    const id = crypto.randomUUID();
    const serializedActionNode = {
        id,
        name: actionNode.name,
        options: actionNode.options.map((stageNode, optionIndex)=>exploreStageNode(stageNode, serialized, actionNode, [
                ...actionHistory,
                {
                    id,
                    optionIndex
                }, 
            ])
        ),
        position: {
            x: 0,
            y: 0
        }
    };
    serialized.actionNodes.push(serializedActionNode);
    return id;
}
function getAssetsSha1s(serializedPack) {
    return [
        ...serializedPack.stageNodes.map((stageNode)=>stageNode.image
        ),
        ...serializedPack.stageNodes.map((stageNode)=>stageNode.audio
        ), 
    ].filter((sha)=>sha
    ).map((sha)=>sha
    ).map(getNameWithoutExt).sort();
}
function getSha1sMap(folder, path = "", map = {
}) {
    folder.files.forEach((f)=>{
        if (isFile(f)) {
            map[f.sha1] = join2(path, f.name);
        } else {
            getSha1sMap(f, join2(path, f.name), map);
        }
    });
    return map;
}
function getAssetsPaths(serializedPack, folder) {
    const sha1s = uniq(getAssetsSha1s(serializedPack));
    const map = getSha1sMap(folder);
    return sha1s.map((sha1)=>({
            sha1,
            path: map[sha1]
        })
    );
}
async function createPackZip(zipPath, storyPath, serializedPack, assets) {
    console.log(`create ${zipPath}`);
    const blobWriter = new BlobWriter("application/zip");
    const zipWriter = new ZipWriter(blobWriter, {
        useWebWorkers: false
    });
    const thumbnailPath = `${storyPath}/thumbnail.png`;
    if (await exists(thumbnailPath)) {
        await zipWriter.add("thumbnail.png", new BlobReader(new Blob([
            await Deno.readFile(thumbnailPath)
        ])));
    }
    await zipWriter.add("story.json", new BlobReader(new Blob([
        JSON.stringify(serializedPack, null, "  ")
    ])));
    for (const asset of assets){
        console.log(`add asset ${asset.path}`);
        await zipWriter.add(`assets/${asset.sha1}.${getExtension(asset.path)}`, new BlobReader(new Blob([
            await Deno.readFile(`${storyPath}/${asset.path}`)
        ])));
    }
    console.log(`write ${zipPath}`);
    const blob = await zipWriter.close();
    await Deno.writeFile(zipPath, new Buffer(await blob.arrayBuffer()).bytes());
}
async function getFolderWithUrlFromRssUrl(url) {
    console.log(bgGreen(` url = ${url}`));
    const resp = await fetch(url);
    const xml = await resp.text();
    const rss = parse3(xml).rss.channel;
    const imgUrl = rss.image?.url || rss.itunes?.image?.["@href"] || "";
    const fs = {
        name: rss.title,
        files: [
            {
                name: `0-item-to-resize.${getExtension(imgUrl)}`,
                url: imgUrl,
                sha1: ""
            }, 
        ]
    };
    const items = rss.item.sort((a, b)=>new Date(a.pubDate).getTime() - new Date(b.pubDate).getTime()
    );
    console.log(bgBlue(` ${items.length} items`));
    if (rss.item.length <= 10) {
        fs.files.push(getFolderOfStories(items));
    } else {
        fs.files.push(getFolderParts(items));
    }
    return fs;
}
function getItemFileName(item) {
    const title = item.title.replace(/[\/"]/g, " ");
    return new Date(item.pubDate).getTime() + ` - ${title}.${getExtension(item.enclosure["@url"])}`;
}
function getFolderOfStories(items) {
    return {
        name: __default2.t("storyQuestion"),
        files: items.map((item)=>({
                name: getItemFileName(item),
                url: item.enclosure["@url"],
                sha1: ""
            })
        )
    };
}
function getFolderParts(items) {
    const partCount = Math.ceil(items.length / 10);
    const parts = [];
    for(let i = 0; i < partCount; i++){
        const partSize = Math.floor(items.length / (partCount - i));
        const part = [];
        part.push(...items.splice(0, partSize));
        parts.push(part);
    }
    return {
        name: __default2.t("partQuestion"),
        files: parts.map((part, index)=>({
                name: `${__default2.t("partTitle")} ${index + 1}`,
                files: [
                    getFolderOfStories(part)
                ]
            })
        )
    };
}
async function writeFolderWithUrl(folder, parentPath) {
    const path = join2(parentPath, folder.name);
    await Deno.mkdir(path, {
        recursive: true
    });
    for (const file of folder.files){
        isFolder(file) ? await writeFolderWithUrl(file, path) : await writeFileWithUrl(file, path);
    }
}
async function writeFileWithUrl(fileWithUrl, parentPath) {
    const filePath = join2(parentPath, fileWithUrl.name);
    console.log(bgBlue(`Download ${fileWithUrl.url}\n     ${filePath}`));
    if (await exists(filePath)) {
        console.log(bgGreen(`    skip`));
    } else {
        const resp = await fetch(fileWithUrl.url);
        const streamReader = resp.body?.getReader();
        if (streamReader) {
            const reader = readerFromStreamReader(streamReader);
            const file = await Deno.open(filePath, {
                create: true,
                write: true
            });
            await copy1(reader, file);
            file.close();
        }
    }
}
async function downloadRss(url, parentPath) {
    const fs = await getFolderWithUrlFromRssUrl(url);
    await writeFolderWithUrl(fs, parentPath);
    const storyPath = join2(parentPath, fs.name);
    const itemToResize = fs.files.find((f)=>isFile(f) && f.name.startsWith("0-item-to-resize")
    );
    const itemToResizePath = join2(storyPath, itemToResize.name);
    await convertToImageItem(itemToResizePath, join2(storyPath, "0-item.png"));
    await Deno.remove(itemToResizePath);
    return storyPath;
}
const en = {
    partQuestion: "Choisis your part",
    partTitle: "Part",
    storyQuestion: "Choose your story"
};
const fr = {
    partQuestion: "Choisis ta partie",
    partTitle: "Partie",
    storyQuestion: "Choisis ton histoire"
};
async function initI18n(lng) {
    await __default2.init({
        lng,
        fallbackLng: "en-US",
        resources: {
            "en-US": {
                translation: en
            },
            "fr-FR": {
                translation: fr
            }
        }
    }, undefined);
}
async function getLang() {
    let LANG;
    if ((await Deno.permissions.query({
        name: "env"
    })).state === "granted") {
        LANG = Deno.env.get("LANG");
    } else {
        console.error(yellow(`Missing Deno env permission ! add "--allow-env" to permit lang detection`));
    }
    let lang;
    const langRegex = /^([a-zA-Z_]+)\./;
    if (LANG && langRegex.test(LANG)) {
        lang = langRegex.exec(LANG)[1].replace(/_/g, "-");
    }
    return lang || "en-US";
}
async function genThumbnail(folder, storyPath) {
    await checkRunPermission();
    const thumbnailPath = join2(storyPath, "thumbnail.png");
    if (!await exists(thumbnailPath)) {
        const itemFile = folder.files.find((f)=>folderImageItemRegEx.test(f.name)
        );
        if (itemFile) {
            await convertToImageItem(join2(storyPath, itemFile.name), thumbnailPath);
        }
    }
}
async function generatePack(opt) {
    const start = Date.now();
    console.log({
        opt
    });
    const lang = opt.lang || await getLang();
    await initI18n(lang);
    if (opt.storyPath.startsWith("http")) {
        opt.storyPath = await downloadRss(opt.storyPath, ".");
        console.log(`downloaded in ${opt.storyPath}`);
    }
    if (!opt.skipNotRss) {
        let folder = await fsToFolder(opt.storyPath, false);
        if (!opt.skipExtractImageFromMp3) {
            await extractImagesFromAudio(opt.storyPath, folder);
            folder = await fsToFolder(opt.storyPath, false);
        }
        if (!opt.skipImageItemGen || !opt.skipAudioItemGen) {
            await genMissingItems(opt.storyPath, folder, !opt.skipImageItemGen, !opt.skipAudioItemGen, lang);
            folder = await fsToFolder(opt.storyPath, false);
        }
        if (!opt.skipAudioConvert) {
            await convertAudioOfFolder(opt.storyPath, folder);
        }
        if (!opt.skipImageItemGen) {
            await genThumbnail(folder, opt.storyPath);
        }
        if (!opt.skipZipGeneration) {
            folder = await fsToFolder(opt.storyPath, true);
            const pack = folderToPack(folder);
            const serializedPack = serializePack(pack);
            const assets = getAssetsPaths(serializedPack, folder);
            const zipPath = `${opt.storyPath}-${Date.now()}.zip`;
            await createPackZip(zipPath, opt.storyPath, serializedPack, assets);
            console.log(`Done (${(Date.now() - start) / 1000} sec) :  ${opt.storyPath}  ${zipPath}`);
        }
    }
}
function parseArgs(args) {
    Yargs(args).command("$0 [options] <story-path>", "convert a folder to Studio pack zip", (y)=>{
        let width = y.terminalWidth();
        if (Deno.consoleSize) {
            width = Math.min(120, Deno.consoleSize(Deno.stdout.rid).columns);
        }
        return y.wrap(width);
    }, generatePack).usage("deno run -A studio_pack_generator.ts [options] <story path | RSS URL>    convert a folder or RSS url to Studio pack").option("lang", {
        alias: "l",
        demandOption: false,
        boolean: false,
        type: "string",
        describe: "the lang used to generate menu and items. Auto detected by default"
    }).option("skip-image-item-gen", {
        alias: "i",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip image item generation"
    }).option("skip-audio-item-gen", {
        alias: "a",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip audio item generation"
    }).option("skip-audio-convert", {
        alias: "v",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip convert audio (and skip increase volume)"
    }).option("skip-extract-image-from-mp3", {
        alias: "m",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip extract item image from story mp3"
    }).option("skip-zip-generation", {
        alias: "z",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "only process item generation, don't create zip"
    }).option("skip-not-rss", {
        alias: "s",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip all except download RSS files"
    }).version(false).demandCommand(1).parse();
}
const importMeta2 = {
    url: "file://./studio_pack_generator.ts",
    main: import.meta.main
};
if (importMeta2.main) {
    parseArgs(Deno.args);
}
