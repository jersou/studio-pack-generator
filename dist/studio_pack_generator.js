#!/usr/bin/env -S deno run -A
// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function yellow(str) {
    return run(str, code([
        33
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
function bgBlue(str) {
    return run(str, code([
        44
    ], 49));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
async function exists(filePath) {
    try {
        await Deno.lstat(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
let wasm;
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0;
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
let heap_next = heap.length;
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr1 = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr1 + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr1 = realloc(ptr1, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr1 + offset, ptr1 + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr1;
}
let cachedInt32Memory0;
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getObject(idx) {
    return heap[idx];
}
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function create_hash(algorithm) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.create_hash(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return DenoHash.__wrap(r0);
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
function update_hash(hash, data) {
    _assertClass(hash, DenoHash);
    const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.update_hash(hash.ptr, ptr0, len0);
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest_hash(hash) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(hash, DenoHash);
        wasm.digest_hash(retptr, hash.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v0 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v0;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DenoHashFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_denohash_free(ptr));
class DenoHash {
    static __wrap(ptr) {
        const obj = Object.create(DenoHash.prototype);
        obj.ptr = ptr;
        DenoHashFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DenoHashFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_denohash_free(ptr);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbindgen_string_new: function(arg0, arg1) {
            const ret = getStringFromWasm0(arg0, arg1);
            return addHeapObject(ret);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                create_hash,
                update_hash,
                digest_hash,
                DenoHash
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAAB+4CAgAASYAAAYAF/AGABfwF/YAF/AX5gAn9/AGACf38Bf2ADf39/AGADf39/AX9gBH\
9/f38AYAR/f39/AX9gBX9/f39/AGAFf39/f38Bf2AGf39/f39/AGAGf39/f39/AX9gBX9/f35/AGAH\
f39/fn9/fwF/YAJ/fgBgAn5/AX8C3oCAgAACGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxVfX3diaW\
5kZ2VuX3N0cmluZ19uZXcABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18QX193YmluZGdlbl90aHJv\
dwAEA9CBgIAAzgEGBgQEBgYCBA4GBAQPAQQEBAEHBQQQBAQEBAcLBAQEBA0EBAQEBAQEBAQEBAQEBA\
QBBQQEBAQEBAQEBwUEBAQGBgYGBAQEDAQEEQEFBAQEBAEEBgYGBgYGBAQEBAQEBAYEBAQEBAYGBAQE\
BAQEBAQEBgQEBAQEBgQEBAQEBAQEBAoFBQEBBAQEBAQGBgYGBQYBAAUIBAcHAQYJAQYBAQcBAgEBAQ\
QBBwEBBwEFBQIFBQQABQEBAQECAAAFBAMCAgICAgICAgICAgICAgAEAQSFgICAAAFwAXl5BYOAgIAA\
AQARBomAgIAAAX8BQYCAwAALB66BgIAACQZtZW1vcnkCABNfX3diZ19kZW5vaGFzaF9mcmVlAJkBC2\
NyZWF0ZV9oYXNoAAYLdXBkYXRlX2hhc2gAmgELZGlnZXN0X2hhc2gAlgEfX193YmluZGdlbl9hZGRf\
dG9fc3RhY2tfcG9pbnRlcgC5ARFfX3diaW5kZ2VuX21hbGxvYwCiARJfX3diaW5kZ2VuX3JlYWxsb2\
MAqwEPX193YmluZGdlbl9mcmVlALIBCauBgIAAAQBBAQt4sQHOAbQBsAG8AZABzwFhGGZSyAE7V1tu\
qQHDAXdWWm12WD9dpQHGAW9ZIDCcAccBU2g+XKQBcGcxR54ByQFzLjSfAcoBdFQZJoUBywFjGiuGAc\
wBYkRJRrYBwQF7Qjk2tQHAAYABQygktwG/AYEBQSwpuAHCAXxKRX46N3onJX0tKn+sAQsjOJIBxQEf\
VTVRowHEAXWXAT2UAa4BgwGEAb4BrQFNCsuvh4AAzgGRWgIBfyJ+IwBBgAFrIgMkACADQQBBgAEQqA\
EhAyAAKQM4IQQgACkDMCEFIAApAyghBiAAKQMgIQcgACkDGCEIIAApAxAhCSAAKQMIIQogACkDACEL\
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\
ICIgJWoiGyACICFzcSAhc2ogG0EadyAbQRV3cyAbQQd3c2pB8vHFs3xqIh5qIQsgHCAKaiEKICMgCW\
ohCSAgIAhqIQggHSAHaiAeaiEHIBsgBmohBiACIAVqIQUgISAEaiEEIAFBwABqIgEgDEcNAAsLIAAg\
BDYCHCAAIAU2AhggACAGNgIUIAAgBzYCECAAIAg2AgwgACAJNgIIIAAgCjYCBCAAIAs2AgALii4BIn\
8jAEHAAGsiAkEYaiIDQgA3AwAgAkEgaiIEQgA3AwAgAkE4aiIFQgA3AwAgAkEwaiIGQgA3AwAgAkEo\
aiIHQgA3AwAgAkEIaiIIIAEpAAg3AwAgAkEQaiIJIAEpABA3AwAgAyABKAAYIgo2AgAgBCABKAAgIg\
M2AgAgAiABKQAANwMAIAIgASgAHCIENgIcIAIgASgAJCILNgIkIAcgASgAKCIMNgIAIAIgASgALCIH\
NgIsIAYgASgAMCINNgIAIAIgASgANCIGNgI0IAUgASgAOCIONgIAIAIgASgAPCIBNgI8IAAgDiADIA\
EgCyACKAIAIgUgCSgCACIJIAUgByACKAIMIg8gAigCBCIQIAEgBSABIAwgAigCFCICIAUgACgCCCIR\
IAAoAgQiEnMgACgCDCITcyAAKAIAIhRqakELdyAAKAIQIhVqIhZBCnciF2ogDyARQQp3IhFqIBAgFW\
ogESAScyAWc2pBDncgE2oiFSAXcyAIKAIAIgggE2ogFiASQQp3IhJzIBVzakEPdyARaiITc2pBDHcg\
EmoiFiATQQp3IhFzIAkgEmogEyAVQQp3IhJzIBZzakEFdyAXaiITc2pBCHcgEmoiF0EKdyIVaiADIB\
ZBCnciFmogCiASaiATIBZzIBdzakEHdyARaiISIBVzIAQgEWogFyATQQp3IhNzIBJzakEJdyAWaiIW\
c2pBC3cgE2oiFyAWQQp3IhFzIAsgE2ogFiASQQp3IhJzIBdzakENdyAVaiITc2pBDncgEmoiFkEKdy\
IVaiAGIBdBCnciF2ogEiAHaiATIBdzIBZzakEPdyARaiISIBVzIBEgDWogFiATQQp3IhNzIBJzakEG\
dyAXaiIWc2pBB3cgE2oiESAWQQp3IhhzIBMgDmogFiASQQp3IhlzIBFzakEJdyAVaiIVc2pBCHcgGW\
oiF0EKdyISaiAPIAwgBiAFIAAoAhwiGkEKdyITaiAEIAAoAiAiFmogDiAAKAIkIhtqIAIgACgCFGog\
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\
IBJBCnciISAEICJqIB8gGkF/c3FqIBogEnFqQenttdMHakEFdyAeaiIUQX9zcWogFCAacWpB6e210w\
dqQQ93IB9qIhJBf3NxaiASIBRxakHp7bXTB2pBCHcgIWoiGiASQQp3Ih5zICEgDWogEiAUQQp3Ig1z\
IBpzakEIdyAXaiIUc2pBBXcgDWoiEkEKdyIXaiAaQQp3IgMgD2ogDSAMaiAUIANzIBJzakEMdyAeai\
IMIBdzIB4gCWogEiAUQQp3Ig1zIAxzakEJdyADaiIDc2pBDHcgDWoiDyADQQp3IglzIA0gBWogAyAM\
QQp3IgxzIA9zakEFdyAXaiIDc2pBDncgDGoiDUEKdyIFaiAPQQp3Ig4gCGogDCAEaiADIA5zIA1zak\
EGdyAJaiIEIAVzIAkgCmogDSADQQp3IgNzIARzakEIdyAOaiIMc2pBDXcgA2oiDSAMQQp3Ig5zIAMg\
BmogDCAEQQp3IgNzIA1zakEGdyAFaiIEc2pBBXcgA2oiDEEKdyIFajYCCCAAIBEgCiAbaiAdIBwgGU\
EKdyIKQX9zcnNqQc76z8p6akEIdyAYaiIPQQp3aiADIBZqIAQgDUEKdyIDcyAMc2pBD3cgDmoiDUEK\
dyIWajYCBCAAIBMgASAYaiAPIB0gHEEKdyIBQX9zcnNqQc76z8p6akEFdyAKaiIJaiAOIAJqIAwgBE\
EKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgACABIBVqIAYgCmogCSAPICBBf3Nyc2pBzvrPynpqQQZ3\
aiADIAtqIA0gBXMgBHNqQQt3IAJqIgpqNgIQIAAgASAQaiAFaiACIAdqIAQgFnMgCnNqQQt3ajYCDA\
uBOQIIfwR+IwBB4ANrIgMkACADIAI2AgwgAyABNgIIAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBfWoOBwAIBwIJAw\
EJCwJAAkAgAUGAgMAAQQMQmAFFDQAgAUGogMAAQQMQmAFFDQEgAUHQgMAAQQMQmAENCiADQbABakEM\
akIANwIAIANBsAFqQRRqQgA3AgAgA0GwAWpBHGpCADcCACADQbABakEkakIANwIAIANBsAFqQSxqQg\
A3AgAgA0GwAWpBNGpCADcCACADQbABakE8akIANwIAIANCADcCtAEgA0HAADYCsAEgA0HIAmogA0Gw\
AWpBxAAQoAEaIANB2ABqIgQgA0HIAmpBPGopAgA3AwAgA0HQAGoiBSADQcgCakE0aikCADcDACADQc\
gAaiIGIANByAJqQSxqKQIANwMAIANBwABqIgcgA0HIAmpBJGopAgA3AwAgA0E4aiIIIANByAJqQRxq\
KQIANwMAIANBMGoiCSADQcgCakEUaikCADcDACADQSBqQQhqIgogA0HIAmpBDGopAgA3AwAgAyADKQ\
LMAjcDIEHgABAIIgJFDQ0gAkEANgIIIAJCADcDACACIAMpAyA3AgwgAkEUaiAKKQMANwIAIAJBHGog\
CSkDADcCACACQSRqIAgpAwA3AgAgAkEsaiAHKQMANwIAIAJBNGogBikDADcCACACQTxqIAUpAwA3Ag\
AgAkHEAGogBCkDADcCACACQdQAakEAKQKwnEA3AgAgAkEAKQKonEA3AkxB1IDAACEEDCELIANBsAFq\
QQxqIgJCADcCACADQgA3ArQBIANBEDYCsAEgA0HIAmpBEGoiBSADQbABakEQaiIGKAIANgIAIANByA\
JqQQhqIgQgA0GwAWpBCGoiBykDADcDACADQSBqQQhqIgggA0HIAmpBDGoiCSkCADcDACADIAMpA7AB\
NwPIAiADIAMpAswCNwMgIAJCADcCACADQgA3ArQBIANBEDYCsAEgBSAGKAIANgIAIAQgBykDADcDAC\
ADIAMpA7ABNwPIAiADQRBqQQhqIgUgCSkCADcDACADIAMpAswCNwMQIAQgCCkDADcDACADIAMpAyA3\
A8gCQdQAEAgiAkUNCiACQQA2AgAgAiADKQPIAjcCBCACQgA3AhQgAiADKQMQNwJEIAJBHGpCADcCAC\
ACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkEMaiAEKQMANwIAIAJBzABq\
IAUpAwA3AgBBhIDAACEEDCALIANBsAFqQQxqQgA3AgAgA0GwAWpBFGpCADcCACADQbABakEcakIANw\
IAIANBsAFqQSRqQgA3AgAgA0GwAWpBLGpCADcCACADQbABakE0akIANwIAIANBsAFqQTxqQgA3AgAg\
A0IANwK0ASADQcAANgKwASADQcgCaiADQbABakHEABCgARogA0HYAGoiBCADQcgCakE8aikCADcDAC\
ADQdAAaiIFIANByAJqQTRqKQIANwMAIANByABqIgYgA0HIAmpBLGopAgA3AwAgA0HAAGoiByADQcgC\
akEkaikCADcDACADQThqIgggA0HIAmpBHGopAgA3AwAgA0EwaiIJIANByAJqQRRqKQIANwMAIANBIG\
pBCGoiCiADQcgCakEMaikCADcDACADIAMpAswCNwMgQeAAEAgiAkUNCiACQQA2AgggAkIANwMAIAIg\
AykDIDcCDCACQRRqIAopAwA3AgAgAkEcaiAJKQMANwIAIAJBJGogCCkDADcCACACQSxqIAcpAwA3Ag\
AgAkE0aiAGKQMANwIAIAJBPGogBSkDADcCACACQcQAaiAEKQMANwIAIAJB1ABqQQApArCcQDcCACAC\
QQApAqicQDcCTEGsgMAAIQQMHwsCQAJAIAFB+IDAAEEJEJgBRQ0AIAFBqIHAAEEJEJgBRQ0BIAFBvI\
TAACACEJgBRQ0EIAFB7ITAACACEJgBRQ0FIAFBnIXAACACEJgBRQ0GIAFBzIXAACACEJgBDQkgA0EA\
NgKwASADQbABakEEckEAQcgAEKgBGiADQcgANgKwASADQcgCaiADQbABakHMABCgARogA0EgaiADQc\
gCakEEckHIABCgARpBmAIQCCICRQ0aIAJBAEHMARCoAUHMAWogA0EgakHIABCgARpB2IXAACEEDCAL\
IANBsAFqQQxqQgA3AgAgA0GwAWpBFGpCADcCACADQbABakEcakIANwIAIANBsAFqQSRqQgA3AgAgA0\
GwAWpBLGpCADcCACADQbABakE0akIANwIAIANBsAFqQTxqQgA3AgAgA0IANwK0ASADQcAANgKwASAD\
QcgCaiADQbABakHEABCgARogA0EgakE4aiIEIANByAJqQTxqKQIANwMAIANBIGpBMGoiBSADQcgCak\
E0aikCADcDACADQSBqQShqIgYgA0HIAmpBLGopAgA3AwAgA0HAAGoiByADQcgCakEkaikCADcDACAD\
QSBqQRhqIgggA0HIAmpBHGopAgA3AwAgA0EgakEQaiIJIANByAJqQRRqKQIANwMAIANBIGpBCGoiCi\
ADQcgCakEMaikCADcDACADIAMpAswCNwMgQeAAEAgiAkUNDCACQgA3AwAgAkEANgIcIAIgAykDIDcC\
ICACQQApA+CcQDcDCCACQRBqQQApA+icQDcDACACQRhqQQAoAvCcQDYCACACQShqIAopAwA3AgAgAk\
EwaiAJKQMANwIAIAJBOGogCCkDADcCACACQcAAaiAHKQMANwIAIAJByABqIAYpAwA3AgAgAkHQAGog\
BSkDADcCACACQdgAaiAEKQMANwIAQYSBwAAhBAwfCyADQbABakEMakIANwIAIANBsAFqQRRqQgA3Ag\
AgA0GwAWpBHGpCADcCACADQbABakEkakIANwIAIANBsAFqQSxqQgA3AgAgA0GwAWpBNGpCADcCACAD\
QbABakE8akIANwIAIANCADcCtAEgA0HAADYCsAEgA0HIAmogA0GwAWpBxAAQoAEaIANB2ABqIgQgA0\
HIAmpBPGopAgA3AwAgA0HQAGoiBSADQcgCakE0aikCADcDACADQSBqQShqIgYgA0HIAmpBLGopAgA3\
AwAgA0EgakEgaiIHIANByAJqQSRqKQIANwMAIANBIGpBGGoiCCADQcgCakEcaikCADcDACADQSBqQR\
BqIgkgA0HIAmpBFGopAgA3AwAgA0EgakEIaiIKIANByAJqQQxqKQIANwMAIAMgAykCzAI3AyBB+AAQ\
CCICRQ0MIAJCADcDACACQQA2AjAgAiADKQMgNwI0IAJBACkDuJxANwMIIAJBEGpBACkDwJxANwMAIA\
JBGGpBACkDyJxANwMAIAJBIGpBACkD0JxANwMAIAJBKGpBACkD2JxANwMAIAJBPGogCikDADcCACAC\
QcQAaiAJKQMANwIAIAJBzABqIAgpAwA3AgAgAkHUAGogBykDADcCACACQdwAaiAGKQMANwIAIAJB5A\
BqIAUpAwA3AgAgAkHsAGogBCkDADcCAEG0gcAAIQQMHgsCQAJAAkACQCABQfyBwABBBhCYAUUNACAB\
QaiCwABBBhCYAUUNASABQdSCwABBBhCYAUUNAiABQYCDwABBBhCYAUUNAyABQfyFwABBBhCYAQ0KIA\
NB5QJqIgRBACkDsJ1AIgs3AAAgA0HdAmpBACkDqJ1AIgw3AAAgA0HVAmpBACkDoJ1AIg03AAAgA0EA\
KQOYnUAiDjcAzQJB+A4QCCICRQ0cIAJCADcDACACIA43AwggAkEQaiANNwMAIAJBGGogDDcDACACQS\
BqIAs3AwAgAkEoakEAQcMAEKgBGiACQQA6APAOIAJBiAFqIAQpAAA3AAAgAkGDAWogA0HIAmpBGGop\
AAA3AAAgAkH7AGogA0HIAmpBEGopAAA3AAAgAkHzAGogA0HQAmopAAA3AAAgAiADKQDIAjcAa0GEhs\
AAIQQMIQsgA0GwAWpBDGpCADcCACADQbABakEUakIANwIAIANBsAFqQRxqQgA3AgAgA0GwAWpBJGpC\
ADcCACADQbABakEsakIANwIAIANBsAFqQTRqQgA3AgAgA0GwAWpBPGpCADcCACADQgA3ArQBIANBwA\
A2ArABIANByAJqIANBsAFqQcQAEKABGiADQdgAaiIEIANByAJqQTxqKQIANwMAIANB0ABqIgUgA0HI\
AmpBNGopAgA3AwAgA0HIAGoiBiADQcgCakEsaikCADcDACADQcAAaiIHIANByAJqQSRqKQIANwMAIA\
NBOGoiCCADQcgCakEcaikCADcDACADQTBqIgkgA0HIAmpBFGopAgA3AwAgA0EgakEIaiIKIANByAJq\
QQxqKQIANwMAIAMgAykCzAI3AyBB8AAQCCICRQ0PIAIgAykDIDcCDCACQQA2AgggAkIANwMAIAJBHG\
ogCSkDADcCACACQRRqIAopAwA3AgAgAkEkaiAIKQMANwIAIAJBLGogBykDADcCACACQTRqIAYpAwA3\
AgAgAkE8aiAFKQMANwIAIAJBxABqIAQpAwA3AgAgAkHUAGpBACkC/JxANwIAIAJBACkC9JxANwJMIA\
JB5ABqQQApAoydQDcCACACQdwAakEAKQKEnUA3AgBBhILAACEEDCALIANBsAFqQQxqQgA3AgAgA0Gw\
AWpBFGpCADcCACADQbABakEcakIANwIAIANBsAFqQSRqQgA3AgAgA0GwAWpBLGpCADcCACADQbABak\
E0akIANwIAIANBsAFqQTxqQgA3AgAgA0IANwK0ASADQcAANgKwASADQcgCaiADQbABakHEABCgARog\
A0HYAGoiBCADQcgCakE8aikCADcDACADQdAAaiIFIANByAJqQTRqKQIANwMAIANByABqIgYgA0HIAm\
pBLGopAgA3AwAgA0HAAGoiByADQcgCakEkaikCADcDACADQThqIgggA0HIAmpBHGopAgA3AwAgA0Ew\
aiIJIANByAJqQRRqKQIANwMAIANBIGpBCGoiCiADQcgCakEMaikCADcDACADIAMpAswCNwMgQfAAEA\
giAkUNDyACIAMpAyA3AgwgAkEANgIIIAJCADcDACACQRxqIAkpAwA3AgAgAkEUaiAKKQMANwIAIAJB\
JGogCCkDADcCACACQSxqIAcpAwA3AgAgAkE0aiAGKQMANwIAIAJBPGogBSkDADcCACACQcQAaiAEKQ\
MANwIAIAJB1ABqQQApA6CdQDcCACACQQApA5idQDcCTCACQeQAakEAKQOwnUA3AgAgAkHcAGpBACkD\
qJ1ANwIAQbCCwAAhBAwfCyADQQA2ArABIANBsAFqQQRyQQBBgAEQqAEaIANBgAE2ArABIANByAJqIA\
NBsAFqQYQBEKABGiADQSBqIANByAJqQQRyQYABEKABGkHYARAIIgJFDQ8gAkIANwMIIAJCADcDACAC\
QQA2AlAgAkEAKQO4nUA3AxAgAkEYakEAKQPAnUA3AwAgAkEgakEAKQPInUA3AwAgAkEoakEAKQPQnU\
A3AwAgAkEwakEAKQPYnUA3AwAgAkE4akEAKQPgnUA3AwAgAkHAAGpBACkD6J1ANwMAIAJByABqQQAp\
A/CdQDcDACACQdQAaiADQSBqQYABEKABGkHcgsAAIQQMHgsgA0EANgKwASADQbABakEEckEAQYABEK\
gBGiADQYABNgKwASADQcgCaiADQbABakGEARCgARogA0EgaiADQcgCakEEckGAARCgARpB2AEQCCIC\
RQ0PIAJCADcDCCACQgA3AwAgAkEANgJQIAJBACkD+J1ANwMQIAJBGGpBACkDgJ5ANwMAIAJBIGpBAC\
kDiJ5ANwMAIAJBKGpBACkDkJ5ANwMAIAJBMGpBACkDmJ5ANwMAIAJBOGpBACkDoJ5ANwMAIAJBwABq\
QQApA6ieQDcDACACQcgAakEAKQOwnkA3AwAgAkHUAGogA0EgakGAARCgARpBiIPAACEEDB0LAkACQA\
JAIAEpAABC89CFm9PFjJk0UQ0AIAEpAABC89CFm9PFzJo2UQ0BIAEpAABC89CFm9PljJw0UQ0CIAEp\
AABC89CFm9OlzZgyUg0IIANBADYCsAEgA0GwAWpBBHJBAEHIABCoARogA0HIADYCsAEgA0HIAmogA0\
GwAWpBzAAQoAEaIANBIGogA0HIAmpBBHJByAAQoAEaQZgCEAgiAkUNFSACQQBBzAEQqAFBzAFqIANB\
IGpByAAQoAEaQZiEwAAhBAwfCyADQQA2ArABIANBsAFqQQRyQQBBkAEQqAEaIANBkAE2ArABIANByA\
JqIANBsAFqQZQBEKABGiADQSBqIANByAJqQQRyQZABEKABGkHgAhAIIgJFDREgAkEAQcwBEKgBQcwB\
aiADQSBqQZABEKABGkGsg8AAIQQMHgsgA0EANgKwASADQbABakEEckEAQYgBEKgBGiADQYgBNgKwAS\
ADQcgCaiADQbABakGMARCgARogA0EgaiADQcgCakEEckGIARCgARpB2AIQCCICRQ0RIAJBAEHMARCo\
AUHMAWogA0EgakGIARCgARpB0IPAACEEDB0LIANBADYCsAEgA0GwAWpBBHJBAEHoABCoARogA0HoAD\
YCsAEgA0HIAmogA0GwAWpB7AAQoAEaIANBIGogA0HIAmpBBHJB6AAQoAEaQbgCEAgiAkUNESACQQBB\
zAEQqAFBzAFqIANBIGpB6AAQoAEaQfSDwAAhBAwcCyADQQA2ArABIANBsAFqQQRyQQBBkAEQqAEaIA\
NBkAE2ArABIANByAJqIANBsAFqQZQBEKABGiADQSBqIANByAJqQQRyQZABEKABGkHgAhAIIgJFDRIg\
AkEAQcwBEKgBQcwBaiADQSBqQZABEKABGkHIhMAAIQQMGwsgA0EANgKwASADQbABakEEckEAQYgBEK\
gBGiADQYgBNgKwASADQcgCaiADQbABakGMARCgARogA0EgaiADQcgCakEEckGIARCgARpB2AIQCCIC\
RQ0SIAJBAEHMARCoAUHMAWogA0EgakGIARCgARpB+ITAACEEDBoLIANBADYCsAEgA0GwAWpBBHJBAE\
HoABCoARogA0HoADYCsAEgA0HIAmogA0GwAWpB7AAQoAEaIANBIGogA0HIAmpBBHJB6AAQoAEaQbgC\
EAgiAkUNEiACQQBBzAEQqAFBzAFqIANBIGpB6AAQoAEaQaiFwAAhBAwZCyABQaiGwABBBRCYAQ0BIA\
NBsAFqQQxqQgA3AgAgA0GwAWpBFGpCADcCACADQbABakEcakIANwIAIANBsAFqQSRqQgA3AgAgA0Gw\
AWpBLGpCADcCACADQbABakE0akIANwIAIANBsAFqQTxqQgA3AgAgA0IANwK0ASADQcAANgKwASADQc\
gCaiADQbABakHEABCgARogA0HYAGoiBCADQcgCakE8aikCADcDACADQdAAaiIFIANByAJqQTRqKQIA\
NwMAIANByABqIgYgA0HIAmpBLGopAgA3AwAgA0HAAGoiByADQcgCakEkaikCADcDACADQSBqQRhqIg\
ggA0HIAmpBHGopAgA3AwAgA0EgakEQaiIJIANByAJqQRRqKQIANwMAIANBIGpBCGoiCiADQcgCakEM\
aikCADcDACADIAMpAswCNwMgQegAEAgiAkUNFCACQgA3AwAgAkEANgIgIAIgAykDIDcCJCACQQApA+\
CiQDcDCCACQRBqQQApA+iiQDcDACACQRhqQQApA/CiQDcDACACQSxqIAopAwA3AgAgAkE0aiAJKQMA\
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\
AkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgs2AiAgAyABQRhqKAAAIgJBGHQgAkEIdE\
GAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIMNgIYIAMoAgAhDSADKAIEIQ4gAygCCCEPIAMoAhAhECAD\
KAIMIREgAygCFCESIAMgAUEkaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiEz\
YCJCADIAFBKGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhQ2AiggAyABQTBq\
KAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIVNgIwIAMgAUEsaigAACICQRh0IA\
JBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFjYCLCADIAFBNGooAAAiAkEYdCACQQh0QYCA/Adx\
ciACQQh2QYD+A3EgAkEYdnJyIgI2AjQgAyABQThqKAAAIhdBGHQgF0EIdEGAgPwHcXIgF0EIdkGA/g\
NxIBdBGHZyciIXNgI4IAMgAUE8aigAACIYQRh0IBhBCHRBgID8B3FyIBhBCHZBgP4DcSAYQRh2cnIi\
GDYCPCAIIBMgCnMgGHMgDCAQcyAVcyARIA5zIBNzIBdzQQF3IhlzQQF3IhpzQQF3IhsgCiAScyACcy\
AQIA9zIBRzIBhzQQF3IhxzQQF3Ih1zIBggAnMgHXMgFSAUcyAccyAbc0EBdyIec0EBdyIfcyAaIBxz\
IB5zIBkgGHMgG3MgFyAVcyAacyAWIBNzIBlzIAsgDHMgF3MgEiARcyAWcyAPIA1zIAtzIAJzQQF3Ii\
BzQQF3IiFzQQF3IiJzQQF3IiNzQQF3IiRzQQF3IiVzQQF3IiZzQQF3IicgHSAhcyACIBZzICFzIBQg\
C3MgIHMgHXNBAXciKHNBAXciKXMgHCAgcyAocyAfc0EBdyIqc0EBdyIrcyAfIClzICtzIB4gKHMgKn\
MgJ3NBAXciLHNBAXciLXMgJiAqcyAscyAlIB9zICdzICQgHnMgJnMgIyAbcyAlcyAiIBpzICRzICEg\
GXMgI3MgICAXcyAicyApc0EBdyIuc0EBdyIvc0EBdyIwc0EBdyIxc0EBdyIyc0EBdyIzc0EBdyI0c0\
EBdyI1ICsgL3MgKSAjcyAvcyAoICJzIC5zICtzQQF3IjZzQQF3IjdzICogLnMgNnMgLXNBAXciOHNB\
AXciOXMgLSA3cyA5cyAsIDZzIDhzIDVzQQF3IjpzQQF3IjtzIDQgOHMgOnMgMyAtcyA1cyAyICxzID\
RzIDEgJ3MgM3MgMCAmcyAycyAvICVzIDFzIC4gJHMgMHMgN3NBAXciPHNBAXciPXNBAXciPnNBAXci\
P3NBAXciQHNBAXciQXNBAXciQnNBAXciQyA5ID1zIDcgMXMgPXMgNiAwcyA8cyA5c0EBdyJEc0EBdy\
JFcyA4IDxzIERzIDtzQQF3IkZzQQF3IkdzIDsgRXMgR3MgOiBEcyBGcyBDc0EBdyJIc0EBdyJJcyBC\
IEZzIEhzIEEgO3MgQ3MgQCA6cyBCcyA/IDVzIEFzID4gNHMgQHMgPSAzcyA/cyA8IDJzID5zIEVzQQ\
F3IkpzQQF3IktzQQF3IkxzQQF3Ik1zQQF3Ik5zQQF3Ik9zQQF3IlBzQQF3aiBGIEpzIEQgPnMgSnMg\
R3NBAXciUXMgSXNBAXciUiBFID9zIEtzIFFzQQF3IlMgTCBBIDogOSA8IDEgJiAfICggISAXIBMgEC\
AIQR53IlRqIA4gBSAHQR53IhAgBnMgCHEgBnNqaiANIAQgCEEFd2ogBiAFcyAHcSAFc2pqQZnzidQF\
aiIOQQV3akGZ84nUBWoiVUEedyIIIA5BHnciDXMgBiAPaiAOIFQgEHNxIBBzaiBVQQV3akGZ84nUBW\
oiDnEgDXNqIBAgEWogVSANIFRzcSBUc2ogDkEFd2pBmfOJ1AVqIhBBBXdqQZnzidQFaiIRQR53Ig9q\
IAwgCGogESAQQR53IhMgDkEedyIMc3EgDHNqIBIgDWogDCAIcyAQcSAIc2ogEUEFd2pBmfOJ1AVqIh\
FBBXdqQZnzidQFaiISQR53IgggEUEedyIQcyAKIAxqIBEgDyATc3EgE3NqIBJBBXdqQZnzidQFaiIK\
cSAQc2ogCyATaiAQIA9zIBJxIA9zaiAKQQV3akGZ84nUBWoiDEEFd2pBmfOJ1AVqIg9BHnciC2ogFS\
AKQR53IhdqIAsgDEEedyITcyAUIBBqIAwgFyAIc3EgCHNqIA9BBXdqQZnzidQFaiIUcSATc2ogFiAI\
aiAPIBMgF3NxIBdzaiAUQQV3akGZ84nUBWoiFUEFd2pBmfOJ1AVqIhYgFUEedyIXIBRBHnciCHNxIA\
hzaiACIBNqIAggC3MgFXEgC3NqIBZBBXdqQZnzidQFaiIUQQV3akGZ84nUBWoiFUEedyICaiAZIBZB\
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\
IgY2AqTpQCAGIAVBAXI2AgQgASAAaiAFNgIAIAEgAkEDcjYCBAsgAUEIag8LAkACQEEAKALI6UAiAE\
UNACAAIAZNDQELQQAgBjYCyOlAC0EAQf8fNgLM6UBBACAINgK46UBBACAGNgK06UBBAEGU5sAANgKg\
5kBBAEGc5sAANgKo5kBBAEGU5sAANgKc5kBBAEGk5sAANgKw5kBBAEGc5sAANgKk5kBBAEGs5sAANg\
K45kBBAEGk5sAANgKs5kBBAEG05sAANgLA5kBBAEGs5sAANgK05kBBAEG85sAANgLI5kBBAEG05sAA\
NgK85kBBAEHE5sAANgLQ5kBBAEG85sAANgLE5kBBAEHM5sAANgLY5kBBAEHE5sAANgLM5kBBAEEANg\
LA6UBBAEHU5sAANgLg5kBBAEHM5sAANgLU5kBBAEHU5sAANgLc5kBBAEHc5sAANgLo5kBBAEHc5sAA\
NgLk5kBBAEHk5sAANgLw5kBBAEHk5sAANgLs5kBBAEHs5sAANgL45kBBAEHs5sAANgL05kBBAEH05s\
AANgKA50BBAEH05sAANgL85kBBAEH85sAANgKI50BBAEH85sAANgKE50BBAEGE58AANgKQ50BBAEGE\
58AANgKM50BBAEGM58AANgKY50BBAEGM58AANgKU50BBAEGU58AANgKg50BBAEGc58AANgKo50BBAE\
GU58AANgKc50BBAEGk58AANgKw50BBAEGc58AANgKk50BBAEGs58AANgK450BBAEGk58AANgKs50BB\
AEG058AANgLA50BBAEGs58AANgK050BBAEG858AANgLI50BBAEG058AANgK850BBAEHE58AANgLQ50\
BBAEG858AANgLE50BBAEHM58AANgLY50BBAEHE58AANgLM50BBAEHU58AANgLg50BBAEHM58AANgLU\
50BBAEHc58AANgLo50BBAEHU58AANgLc50BBAEHk58AANgLw50BBAEHc58AANgLk50BBAEHs58AANg\
L450BBAEHk58AANgLs50BBAEH058AANgKA6EBBAEHs58AANgL050BBAEH858AANgKI6EBBAEH058AA\
NgL850BBAEGE6MAANgKQ6EBBAEH858AANgKE6EBBAEGM6MAANgKY6EBBAEGE6MAANgKM6EBBACAGNg\
Ko6UBBAEGM6MAANgKU6EBBACAIQVhqIgA2AqDpQCAGIABBAXI2AgQgBiAAakEoNgIEQQBBgICAATYC\
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\
aiAOIAlqIg8gBnNBGXciBmoiDiAXaiAOIAVzQRB3IgUgICAZc0EYdyIOIBtqIhdqIhUgBnNBFHciBm\
oiCXM2AgggACABIAogEGogFyAdc0EZdyIQaiIXaiAXIA1zQRB3IgEgEmoiDSAQc0EUdyIQaiIXIAFz\
QRh3IgEgDWoiDSALIBggB2ogBCAIc0EZdyIIaiIHaiAHIA5zQRB3IgcgD2oiDyAIc0EUdyIIaiIOcz\
YCBCAAIA4gB3NBGHciByAPaiIPIBdzNgIMIAAgCSAFc0EYdyIFIBVqIg4gE3M2AgAgACACIBFzQRl3\
IAVzNgIUIAAgDSAQc0EZdyAHczYCECAAIA4gBnNBGXcgDHM2AhwgACAPIAhzQRl3IAFzNgIYC+MZAh\
t/An4jAEGwAmsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQekAai0AAEEGdCAALQBoaiIERQ0A\
IAAgASACQYAIIARrIgQgBCACSxsiBRA8GiACIAVrIgJFDQEgA0H4AGpBEGogAEEQaiIEKQMANwMAIA\
NB+ABqQRhqIABBGGoiBikDADcDACADQfgAakEgaiAAQSBqIgcpAwA3AwAgA0H4AGpBMGogAEEwaikD\
ADcDACADQfgAakE4aiAAQThqKQMANwMAIANB+ABqQcAAaiAAQcAAaikDADcDACADQfgAakHIAGogAE\
HIAGopAwA3AwAgA0H4AGpB0ABqIABB0ABqKQMANwMAIANB+ABqQdgAaiAAQdgAaikDADcDACADQfgA\
akHgAGogAEHgAGopAwA3AwAgAyAAKQMINwOAASADIAApAyg3A6ABIABB6QBqLQAAIQggAC0AaiEJIA\
MgAC0AaCIKOgDgASADIAApAwAiHjcDeCADIAkgCEVyQQJyIgg6AOEBIANB6AFqQRhqIgkgBykCADcD\
ACADQegBakEQaiIHIAYpAgA3AwAgA0HoAWpBCGoiBiAEKQIANwMAIAMgACkCCDcD6AEgA0HoAWogA0\
H4AGpBKGogCiAeIAgQCiAJKAIAIQggBygCACEHIAYoAgAhCSADKAKEAiEKIAMoAvwBIQsgAygC9AEh\
DCADKALsASENIAMoAugBIQ4gACAAKQMAEBcgAEHwDmoiDy0AACIGQTdPDQIgACAGQQV0aiIEQZABai\
AONgIAIARBrAFqIAo2AgAgBEGoAWogCDYCACAEQaQBaiALNgIAIARBoAFqIAc2AgAgBEGcAWogDDYC\
ACAEQZgBaiAJNgIAIARBlAFqIA02AgAgDyAGQQFqOgAAIABBKGoiBEIANwMAIARBCGpCADcDACAEQR\
BqQgA3AwAgBEEYakIANwMAIARBIGpCADcDACAEQShqQgA3AwAgBEEwakIANwMAIARBOGpCADcDACAA\
QQA7AWggAEEIaiIEIAApA3A3AwAgBEEIaiAAQfgAaikDADcDACAEQRBqIABBgAFqKQMANwMAIARBGG\
ogAEGIAWopAwA3AwAgACAAKQMAQgF8NwMAIAEgBWohAQsCQCACQYEISQ0AIABBkAFqIQ4gAEHwAGoh\
ByAAKQMAIR8gA0EIakEoaiEKIANBCGpBCGohDSADQfgAakEoaiEJIANB+ABqQQhqIQsgAEHwDmohDA\
NAIB9CCoYhHkF/IAJBAXZndkEBaiEFA0AgBSIEQQF2IQUgHiAEQX9qrYNCAFINAAsgBEEKdq0hHgJA\
AkAgBEGBCEkNACACIARJDQYgAC0AaiEIIANB+ABqQThqQgA3AwAgA0H4AGpBMGpCADcDACAJQgA3Aw\
AgA0H4AGpBIGpCADcDACADQfgAakEYakIANwMAIANB+ABqQRBqQgA3AwAgC0IANwMAIANCADcDeCAB\
IAQgByAfIAggA0H4AGpBwAAQDiEFIANBkAJqQRhqQgA3AwAgA0GQAmpBEGpCADcDACADQZACakEIak\
IANwMAIANCADcDkAICQCAFQQNJDQADQCAFQQV0IgVBwQBPDQkgA0H4AGogBSAHIAggA0GQAmpBIBAi\
IgVBBXQiBkHBAE8NCiAGQSFPDQsgA0H4AGogA0GQAmogBhCgARogBUECSw0ACwsgAygCtAEhECADKA\
KwASERIAMoAqwBIRIgAygCqAEhEyADKAKkASEUIAMoAqABIRUgAygCnAEhFiADKAKYASEXIAMoApQB\
IQggAygCkAEhDyADKAKMASEYIAMoAogBIRkgAygChAEhGiADKAKAASEbIAMoAnwhHCADKAJ4IR0gAC\
AAKQMAEBcgDC0AACIGQTdPDQogDiAGQQV0aiIFIB02AgAgBSAINgIcIAUgDzYCGCAFIBg2AhQgBSAZ\
NgIQIAUgGjYCDCAFIBs2AgggBSAcNgIEIAwgBkEBajoAACAAIAApAwAgHkIBiHwQFyAMLQAAIgZBN0\
8NCyAOIAZBBXRqIgUgFzYCACAFIBA2AhwgBSARNgIYIAUgEjYCFCAFIBM2AhAgBSAUNgIMIAUgFTYC\
CCAFIBY2AgQgDCAGQQFqOgAADAELIAlCADcDACAJQQhqIg9CADcDACAJQRBqIhhCADcDACAJQRhqIh\
lCADcDACAJQSBqIhpCADcDACAJQShqIhtCADcDACAJQTBqIhxCADcDACAJQThqIh1CADcDACALIAcp\
AwA3AwAgC0EIaiIFIAdBCGopAwA3AwAgC0EQaiIGIAdBEGopAwA3AwAgC0EYaiIIIAdBGGopAwA3Aw\
AgA0EAOwHgASADIB83A3ggAyAALQBqOgDiASADQfgAaiABIAQQPBogDSALKQMANwMAIA1BCGogBSkD\
ADcDACANQRBqIAYpAwA3AwAgDUEYaiAIKQMANwMAIAogCSkDADcDACAKQQhqIA8pAwA3AwAgCkEQai\
AYKQMANwMAIApBGGogGSkDADcDACAKQSBqIBopAwA3AwAgCkEoaiAbKQMANwMAIApBMGogHCkDADcD\
ACAKQThqIB0pAwA3AwAgAy0A4gEhDyADLQDhASEYIAMgAy0A4AEiGToAcCADIAMpA3giHzcDCCADIA\
8gGEVyQQJyIg86AHEgA0HoAWpBGGoiGCAIKQIANwMAIANB6AFqQRBqIgggBikCADcDACADQegBakEI\
aiIGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBkgHyAPEAogGCgCACEPIAgoAgAhCCAGKAIAIR\
ggAygChAIhGSADKAL8ASEaIAMoAvQBIRsgAygC7AEhHCADKALoASEdIAAgACkDABAXIAwtAAAiBkE3\
Tw0LIA4gBkEFdGoiBSAdNgIAIAUgGTYCHCAFIA82AhggBSAaNgIUIAUgCDYCECAFIBs2AgwgBSAYNg\
IIIAUgHDYCBCAMIAZBAWo6AAALIAAgACkDACAefCIfNwMAIAIgBEkNCyABIARqIQEgAiAEayICQYAI\
Sw0ACwsgAkUNACAAIAEgAhA8GiAAIAApAwAQFwsgA0GwAmokAA8LIANBkAJqQQhqIgQgCTYCACADQZ\
ACakEQaiIFIAc2AgAgA0GQAmpBGGoiBiAINgIAIAMgDDYCnAIgA0GBAWoiByAEKQIANwAAIAMgCzYC\
pAIgA0GJAWoiBCAFKQIANwAAIAMgCjYCrAIgA0GRAWoiBSAGKQIANwAAIAMgDTYClAIgAyAONgKQAi\
ADIAMpApACNwB5IANBCGpBGGogBSkAADcDACADQQhqQRBqIAQpAAA3AwAgA0EIakEIaiAHKQAANwMA\
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\
QTRqIgQgBC0AACABLQAEIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQTVqIgQgBC0AACAFIANzQf8BcU\
HAmcAAai0AAHMiAzoAACAAQTZqIgQgBC0AACAGIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQTdqIgQg\
BC0AACAHIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQThqIgQgBC0AACAIIANzQf8BcUHAmcAAai0AAH\
MiAzoAACAAQTlqIgQgBC0AACAJIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQTpqIgQgBC0AACAKIANz\
Qf8BcUHAmcAAai0AAHMiAzoAACAAQTtqIgQgBC0AACALIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQT\
xqIgQgBC0AACABLQAMIANzQf8BcUHAmcAAai0AAHMiAzoAACAAQT1qIgQgBC0AACABLQANIANzQf8B\
cUHAmcAAai0AAHMiAzoAACAAQT5qIgAgAC0AACABLQAOIANzQf8BcUHAmcAAai0AAHMiADoAACACIA\
ItAAAgAS0ADyAAc0H/AXFBwJnAAGotAABzOgAAC8sOAg5/AX4jAEGgAmsiByQAAkACQAJAAkACQAJA\
AkACQAJAIAFBgQhJDQBBfyABQX9qQQt2IghndkEKdEGACGpBgAggCBsiCCABSw0DIAdBCGpBAEGAAR\
CoARogASAIayEJIAAgCGohCiAIQQp2rSADfCEVIAhBgAhHDQEgB0EIakEgaiELQeAAIQEgAEGACCAC\
IAMgBCAHQQhqQSAQDiEIDAILIAdCADcDiAFBACELAkAgAUGAeHEiDEUNAEEAIAxrIQpBASEJIAAhCA\
NAIAlBAXFFDQVBASELIAdBAToAjAEgByAINgKIASAIQYAIaiEIQQAhCSAKQYAIaiIKDQALCyABQf8H\
cSEJAkAgBkEFdiIIIAxBAEciCiAKIAhLG0UNACAHKAKIASEIIAdBCGpBGGoiCiACQRhqKQIANwMAIA\
dBCGpBEGoiCyACQRBqKQIANwMAIAdBCGpBCGoiASACQQhqKQIANwMAIAcgAikCADcDCCAHQQhqIAhB\
wAAgAyAEQQFyEAogB0EIaiAIQcAAakHAACADIAQQCiAHQQhqIAhBgAFqQcAAIAMgBBAKIAdBCGogCE\
HAAWpBwAAgAyAEEAogB0EIaiAIQYACakHAACADIAQQCiAHQQhqIAhBwAJqQcAAIAMgBBAKIAdBCGog\
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\
ADcDACACQagBaiAFQRBqKQMANwMAQcAAIQYgAkHwAGpBwABqIAVBGGopAwA3AwAgAiABKQNwNwN4IA\
IgBSkDADcDmAEgA0EFdCAEakFgaiIFKQMAIRIgBSkDCCETIAUpAxAhFCABLQBqIQggAkHQAWogBSkD\
GDcDACACQcgBaiAUNwMAIAJBwAFqIBM3AwAgAkG4AWogEjcDAEIAIRIgAkIANwNwIAIgCEEEciIJOg\
DZASACQcAAOgDYASAHRQ0CIAJB8ABqQQhqIQUgCSEKDAELIAJB8ABqQRBqIAFBEGopAwA3AwAgAkHw\
AGpBGGogAUEYaikDADcDACACQfAAakEgaiABQSBqKQMANwMAIAJB8ABqQTBqIAFBMGopAwA3AwAgAk\
HwAGpBOGogAUE4aikDADcDACACQfAAakHAAGogAUHAAGopAwA3AwAgAkHwAGpByABqIAFByABqKQMA\
NwMAIAJB8ABqQdAAaiABQdAAaikDADcDACACQfAAakHYAGogAUHYAGopAwA3AwAgAkHwAGpB4ABqIA\
FB4ABqKQMANwMAIAIgASkDCDcDeCACIAEpAyg3A5gBIAIgAS0AaiIHIAVFckECciIKOgDZASACIAY6\
ANgBIAIgASkDACISNwNwIAdBBHIhCSACQfgAaiEFIAMhBwtBASAHayELIAFB8ABqIQggBCAHQX9qIg\
xBBXRqIQEgAkGYAWohBwNAIAwgA08NAiACQRhqIgQgBUEYaiINKQIANwMAIAJBEGoiDiAFQRBqIg8p\
AgA3AwAgAkEIaiIQIAVBCGoiESkCADcDACACIAUpAgA3AwAgAiAHIAYgEiAKEAogECkDACESIA4pAw\
AhEyAEKQMAIRQgAikDACEVIA0gCEEYaikDADcDACAPIAhBEGopAwA3AwAgESAIQQhqKQMANwMAIAUg\
CCkDADcDACAHIAEpAwA3AwAgB0EIaiABQQhqKQMANwMAIAdBEGogAUEQaikDADcDACAHQRhqIAFBGG\
opAwA3AwAgAiAUNwPQASACIBM3A8gBIAIgEjcDwAEgAiAVNwO4ASACIAk6ANkBQcAAIQYgAkHAADoA\
2AFCACESIAJCADcDcCABQWBqIQEgCSEKIAtBAWoiC0EBRw0ACwsgAiACQfAAakHwABCgASIBLQBpIQ\
ggAS0AaCEGDAILQQAgC2sgA0H8isAAEI8BAAsgAkEQaiABQRBqKQMANwMAIAJBGGogAUEYaikDADcD\
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\
IAcgC0EFdGoiBEEIaikAADcDACACQRBqIg0gBEEQaikAADcDACACQRhqIg4gBEEYaikAADcDACACIA\
QpAAA3AwAgC0H/AXEiBEUNAiADIARBf2oiDzoAACAKIAIpAwA3AAAgCkEIaiAMKQMANwAAIApBEGog\
DSkDADcAACAKQRhqIA4pAwA3AAAgAkGQAWpBGGoiBCAHIA9BBXRqIgtBGGopAAA3AwAgAkGQAWpBEG\
oiDCALQRBqKQAANwMAIAJBkAFqQQhqIg0gC0EIaikAADcDACAJIAYpAwA3AwAgCUEIaiAGQQhqIg4p\
AwA3AwAgCUEQaiAGQRBqIhApAwA3AwAgCUEYaiAGQRhqIhEpAwA3AwAgAiALKQAANwOQASAAQThqIA\
JBkAFqQThqKQMANwAAIABBMGogAkGQAWpBMGopAwA3AAAgAEEoaiACQZABakEoaikDADcAACAAQSBq\
IAopAwA3AAAgAEEYaiAEKQMANwAAIABBEGogDCkDADcAACAAQQhqIA0pAwA3AAAgACACKQOQATcAAC\
ACQcAAOgCIASACIAg6AIkBIAJCADcDICAEIBEpAgA3AwAgDCAQKQIANwMAIA0gDikCADcDACACIAYp\
AgA3A5ABIAJBkAFqIABBwABCACAIEAogBCgCACELIAwoAgAhDCANKAIAIQ0gAigCrAEhDiACKAKkAS\
EQIAIoApwBIREgAigClAEhEiACKAKQASETIA9B/wFxIgRBN08NAyAHIARBBXRqIgQgEzYCACAEIA42\
AhwgBCALNgIYIAQgEDYCFCAEIAw2AhAgBCARNgIMIAQgDTYCCCAEIBI2AgQgAyAPQQFqIgQ6AAAgBE\
H/AXEgBUsNAAsLIAJB0AFqJAAPC0GkocAAQStBvIrAABCdAQALIAIgDjYCrAEgAiALNgKoASACIBA2\
AqQBIAIgDDYCoAEgAiARNgKcASACIA02ApgBIAIgEjYClAEgAiATNgKQAUG4nsAAQSsgAkGQAWpB+I\
vAAEGci8AAEIIBAAuoBgERfyMAQYABayICJAACQAJAIAEoAgAiA0EQTw0AIAFBBGoiBCADakEQIANr\
IgMgAxCoARogAUEANgIAIAFBFGoiAyAEEA0gAkEQakEIaiIEIAFBzABqIgUpAAA3AwAgAiABQcQAai\
IGKQAANwMQIAMgAkEQahANIAJBCGoiByABQRxqIggpAgA3AwAgAiABKQIUNwMAIAJBEGpBKGoiCUIA\
NwMAIAJBEGpBIGoiCkIANwMAIAJBEGpBGGoiC0IANwMAIAJBEGpBEGoiDEIANwMAIARCADcDACACQg\
A3AxAgAkHQAGpBDGoiDUIANwIAIAJCADcCVCACQRA2AlAgAkHoAGpBEGogAkHQAGpBEGooAgA2AgAg\
AkHoAGpBCGoiDiACQdAAakEIaiIPKQMANwMAIAIgAikDUDcDaCACQRBqQThqIhAgAkHoAGpBDGoiES\
kCADcDACACQRBqQTBqIhIgAikCbDcDACAFIBApAwA3AAAgBiASKQMANwAAIAFBPGogCSkDADcAACAB\
QTRqIAopAwA3AAAgAUEsaiALKQMANwAAIAFBJGogDCkDADcAACAIIAQpAwA3AAAgASACKQMQNwAUIA\
FBADYCAEEQEAgiBUUNASAFIAIpAwA3AAAgBUEIaiAHKQMANwAAIAlCADcDACAKQgA3AwAgC0IANwMA\
IAJBEGpBEGoiBkIANwMAIARCADcDACACQgA3AxAgDUIANwIAIAJCADcCVCACQRA2AlAgAkHoAGpBEG\
ogAkHQAGpBEGooAgA2AgAgDiAPKQMANwMAIAIgAikDUDcDaCAQIBEpAgA3AwAgEiACKQJsNwMAIANB\
OGogECkDADcAACADQTBqIBIpAwA3AAAgA0EoaiAJKQMANwAAIANBIGogCikDADcAACADQRhqIAspAw\
A3AAAgA0EQaiAGKQMANwAAIANBCGogBCkDADcAACADIAIpAxA3AAAgAUEANgIAIABBEDYCBCAAIAU2\
AgAgAkGAAWokAA8LQbSfwABBFyACQRBqQcCbwABB0JvAABCCAQALQRBBAUEAKALc6UAiAkECIAIbEQ\
QAAAv2BQIHfwh+IwBBoAFrIgIkACACQTBqQSxqQgA3AgAgAkEwakEkakIANwIAIAJBMGpBHGpCADcC\
ACACQTBqQRRqQgA3AgAgAkEwakEMakIANwIAIAJCADcCNCACQTA2AjAgAkHoAGpBMGogAkEwakEwai\
gCADYCACACQegAakEoaiACQTBqQShqKQMANwMAIAJB6ABqQSBqIAJBMGpBIGopAwA3AwAgAkHoAGpB\
GGogAkEwakEYaikDADcDACACQegAakEQaiACQTBqQRBqKQMANwMAIAJB6ABqQQhqIAJBMGpBCGopAw\
A3AwAgAiACKQMwNwNoIAJBKGoiAyACQegAakEsaikCADcDACACQSBqIgQgAkHoAGpBJGopAgA3AwAg\
AkEYaiIFIAJB6ABqQRxqKQIANwMAIAJBEGoiBiACQegAakEUaikCADcDACACQQhqIgcgAkHoAGpBDG\
opAgA3AwAgAiACKQJsNwMAIAEgAhAeIAFCADcDCCABQgA3AwAgAUEANgJQIAFBACkDuJ1AIgk3AxAg\
AUEYakEAKQPAnUAiCjcDACABQSBqQQApA8idQCILNwMAIAFBKGpBACkD0J1AIgw3AwAgAUEwakEAKQ\
PYnUAiDTcDACABQThqQQApA+CdQCIONwMAIAFBwABqQQApA+idQCIPNwMAIAFByABqQQApA/CdQCIQ\
NwMAAkBBMBAIIggNAEEwQQFBACgC3OlAIgJBAiACGxEEAAALIAggAikDADcAACAIQShqIAMpAwA3AA\
AgCEEgaiAEKQMANwAAIAhBGGogBSkDADcAACAIQRBqIAYpAwA3AAAgCEEIaiAHKQMANwAAIAFCADcD\
CCABQgA3AwAgAUEANgJQIAFBEGoiASAJNwMAIAFBCGogCjcDACABQRBqIAs3AwAgAUEYaiAMNwMAIA\
FBIGogDTcDACABQShqIA43AwAgAUEwaiAPNwMAIAFBOGogEDcDACAAQTA2AgQgACAINgIAIAJBoAFq\
JAAL4QUCCX8IfiMAQdABayICJAAgAkHAAGpBDGpCADcCACACQcAAakEUakIANwIAIAJBwABqQRxqQg\
A3AgAgAkHAAGpBJGpCADcCACACQcAAakEsakIANwIAIAJBwABqQTRqQgA3AgAgAkHAAGpBPGpCADcC\
ACACQgA3AkQgAkHAADYCQCACQYgBaiACQcAAakHEABCgARogAkE4aiIDIAJBiAFqQTxqKQIANwMAIA\
JBMGoiBCACQYgBakE0aikCADcDACACQShqIgUgAkGIAWpBLGopAgA3AwAgAkEgaiIGIAJBiAFqQSRq\
KQIANwMAIAJBGGoiByACQYgBakEcaikCADcDACACQRBqIgggAkGIAWpBFGopAgA3AwAgAkEIaiIJIA\
JBiAFqQQxqKQIANwMAIAIgAikCjAE3AwAgASACEBYgAUIANwMIIAFCADcDACABQQA2AlAgAUEAKQP4\
nUAiCzcDECABQRhqQQApA4CeQCIMNwMAIAFBIGpBACkDiJ5AIg03AwAgAUEoakEAKQOQnkAiDjcDAC\
ABQTBqQQApA5ieQCIPNwMAIAFBOGpBACkDoJ5AIhA3AwAgAUHAAGpBACkDqJ5AIhE3AwAgAUHIAGpB\
ACkDsJ5AIhI3AwACQEHAABAIIgoNAEHAAEEBQQAoAtzpQCICQQIgAhsRBAAACyAKIAIpAwA3AAAgCk\
E4aiADKQMANwAAIApBMGogBCkDADcAACAKQShqIAUpAwA3AAAgCkEgaiAGKQMANwAAIApBGGogBykD\
ADcAACAKQRBqIAgpAwA3AAAgCkEIaiAJKQMANwAAIAFCADcDCCABQgA3AwAgAUEANgJQIAFBEGoiAS\
ALNwMAIAFBCGogDDcDACABQRBqIA03AwAgAUEYaiAONwMAIAFBIGogDzcDACABQShqIBA3AwAgAUEw\
aiARNwMAIAFBOGogEjcDACAAQcAANgIEIAAgCjYCACACQdABaiQAC7UFAgZ/AX4jAEEwayICJAAgAE\
EIaiEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAQTcgACgCICIEa0E/cUEBaiIFQcAAIARrIgZJDQAg\
BA0BQejjwAAhBAwCCyAFIARqIgYgBUkNAyAGQcAASw0EIABBIGogBGpBBGpB6OPAACAFEKABGiAAKA\
IgIAVqIQYMAgsgBEHBAE8NBCAAQSRqIgcgBGpB6OPAACAGEKABGiADIAcQCSAFIAZrIQUgBkHo48AA\
aiEECyAFQT9xIQYgBCAFQUBxIgVqIQcCQCAFRQ0AQQAgBWshBQNAIAMgBBAJIARBwABqIQQgBUHAAG\
oiBQ0ACwsgAEEkaiAHIAYQoAEaCyAAIAY2AiAgAiAAKQMAQgOGIgg3AwgCQAJAQcAAIAZrIgRBCEsN\
ACAGDQFBCCEGIAJBCGohBwwICyAGQQhqIQQgBkF3Sw0EIARBwABLDQUgAEEgaiAGakEEaiAINwAAIA\
AoAiBBCGohBgwICyAGQcEATw0FIABBJGoiBSAGaiACQQhqIAQQoAEaIAMgBRAJIAZBSGoiBUE/cSEG\
IAJBCGogBGoiBCAFQUBxIgVqIQcgBUUNBkEAIAVrIQUDQCADIAQQCSAEQcAAaiEEIAVBwABqIgUNAA\
wHCwsgBCAGQfiiwAAQkQEACyAGQcAAQfiiwAAQjQEACyAEQcAAQYijwAAQjAEACyAGIARB+KLAABCR\
AQALIARBwABB+KLAABCNAQALIAZBwABBiKPAABCMAQALIABBJGogByAGEKABGgsgACAGNgIgIAIgBj\
YCFAJAIAYNACABQRBqIANBEGopAAA3AAAgAUEIaiADQQhqKQAANwAAIAEgAykAADcAACACQTBqJAAP\
CyACQQA2AhggAkEUakGo5MAAIAJBGGpBrOTAABCVAQALoAUBCn8jAEEwayIDJAAgA0EkaiABNgIAIA\
NBAzoAKCADQoCAgICABDcDCCADIAA2AiBBACEAIANBADYCGCADQQA2AhACQAJAAkACQCACKAIIIgEN\
ACACKAIAIQQgAigCBCIFIAJBFGooAgAiASABIAVLGyIGRQ0BIAIoAhAhB0EAIQAgBiEBA0ACQCAEIA\
BqIghBBGooAgAiCUUNACADKAIgIAgoAgAgCSADKAIkKAIMEQcADQQLIAcgAGoiCCgCACADQQhqIAhB\
BGooAgARBQANAyAAQQhqIQAgAUF/aiIBDQALIAYhAAwBCyACKAIAIQQgAigCBCIFIAJBDGooAgAiCC\
AIIAVLGyIKRQ0AIAFBEGohACAKIQsgBCEBA0ACQCABQQRqKAIAIghFDQAgAygCICABKAIAIAggAygC\
JCgCDBEHAA0DCyADIABBDGotAAA6ACggAyAAQXRqKQIAQiCJNwMIIABBCGooAgAhCCACKAIQIQdBAC\
EGQQAhCQJAAkACQCAAQQRqKAIADgMBAAIBCyAIQQN0IQxBACEJIAcgDGoiDCgCBEEDRw0BIAwoAgAo\
AgAhCAtBASEJCyAAQXBqIQwgAyAINgIUIAMgCTYCECAAKAIAIQgCQAJAAkAgAEF8aigCAA4DAQACAQ\
sgCEEDdCEJIAcgCWoiCSgCBEEDRw0BIAkoAgAoAgAhCAtBASEGCyADIAg2AhwgAyAGNgIYIAcgDCgC\
AEEDdGoiCCgCACADQQhqIAgoAgQRBQANAiABQQhqIQEgAEEgaiEAIAtBf2oiCw0ACyAKIQALAkAgAC\
AFTw0AIAMoAiAgBCAAQQN0aiIAKAIAIAAoAgQgAygCJCgCDBEHAA0BC0EAIQAMAQtBASEACyADQTBq\
JAAgAAv4BAEHfyAAKAIAIgVBAXEiBiAEaiEHAkACQCAFQQRxDQBBACEBDAELQQAhCAJAIAJFDQAgAi\
EJIAEhCgNAIAggCi0AAEHAAXFBgAFHaiEIIApBAWohCiAJQX9qIgkNAAsLIAggB2ohBwtBK0GAgMQA\
IAYbIQYCQAJAIAAoAghBAUYNAEEBIQogACAGIAEgAhCbAQ0BIAAoAhggAyAEIABBHGooAgAoAgwRBw\
APCwJAAkACQAJAAkAgAEEMaigCACIIIAdNDQAgBUEIcQ0EQQAhCiAIIAdrIgkhBUEBIAAtACAiCCAI\
QQNGG0EDcQ4DAwECAwtBASEKIAAgBiABIAIQmwENBCAAKAIYIAMgBCAAQRxqKAIAKAIMEQcADwtBAC\
EFIAkhCgwBCyAJQQF2IQogCUEBakEBdiEFCyAKQQFqIQogAEEcaigCACEJIAAoAgQhCCAAKAIYIQcC\
QANAIApBf2oiCkUNASAHIAggCSgCEBEFAEUNAAtBAQ8LQQEhCiAIQYCAxABGDQEgACAGIAEgAhCbAQ\
0BIAcgAyAEIAkoAgwRBwANAUEAIQoCQANAAkAgBSAKRw0AIAUhCgwCCyAKQQFqIQogByAIIAkoAhAR\
BQBFDQALIApBf2ohCgsgCiAFSSEKDAELIAAoAgQhBSAAQTA2AgQgAC0AICELQQEhCiAAQQE6ACAgAC\
AGIAEgAhCbAQ0AIAggB2tBAWohCiAAQRxqKAIAIQggACgCGCEJAkADQCAKQX9qIgpFDQEgCUEwIAgo\
AhARBQBFDQALQQEPC0EBIQogCSADIAQgCCgCDBEHAA0AIAAgCzoAICAAIAU2AgRBAA8LIAoLgQUBAX\
4gABAyIAEgACkDECICQjiGIAJCKIZCgICAgICAwP8Ag4QgAkIYhkKAgICAgOA/gyACQgiGQoCAgIDw\
H4OEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiIQoD+A4MgAkI4iISEhDcAACABIABBGGopAw\
AiAkI4hiACQiiGQoCAgICAgMD/AIOEIAJCGIZCgICAgIDgP4MgAkIIhkKAgICA8B+DhIQgAkIIiEKA\
gID4D4MgAkIYiEKAgPwHg4QgAkIoiEKA/gODIAJCOIiEhIQ3AAggASAAQSBqKQMAIgJCOIYgAkIohk\
KAgICAgIDA/wCDhCACQhiGQoCAgICA4D+DIAJCCIZCgICAgPAfg4SEIAJCCIhCgICA+A+DIAJCGIhC\
gID8B4OEIAJCKIhCgP4DgyACQjiIhISENwAQIAEgAEEoaikDACICQjiGIAJCKIZCgICAgICAwP8Ag4\
QgAkIYhkKAgICAgOA/gyACQgiGQoCAgIDwH4OEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiI\
QoD+A4MgAkI4iISEhDcAGCABIABBMGopAwAiAkI4hiACQiiGQoCAgICAgMD/AIOEIAJCGIZCgICAgI\
DgP4MgAkIIhkKAgICA8B+DhIQgAkIIiEKAgID4D4MgAkIYiEKAgPwHg4QgAkIoiEKA/gODIAJCOIiE\
hIQ3ACAgASAAQThqKQMAIgJCOIYgAkIohkKAgICAgIDA/wCDhCACQhiGQoCAgICA4D+DIAJCCIZCgI\
CAgPAfg4SEIAJCCIhCgICA+A+DIAJCGIhCgID8B4OEIAJCKIhCgP4DgyACQjiIhISENwAoC+UEAgh/\
AX4jAEGAD2siAiQAIAJBCGpBiAFqIAFBiAFqKQMANwMAIAJBCGpBgAFqIAFBgAFqKQMANwMAIAJBCG\
pB+ABqIAFB+ABqKQMANwMAIAJBCGpBEGogAUEQaikDADcDACACQQhqQRhqIAFBGGopAwA3AwAgAkEI\
akEgaiABQSBqKQMANwMAIAJBCGpBMGogAUEwaikDADcDACACQQhqQThqIAFBOGopAwA3AwAgAkEIak\
HAAGogAUHAAGopAwA3AwAgAkEIakHIAGogAUHIAGopAwA3AwAgAkEIakHQAGogAUHQAGopAwA3AwAg\
AkEIakHYAGogAUHYAGopAwA3AwAgAkEIakHgAGogAUHgAGopAwA3AwAgAiABKQNwNwN4IAIgASkDCD\
cDECACIAEpAyg3AzAgASkDACEKQQAhAyACQQhqQfAOakEAOgAAIAFBkAFqIQQgAUHwDmotAABBBXQh\
BSACQQhqQZABaiEGIAEtAGohByABLQBpIQggAS0AaCEJAkADQAJAIAUNACADIQEMAgsgBiAEKQAANw\
AAIAZBCGogBEEIaikAADcAACAGQRBqIARBEGopAAA3AAAgBkEYaiAEQRhqKQAANwAAIAZBIGohBiAF\
QWBqIQUgBEEgaiEEQTchASADQQFqIgNBN0cNAAsLIAIgBzoAciACIAg6AHEgAiAJOgBwIAIgCjcDCC\
ACIAE6APgOAkBB+A4QCCIEDQBB+A5BCEEAKALc6UAiBEECIAQbEQQAAAsgBCACQQhqQfgOEKABIQQg\
AEGUlcAANgIEIAAgBDYCACACQYAPaiQAC90EAgZ/BX4jAEGQAWsiAiQAIAJBMGpBJGpCADcCACACQT\
BqQRxqQgA3AgAgAkEwakEUakIANwIAIAJBMGpBDGpCADcCACACQgA3AjQgAkEoNgIwIAJB4ABqQShq\
IAJBMGpBKGooAgA2AgAgAkHgAGpBIGogAkEwakEgaikDADcDACACQeAAakEYaiACQTBqQRhqKQMANw\
MAIAJB4ABqQRBqIAJBMGpBEGopAwA3AwAgAkHgAGpBCGogAkEwakEIaikDADcDACACIAIpAzA3A2Ag\
AkEIakEgaiIDIAJB4ABqQSRqKQIANwMAIAJBCGpBGGoiBCACQeAAakEcaikCADcDACACQQhqQRBqIg\
UgAkHgAGpBFGopAgA3AwAgAkEIakEIaiIGIAJB4ABqQQxqKQIANwMAIAIgAikCZDcDCCABIAJBCGoQ\
TiABQgA3AwAgAUEANgIwIAFBACkDuJxAIgg3AwggAUEQakEAKQPAnEAiCTcDACABQRhqQQApA8icQC\
IKNwMAIAFBIGpBACkD0JxAIgs3AwAgAUEoakEAKQPYnEAiDDcDAAJAQSgQCCIHDQBBKEEBQQAoAtzp\
QCICQQIgAhsRBAAACyAHIAIpAwg3AAAgB0EgaiADKQMANwAAIAdBGGogBCkDADcAACAHQRBqIAUpAw\
A3AAAgB0EIaiAGKQMANwAAIAFCADcDACABQQA2AjAgAUEIaiIBIAg3AwAgAUEIaiAJNwMAIAFBEGog\
CjcDACABQRhqIAs3AwAgAUEgaiAMNwMAIABBKDYCBCAAIAc2AgAgAkGQAWokAAvJBAIEfwF+IABBCG\
ohAiAAKQMAIQYCQAJAAkACQCAAKAIcIgNBwABHDQAgAiAAQSBqQQEQB0EAIQMgAEEANgIcDAELIANB\
P0sNAQsgAEEgaiIEIANqQYABOgAAIAAgACgCHCIFQQFqIgM2AhwCQCADQcEATw0AIABBHGogA2pBBG\
pBAEE/IAVrEKgBGgJAQcAAIAAoAhxrQQhPDQAgAiAEQQEQByAAKAIcIgNBwQBPDQMgBEEAIAMQqAEa\
CyAAQdgAaiAGQjuGIAZCK4ZCgICAgICAwP8Ag4QgBkIbhkKAgICAgOA/gyAGQguGQoCAgIDwH4OEhC\
AGQgWIQoCAgPgPgyAGQhWIQoCA/AeDhCAGQiWIQoD+A4MgBkIDhkI4iISEhDcDACACIARBARAHIABB\
ADYCHCABIAAoAggiA0EYdCADQQh0QYCA/AdxciADQQh2QYD+A3EgA0EYdnJyNgAAIAEgAEEMaigCAC\
IDQRh0IANBCHRBgID8B3FyIANBCHZBgP4DcSADQRh2cnI2AAQgASAAQRBqKAIAIgNBGHQgA0EIdEGA\
gPwHcXIgA0EIdkGA/gNxIANBGHZycjYACCABIABBFGooAgAiA0EYdCADQQh0QYCA/AdxciADQQh2QY\
D+A3EgA0EYdnJyNgAMIAEgAEEYaigCACIAQRh0IABBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnI2\
ABAPCyADQcAAQYSfwAAQjAEACyADQcAAQZSfwAAQjwEACyADQcAAQaSfwAAQjQEAC7EEAQl/IwBBMG\
siBiQAQQAhByAGQQA6AAgCQAJAAkACQAJAIAFBQHEiCEUNACAIQUBqQQZ2QQFqIQlBACEHIAYhCiAA\
IQsDQCAHQQJGDQIgCiALNgIAIAYgB0EBaiIHOgAIIApBBGohCiALQcAAaiELIAkgB0cNAAsLIAFBP3\
EhDAJAIAVBBXYiCyAHQf////8DcSIKIAogC0sbIgtFDQAgA0EEciENIAtBBXQhDkEAIQsgBiEKA0Ag\
CigCACEHIAZBEGpBGGoiCSACQRhqKQIANwMAIAZBEGpBEGoiASACQRBqKQIANwMAIAZBEGpBCGoiAy\
ACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAdBwABCACANEAogBCALaiIHQRhqIAkpAwA3AAAgB0EQ\
aiABKQMANwAAIAdBCGogAykDADcAACAHIAYpAxA3AAAgCkEEaiEKIA4gC0EgaiILRw0ACyAGLQAIIQ\
cLAkAgDEUNACAHQQV0IgIgBUsNAiAFIAJrIgtBH00NAyAMQSBHDQQgBCACaiICIAAgCGoiCykAADcA\
ACACQRhqIAtBGGopAAA3AAAgAkEQaiALQRBqKQAANwAAIAJBCGogC0EIaikAADcAACAHQQFqIQcLIA\
ZBMGokACAHDwsgBiALNgIQQbiewABBKyAGQRBqQYyLwABBnIvAABCCAQALIAIgBUGoicAAEIwBAAtB\
ICALQaiJwAAQjQEAC0EgIAxB/KHAABCOAQALqAQBBH8jAEHwAGsiAiQAIAJBIGpBHGpCADcCACACQS\
BqQRRqQgA3AgAgAkEgakEMakIANwIAIAJCADcCJCACQSA2AiAgAkHIAGpBGGogAkEgakEYaikDADcD\
ACACQcgAakEQaiACQSBqQRBqKQMANwMAIAJByABqQQhqIAJBIGpBCGopAwA3AwAgAkHIAGpBIGogAk\
EgakEgaigCADYCACACIAIpAyA3A0ggAkEQaiACQcgAakEUaikCADcDACACQQhqIAJByABqQQxqKQIA\
NwMAIAJBGGogAkHIAGpBHGopAgA3AwAgAiACKQJMNwMAIAIgARASIAFCADcDACABQSBqIAFBiAFqKQ\
MANwMAIAFBGGogAUGAAWopAwA3AwAgAUEQaiABQfgAaikDADcDACABIAEpA3A3AwggAUEoakEAQcIA\
EKgBIQMCQCABQfAOaiIELQAARQ0AIARBADoAAAsCQEEgEAgiBA0AQSBBAUEAKALc6UAiAkECIAIbEQ\
QAAAsgBCACKQMANwAAIARBGGogAkEYaikDADcAACAEQRBqIAJBEGopAwA3AAAgBEEIaiACQQhqKQMA\
NwAAIAFCADcDACABQQhqIgVBGGogAUHwAGoiAUEYaikDADcDACAFQRBqIAFBEGopAwA3AwAgBUEIai\
ABQQhqKQMANwMAIAUgASkDADcDACADQQBBwgAQqAEaIABBIDYCBCAAIAQ2AgAgAkHwAGokAAuJBAEH\
fyMAQaADayICJAAgAkHoAmpBLGpCADcCACACQegCakEkakIANwIAIAJB6AJqQRxqQgA3AgAgAkHoAm\
pBFGpCADcCACACQegCakEMakIANwIAIAJCADcC7AIgAkEwNgLoAiACQTBqQTBqIAJB6AJqQTBqKAIA\
NgIAIAJBMGpBKGogAkHoAmpBKGopAwA3AwAgAkEwakEgaiACQegCakEgaikDADcDACACQTBqQRhqIA\
JB6AJqQRhqKQMANwMAIAJBMGpBEGogAkHoAmpBEGopAwA3AwAgAkEwakEIaiACQegCakEIaikDADcD\
ACACIAIpA+gCNwMwIAJBKGoiAyACQTBqQSxqKQIANwMAIAJBIGoiBCACQTBqQSRqKQIANwMAIAJBGG\
oiBSACQTBqQRxqKQIANwMAIAJBEGoiBiACQTBqQRRqKQIANwMAIAJBCGoiByACQTBqQQxqKQIANwMA\
IAIgAikCNDcDACACQTBqIAFBuAIQoAEaIAJBMGogAhBgAkBBMBAIIggNAEEwQQFBACgC3OlAIgJBAi\
ACGxEEAAALIAggAikDADcAACAIQShqIAMpAwA3AAAgCEEgaiAEKQMANwAAIAhBGGogBSkDADcAACAI\
QRBqIAYpAwA3AAAgCEEIaiAHKQMANwAAIAEQDyAAQTA2AgQgACAINgIAIAJBoANqJAALiQQBB38jAE\
GgA2siAiQAIAJB6AJqQSxqQgA3AgAgAkHoAmpBJGpCADcCACACQegCakEcakIANwIAIAJB6AJqQRRq\
QgA3AgAgAkHoAmpBDGpCADcCACACQgA3AuwCIAJBMDYC6AIgAkEwakEwaiACQegCakEwaigCADYCAC\
ACQTBqQShqIAJB6AJqQShqKQMANwMAIAJBMGpBIGogAkHoAmpBIGopAwA3AwAgAkEwakEYaiACQegC\
akEYaikDADcDACACQTBqQRBqIAJB6AJqQRBqKQMANwMAIAJBMGpBCGogAkHoAmpBCGopAwA3AwAgAi\
ACKQPoAjcDMCACQShqIgMgAkEwakEsaikCADcDACACQSBqIgQgAkEwakEkaikCADcDACACQRhqIgUg\
AkEwakEcaikCADcDACACQRBqIgYgAkEwakEUaikCADcDACACQQhqIgcgAkEwakEMaikCADcDACACIA\
IpAjQ3AwAgAkEwaiABQbgCEKABGiACQTBqIAIQXwJAQTAQCCIIDQBBMEEBQQAoAtzpQCICQQIgAhsR\
BAAACyAIIAIpAwA3AAAgCEEoaiADKQMANwAAIAhBIGogBCkDADcAACAIQRhqIAUpAwA3AAAgCEEQai\
AGKQMANwAAIAhBCGogBykDADcAACABEA8gAEEwNgIEIAAgCDYCACACQaADaiQAC4kEAQd/IwBBwAJr\
IgIkACACQYgCakEsakIANwIAIAJBiAJqQSRqQgA3AgAgAkGIAmpBHGpCADcCACACQYgCakEUakIANw\
IAIAJBiAJqQQxqQgA3AgAgAkIANwKMAiACQTA2AogCIAJBMGpBMGogAkGIAmpBMGooAgA2AgAgAkEw\
akEoaiACQYgCakEoaikDADcDACACQTBqQSBqIAJBiAJqQSBqKQMANwMAIAJBMGpBGGogAkGIAmpBGG\
opAwA3AwAgAkEwakEQaiACQYgCakEQaikDADcDACACQTBqQQhqIAJBiAJqQQhqKQMANwMAIAIgAikD\
iAI3AzAgAkEoaiIDIAJBMGpBLGopAgA3AwAgAkEgaiIEIAJBMGpBJGopAgA3AwAgAkEYaiIFIAJBMG\
pBHGopAgA3AwAgAkEQaiIGIAJBMGpBFGopAgA3AwAgAkEIaiIHIAJBMGpBDGopAgA3AwAgAiACKQI0\
NwMAIAJBMGogAUHYARCgARogAkEwaiACEB4CQEEwEAgiCA0AQTBBAUEAKALc6UAiAkECIAIbEQQAAA\
sgCCACKQMANwAAIAhBKGogAykDADcAACAIQSBqIAQpAwA3AAAgCEEYaiAFKQMANwAAIAhBEGogBikD\
ADcAACAIQQhqIAcpAwA3AAAgARAPIABBMDYCBCAAIAg2AgAgAkHAAmokAAuIBAEHfyMAQaABayICJA\
AgAkEwakEsakIANwIAIAJBMGpBJGpCADcCACACQTBqQRxqQgA3AgAgAkEwakEUakIANwIAIAJBMGpB\
DGpCADcCACACQgA3AjQgAkEwNgIwIAJB6ABqQTBqIAJBMGpBMGooAgA2AgAgAkHoAGpBKGogAkEwak\
EoaikDADcDACACQegAakEgaiACQTBqQSBqKQMANwMAIAJB6ABqQRhqIAJBMGpBGGopAwA3AwAgAkHo\
AGpBEGogAkEwakEQaikDADcDACACQegAakEIaiACQTBqQQhqKQMANwMAIAIgAikDMDcDaCACQShqIg\
MgAkHoAGpBLGopAgA3AwAgAkEgaiIEIAJB6ABqQSRqKQIANwMAIAJBGGoiBSACQegAakEcaikCADcD\
ACACQRBqIgYgAkHoAGpBFGopAgA3AwAgAkEIaiIHIAJB6ABqQQxqKQIANwMAIAIgAikCbDcDACABIA\
IQXyABQQBBzAEQqAEhCAJAQTAQCCIBDQBBMEEBQQAoAtzpQCICQQIgAhsRBAAACyABIAIpAwA3AAAg\
AUEoaiADKQMANwAAIAFBIGogBCkDADcAACABQRhqIAUpAwA3AAAgAUEQaiAGKQMANwAAIAFBCGogBy\
kDADcAACAIQQBBzAEQqAEaIABBMDYCBCAAIAE2AgAgAkGgAWokAAuIBAEHfyMAQaABayICJAAgAkEw\
akEsakIANwIAIAJBMGpBJGpCADcCACACQTBqQRxqQgA3AgAgAkEwakEUakIANwIAIAJBMGpBDGpCAD\
cCACACQgA3AjQgAkEwNgIwIAJB6ABqQTBqIAJBMGpBMGooAgA2AgAgAkHoAGpBKGogAkEwakEoaikD\
ADcDACACQegAakEgaiACQTBqQSBqKQMANwMAIAJB6ABqQRhqIAJBMGpBGGopAwA3AwAgAkHoAGpBEG\
ogAkEwakEQaikDADcDACACQegAakEIaiACQTBqQQhqKQMANwMAIAIgAikDMDcDaCACQShqIgMgAkHo\
AGpBLGopAgA3AwAgAkEgaiIEIAJB6ABqQSRqKQIANwMAIAJBGGoiBSACQegAakEcaikCADcDACACQR\
BqIgYgAkHoAGpBFGopAgA3AwAgAkEIaiIHIAJB6ABqQQxqKQIANwMAIAIgAikCbDcDACABIAIQYCAB\
QQBBzAEQqAEhCAJAQTAQCCIBDQBBMEEBQQAoAtzpQCICQQIgAhsRBAAACyABIAIpAwA3AAAgAUEoai\
ADKQMANwAAIAFBIGogBCkDADcAACABQRhqIAUpAwA3AAAgAUEQaiAGKQMANwAAIAFBCGogBykDADcA\
ACAIQQBBzAEQqAEaIABBMDYCBCAAIAE2AgAgAkGgAWokAAv0AwEJfyMAQaADayICJAAgAkHYAmpBDG\
pCADcCACACQdgCakEUakIANwIAIAJB2AJqQRxqQgA3AgAgAkHYAmpBJGpCADcCACACQdgCakEsakIA\
NwIAIAJB2AJqQTRqQgA3AgAgAkHYAmpBPGpCADcCACACQgA3AtwCIAJBwAA2AtgCIAJBwABqIAJB2A\
JqQcQAEKABGiACQThqIgMgAkHAAGpBPGopAgA3AwAgAkEwaiIEIAJBwABqQTRqKQIANwMAIAJBKGoi\
BSACQcAAakEsaikCADcDACACQSBqIgYgAkHAAGpBJGopAgA3AwAgAkEYaiIHIAJBwABqQRxqKQIANw\
MAIAJBEGoiCCACQcAAakEUaikCADcDACACQQhqIgkgAkHAAGpBDGopAgA3AwAgAiACKQJENwMAIAJB\
wABqIAFBmAIQoAEaIAJBwABqIAIQTwJAQcAAEAgiCg0AQcAAQQFBACgC3OlAIgJBAiACGxEEAAALIA\
ogAikDADcAACAKQThqIAMpAwA3AAAgCkEwaiAEKQMANwAAIApBKGogBSkDADcAACAKQSBqIAYpAwA3\
AAAgCkEYaiAHKQMANwAAIApBEGogCCkDADcAACAKQQhqIAkpAwA3AAAgARAPIABBwAA2AgQgACAKNg\
IAIAJBoANqJAAL9AMBCX8jAEGgA2siAiQAIAJB2AJqQQxqQgA3AgAgAkHYAmpBFGpCADcCACACQdgC\
akEcakIANwIAIAJB2AJqQSRqQgA3AgAgAkHYAmpBLGpCADcCACACQdgCakE0akIANwIAIAJB2AJqQT\
xqQgA3AgAgAkIANwLcAiACQcAANgLYAiACQcAAaiACQdgCakHEABCgARogAkE4aiIDIAJBwABqQTxq\
KQIANwMAIAJBMGoiBCACQcAAakE0aikCADcDACACQShqIgUgAkHAAGpBLGopAgA3AwAgAkEgaiIGIA\
JBwABqQSRqKQIANwMAIAJBGGoiByACQcAAakEcaikCADcDACACQRBqIgggAkHAAGpBFGopAgA3AwAg\
AkEIaiIJIAJBwABqQQxqKQIANwMAIAIgAikCRDcDACACQcAAaiABQZgCEKABGiACQcAAaiACEFACQE\
HAABAIIgoNAEHAAEEBQQAoAtzpQCICQQIgAhsRBAAACyAKIAIpAwA3AAAgCkE4aiADKQMANwAAIApB\
MGogBCkDADcAACAKQShqIAUpAwA3AAAgCkEgaiAGKQMANwAAIApBGGogBykDADcAACAKQRBqIAgpAw\
A3AAAgCkEIaiAJKQMANwAAIAEQDyAAQcAANgIEIAAgCjYCACACQaADaiQAC/QDAQl/IwBB4AJrIgIk\
ACACQZgCakEMakIANwIAIAJBmAJqQRRqQgA3AgAgAkGYAmpBHGpCADcCACACQZgCakEkakIANwIAIA\
JBmAJqQSxqQgA3AgAgAkGYAmpBNGpCADcCACACQZgCakE8akIANwIAIAJCADcCnAIgAkHAADYCmAIg\
AkHAAGogAkGYAmpBxAAQoAEaIAJBOGoiAyACQcAAakE8aikCADcDACACQTBqIgQgAkHAAGpBNGopAg\
A3AwAgAkEoaiIFIAJBwABqQSxqKQIANwMAIAJBIGoiBiACQcAAakEkaikCADcDACACQRhqIgcgAkHA\
AGpBHGopAgA3AwAgAkEQaiIIIAJBwABqQRRqKQIANwMAIAJBCGoiCSACQcAAakEMaikCADcDACACIA\
IpAkQ3AwAgAkHAAGogAUHYARCgARogAkHAAGogAhAWAkBBwAAQCCIKDQBBwABBAUEAKALc6UAiAkEC\
IAIbEQQAAAsgCiACKQMANwAAIApBOGogAykDADcAACAKQTBqIAQpAwA3AAAgCkEoaiAFKQMANwAAIA\
pBIGogBikDADcAACAKQRhqIAcpAwA3AAAgCkEQaiAIKQMANwAAIApBCGogCSkDADcAACABEA8gAEHA\
ADYCBCAAIAo2AgAgAkHgAmokAAvzAwEJfyMAQdABayICJAAgAkHAAGpBDGpCADcCACACQcAAakEUak\
IANwIAIAJBwABqQRxqQgA3AgAgAkHAAGpBJGpCADcCACACQcAAakEsakIANwIAIAJBwABqQTRqQgA3\
AgAgAkHAAGpBPGpCADcCACACQgA3AkQgAkHAADYCQCACQYgBaiACQcAAakHEABCgARogAkE4aiIDIA\
JBiAFqQTxqKQIANwMAIAJBMGoiBCACQYgBakE0aikCADcDACACQShqIgUgAkGIAWpBLGopAgA3AwAg\
AkEgaiIGIAJBiAFqQSRqKQIANwMAIAJBGGoiByACQYgBakEcaikCADcDACACQRBqIgggAkGIAWpBFG\
opAgA3AwAgAkEIaiIJIAJBiAFqQQxqKQIANwMAIAIgAikCjAE3AwAgASACEE8gAUEAQcwBEKgBIQoC\
QEHAABAIIgENAEHAAEEBQQAoAtzpQCICQQIgAhsRBAAACyABIAIpAwA3AAAgAUE4aiADKQMANwAAIA\
FBMGogBCkDADcAACABQShqIAUpAwA3AAAgAUEgaiAGKQMANwAAIAFBGGogBykDADcAACABQRBqIAgp\
AwA3AAAgAUEIaiAJKQMANwAAIApBAEHMARCoARogAEHAADYCBCAAIAE2AgAgAkHQAWokAAvzAwEJfy\
MAQdABayICJAAgAkHAAGpBDGpCADcCACACQcAAakEUakIANwIAIAJBwABqQRxqQgA3AgAgAkHAAGpB\
JGpCADcCACACQcAAakEsakIANwIAIAJBwABqQTRqQgA3AgAgAkHAAGpBPGpCADcCACACQgA3AkQgAk\
HAADYCQCACQYgBaiACQcAAakHEABCgARogAkE4aiIDIAJBiAFqQTxqKQIANwMAIAJBMGoiBCACQYgB\
akE0aikCADcDACACQShqIgUgAkGIAWpBLGopAgA3AwAgAkEgaiIGIAJBiAFqQSRqKQIANwMAIAJBGG\
oiByACQYgBakEcaikCADcDACACQRBqIgggAkGIAWpBFGopAgA3AwAgAkEIaiIJIAJBiAFqQQxqKQIA\
NwMAIAIgAikCjAE3AwAgASACEFAgAUEAQcwBEKgBIQoCQEHAABAIIgENAEHAAEEBQQAoAtzpQCICQQ\
IgAhsRBAAACyABIAIpAwA3AAAgAUE4aiADKQMANwAAIAFBMGogBCkDADcAACABQShqIAUpAwA3AAAg\
AUEgaiAGKQMANwAAIAFBGGogBykDADcAACABQRBqIAgpAwA3AAAgAUEIaiAJKQMANwAAIApBAEHMAR\
CoARogAEHAADYCBCAAIAE2AgAgAkHQAWokAAvwAwIFfwR+IwBB8ABrIgIkACACQSBqQRxqQgA3AgAg\
AkEgakEUakIANwIAIAJBIGpBDGpCADcCACACQgA3AiQgAkEgNgIgIAJByABqQSBqIAJBIGpBIGooAg\
A2AgAgAkHIAGpBGGogAkEgakEYaikDADcDACACQcgAakEQaiACQSBqQRBqKQMANwMAIAJByABqQQhq\
IAJBIGpBCGopAwA3AwAgAiACKQMgNwNIIAJBGGoiAyACQcgAakEcaikCADcDACACQRBqIgQgAkHIAG\
pBFGopAgA3AwAgAkEIaiIFIAJByABqQQxqKQIANwMAIAIgAikCTDcDACABIAIQLyABQQA2AgggAUIA\
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\
BSkDADcAACABEA8gAEEgNgIEIAAgBjYCACACQcABaiQAC5MDAgR/A34jAEHgAGsiAiQAIAJBIGpBFG\
pCADcCACACQSBqQQxqQgA3AgAgAkIANwIkIAJBGDYCICACQcAAakEQaiACQSBqQRBqKQMANwMAIAJB\
wABqQQhqIAJBIGpBCGopAwA3AwAgAkHAAGpBGGogAkEgakEYaigCADYCACACQQhqQQhqIgMgAkHAAG\
pBDGopAgA3AwAgAkEIakEQaiIEIAJBwABqQRRqKQIANwMAIAIgAikDIDcDQCACIAIpAkQ3AwggASAC\
QQhqEBsgAUIANwMAIAFBADYCICABQQApA+CiQCIGNwMIIAFBEGpBACkD6KJAIgc3AwAgAUEYakEAKQ\
PwokAiCDcDAAJAQRgQCCIFDQBBGEEBQQAoAtzpQCICQQIgAhsRBAAACyAFIAIpAwg3AAAgBUEQaiAE\
KQMANwAAIAVBCGogAykDADcAACABQgA3AwAgAUEANgIgIAFBCGoiASAGNwMAIAFBCGogBzcDACABQR\
BqIAg3AwAgAEEYNgIEIAAgBTYCACACQeAAaiQAC/sCAQV/IwBBoANrIgIkACACQfgCakEcakIANwIA\
IAJB+AJqQRRqQgA3AgAgAkH4AmpBDGpCADcCACACQgA3AvwCIAJBIDYC+AIgAkEgakEgaiACQfgCak\
EgaigCADYCACACQSBqQRhqIAJB+AJqQRhqKQMANwMAIAJBIGpBEGogAkH4AmpBEGopAwA3AwAgAkEg\
akEIaiACQfgCakEIaikDADcDACACIAIpA/gCNwMgIAJBGGoiAyACQSBqQRxqKQIANwMAIAJBEGoiBC\
ACQSBqQRRqKQIANwMAIAJBCGoiBSACQSBqQQxqKQIANwMAIAIgAikCJDcDACACQSBqIAFB2AIQoAEa\
IAJBIGogAhBpAkBBIBAIIgYNAEEgQQFBACgC3OlAIgJBAiACGxEEAAALIAYgAikDADcAACAGQRhqIA\
MpAwA3AAAgBkEQaiAEKQMANwAAIAZBCGogBSkDADcAACABEA8gAEEgNgIEIAAgBjYCACACQaADaiQA\
C/sCAQV/IwBBoANrIgIkACACQfgCakEcakIANwIAIAJB+AJqQRRqQgA3AgAgAkH4AmpBDGpCADcCAC\
ACQgA3AvwCIAJBIDYC+AIgAkEgakEgaiACQfgCakEgaigCADYCACACQSBqQRhqIAJB+AJqQRhqKQMA\
NwMAIAJBIGpBEGogAkH4AmpBEGopAwA3AwAgAkEgakEIaiACQfgCakEIaikDADcDACACIAIpA/gCNw\
MgIAJBGGoiAyACQSBqQRxqKQIANwMAIAJBEGoiBCACQSBqQRRqKQIANwMAIAJBCGoiBSACQSBqQQxq\
KQIANwMAIAIgAikCJDcDACACQSBqIAFB2AIQoAEaIAJBIGogAhBqAkBBIBAIIgYNAEEgQQFBACgC3O\
lAIgJBAiACGxEEAAALIAYgAikDADcAACAGQRhqIAMpAwA3AAAgBkEQaiAEKQMANwAAIAZBCGogBSkD\
ADcAACABEA8gAEEgNgIEIAAgBjYCACACQaADaiQAC/sCAQV/IwBBwA9rIgIkACACQZgPakEcakIANw\
IAIAJBmA9qQRRqQgA3AgAgAkGYD2pBDGpCADcCACACQgA3ApwPIAJBIDYCmA8gAkEgakEgaiACQZgP\
akEgaigCADYCACACQSBqQRhqIAJBmA9qQRhqKQMANwMAIAJBIGpBEGogAkGYD2pBEGopAwA3AwAgAk\
EgakEIaiACQZgPakEIaikDADcDACACIAIpA5gPNwMgIAJBGGoiAyACQSBqQRxqKQIANwMAIAJBEGoi\
BCACQSBqQRRqKQIANwMAIAJBCGoiBSACQSBqQQxqKQIANwMAIAIgAikCJDcDACACQSBqIAFB+A4QoA\
EaIAIgAkEgahASAkBBIBAIIgYNAEEgQQFBACgC3OlAIgJBAiACGxEEAAALIAYgAikDADcAACAGQRhq\
IAMpAwA3AAAgBkEQaiAEKQMANwAAIAZBCGogBSkDADcAACABEA8gAEEgNgIEIAAgBjYCACACQcAPai\
QAC/oCAQV/IwBB8ABrIgIkACACQSBqQRxqQgA3AgAgAkEgakEUakIANwIAIAJBIGpBDGpCADcCACAC\
QgA3AiQgAkEgNgIgIAJByABqQSBqIAJBIGpBIGooAgA2AgAgAkHIAGpBGGogAkEgakEYaikDADcDAC\
ACQcgAakEQaiACQSBqQRBqKQMANwMAIAJByABqQQhqIAJBIGpBCGopAwA3AwAgAiACKQMgNwNIIAJB\
GGoiAyACQcgAakEcaikCADcDACACQRBqIgQgAkHIAGpBFGopAgA3AwAgAkEIaiIFIAJByABqQQxqKQ\
IANwMAIAIgAikCTDcDACABIAIQaSABQQBBzAEQqAEhBgJAQSAQCCIBDQBBIEEBQQAoAtzpQCICQQIg\
AhsRBAAACyABIAIpAwA3AAAgAUEYaiADKQMANwAAIAFBEGogBCkDADcAACABQQhqIAUpAwA3AAAgBk\
EAQcwBEKgBGiAAQSA2AgQgACABNgIAIAJB8ABqJAAL+gIBBX8jAEHwAGsiAiQAIAJBIGpBHGpCADcC\
ACACQSBqQRRqQgA3AgAgAkEgakEMakIANwIAIAJCADcCJCACQSA2AiAgAkHIAGpBIGogAkEgakEgai\
gCADYCACACQcgAakEYaiACQSBqQRhqKQMANwMAIAJByABqQRBqIAJBIGpBEGopAwA3AwAgAkHIAGpB\
CGogAkEgakEIaikDADcDACACIAIpAyA3A0ggAkEYaiIDIAJByABqQRxqKQIANwMAIAJBEGoiBCACQc\
gAakEUaikCADcDACACQQhqIgUgAkHIAGpBDGopAgA3AwAgAiACKQJMNwMAIAEgAhBqIAFBAEHMARCo\
ASEGAkBBIBAIIgENAEEgQQFBACgC3OlAIgJBAiACGxEEAAALIAEgAikDADcAACABQRhqIAMpAwA3AA\
AgAUEQaiAEKQMANwAAIAFBCGogBSkDADcAACAGQQBBzAEQqAEaIABBIDYCBCAAIAE2AgAgAkHwAGok\
AAuMAwEHfyMAQbABayICJAAgAkHYAGpBBHIgAUEEahB5IAIgASgCADYCWCACQZgBaiIDIAFBPGopAA\
A3AwAgAkGQAWoiBCABQTRqKQAANwMAIAJBiAFqIgUgAUEsaikAADcDACACQfAAakEQaiIGIAFBJGop\
AAA3AwAgAkHwAGpBCGoiByABQRxqKQAANwMAIAIgASkAFDcDcCACQaABaiIIIAFBxABqEHkgAkEQai\
ACQdgAakEQaigCADYCACACQQhqIAJB2ABqQQhqKQMANwMAIAJBHGogBykDADcCACACQSRqIAYpAwA3\
AgAgAkEsaiAFKQMANwIAIAJBNGogBCkDADcCACACQTxqIAMpAwA3AgAgAkHEAGogCCkDADcCACACQc\
wAaiACQagBaikDADcCACACIAIpA1g3AwAgAiACKQNwNwIUAkBB1AAQCCIBDQBB1ABBBEEAKALc6UAi\
AkECIAIbEQQAAAsgASACQdQAEKABIQEgAEHIlsAANgIEIAAgATYCACACQbABaiQAC/ICAQN/AkACQA\
JAAkACQCAALQBoIgNFDQAgA0HBAE8NAyAAIANqQShqIAEgAkHAACADayIDIAMgAksbIgMQoAEaIAAg\
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\
AWogByAGEKABGiAAIAY2AsgBDwsgAyAFQfiiwAAQkQEACyAFQegAQfiiwAAQjQEACyADQegAQYijwA\
AQjAEAC+8CAQV/AkACQAJAAkACQAJAQZABIAAoAsgBIgNrIgQgAksNACADDQEgASEFDAILIAMgAmoi\
BSADSQ0CIAVBkAFLDQMgAEHIAWogA2pBBGogASACEKABGiAAIAAoAsgBIAJqNgLIAQ8LIANBkQFPDQ\
MgAiAEayECIAEgBGohBSAAIANqQcwBaiABIAQQoAEaQQAhAwNAIAAgA2oiASABLQAAIAFBzAFqLQAA\
czoAACADQQFqIgNBkAFHDQALIAAQEwsgBSACIAJBkAFwIgZrIgJqIQcCQCACQZABSQ0AA0AgBUGQAW\
ohBCACQfB+aiECQQAhAwNAIAAgA2oiASABLQAAIAUgA2otAABzOgAAIANBAWoiA0GQAUcNAAsgABAT\
IAQhBSACQZABTw0ACwsgAEHMAWogByAGEKABGiAAIAY2AsgBDwsgAyAFQfiiwAAQkQEACyAFQZABQf\
iiwAAQjQEACyADQZABQYijwAAQjAEAC+QCAQV/IwBBoANrIgIkACACQYADakEcakEANgIAIAJBgANq\
QRRqQgA3AgAgAkGAA2pBDGpCADcCACACQgA3AoQDIAJBHDYCgAMgAkEgakEQaiACQYADakEQaikDAD\
cDACACQSBqQQhqIAJBgANqQQhqKQMANwMAIAJBIGpBGGogAkGAA2pBGGopAwA3AwAgAkEIaiIDIAJB\
IGpBDGopAgA3AwAgAkEQaiIEIAJBIGpBFGopAgA3AwAgAkEYaiIFIAJBIGpBHGooAgA2AgAgAiACKQ\
OAAzcDICACIAIpAiQ3AwAgAkEgaiABQeACEKABGiACQSBqIAIQbAJAQRwQCCIGDQBBHEEBQQAoAtzp\
QCICQQIgAhsRBAAACyAGIAIpAwA3AAAgBkEYaiAFKAIANgAAIAZBEGogBCkDADcAACAGQQhqIAMpAw\
A3AAAgARAPIABBHDYCBCAAIAY2AgAgAkGgA2okAAvkAgEFfyMAQaADayICJAAgAkGAA2pBHGpBADYC\
ACACQYADakEUakIANwIAIAJBgANqQQxqQgA3AgAgAkIANwKEAyACQRw2AoADIAJBIGpBEGogAkGAA2\
pBEGopAwA3AwAgAkEgakEIaiACQYADakEIaikDADcDACACQSBqQRhqIAJBgANqQRhqKQMANwMAIAJB\
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\
ACgCMGtBCE8NACACIAQQBCAAKAIwIgNBwQBPDQMgBEEAIAMQqAEaCyAAQewAaiAGQgOGNwIAIAIgBB\
AEIABBADYCMCABIAAoAgg2AAAgASAAQQxqKQIANwAEIAEgAEEUaikCADcADCABIABBHGopAgA3ABQg\
ASAAQSRqKQIANwAcIAEgAEEsaigCADYAJA8LIANBwABBhJ/AABCMAQALIANBwABBlJ/AABCPAQALIA\
NBwABBpJ/AABCNAQALugIBA38jAEEQayICJAACQCAAKALIASIDQccASw0AIAAgA2pBzAFqQQY6AAAC\
QCADQQFqIgRByABGDQAgACAEakHMAWpBAEHHACADaxCoARoLQQAhAyAAQQA2AsgBIABBkwJqIgQgBC\
0AAEGAAXI6AAADQCAAIANqIgQgBC0AACAEQcwBai0AAHM6AAAgA0EBaiIDQcgARw0ACyAAEBMgASAA\
KQAANwAAIAFBOGogAEE4aikAADcAACABQTBqIABBMGopAAA3AAAgAUEoaiAAQShqKQAANwAAIAFBIG\
ogAEEgaikAADcAACABQRhqIABBGGopAAA3AAAgAUEQaiAAQRBqKQAANwAAIAFBCGogAEEIaikAADcA\
ACACQRBqJAAPC0G0n8AAQRcgAkEIakHMn8AAQZShwAAQggEAC7oCAQN/IwBBEGsiAiQAAkAgACgCyA\
EiA0HHAEsNACAAIANqQcwBakEBOgAAAkAgA0EBaiIEQcgARg0AIAAgBGpBzAFqQQBBxwAgA2sQqAEa\
C0EAIQMgAEEANgLIASAAQZMCaiIEIAQtAABBgAFyOgAAA0AgACADaiIEIAQtAAAgBEHMAWotAABzOg\
AAIANBAWoiA0HIAEcNAAsgABATIAEgACkAADcAACABQThqIABBOGopAAA3AAAgAUEwaiAAQTBqKQAA\
NwAAIAFBKGogAEEoaikAADcAACABQSBqIABBIGopAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAE\
EQaikAADcAACABQQhqIABBCGopAAA3AAAgAkEQaiQADwtBtJ/AAEEXIAJBCGpBzJ/AAEHUoMAAEIIB\
AAu0AgEEfyMAQaABayICJAAgAkGAAWpBFGpCADcCACACQYABakEMakIANwIAIAJCADcChAEgAkEYNg\
KAASACQRhqQRBqIAJBgAFqQRBqKQMANwMAIAJBGGpBCGogAkGAAWpBCGopAwA3AwAgAkEYakEYaiAC\
QYABakEYaigCADYCACACQQhqIgMgAkEYakEMaikCADcDACACQRBqIgQgAkEYakEUaikCADcDACACIA\
IpA4ABNwMYIAIgAikCHDcDACACQRhqIAFB6AAQoAEaIAJBGGogAhAbAkBBGBAIIgUNAEEYQQFBACgC\
3OlAIgJBAiACGxEEAAALIAUgAikDADcAACAFQRBqIAQpAwA3AAAgBUEIaiADKQMANwAAIAEQDyAAQR\
g2AgQgACAFNgIAIAJBoAFqJAALtgIBCH8jAEHwAGsiAUEoaiICQgA3AwAgAUEgaiIDQgA3AwAgAUEY\
aiIEQgA3AwAgAUEQaiIFQgA3AwAgAUEIaiIGQgA3AwAgAUIANwMAIAFBwABqQQxqQgA3AgAgAUIANw\
JEIAFBEDYCQCABQdgAakEQaiABQcAAakEQaigCADYCACABQdgAakEIaiABQcAAakEIaikDADcDACAB\
IAEpA0A3A1ggAUE4aiIHIAFB2ABqQQxqKQIANwMAIAFBMGoiCCABKQJcNwMAIABBzABqIAcpAwA3AA\
AgAEHEAGogCCkDADcAACAAQTxqIAIpAwA3AAAgAEE0aiADKQMANwAAIABBLGogBCkDADcAACAAQSRq\
IAUpAwA3AAAgAEEcaiAGKQMANwAAIAAgASkDADcAFCAAQQA2AgALtwICBX8BfiMAQcABayICJAAgAk\
HQAGpBCGoiAyABQRBqKQMANwMAIAJB0ABqQRBqIgQgAUEYaikDADcDACACQdAAakEYaiIFIAFBIGop\
AwA3AwAgAkHQAGpBIGoiBiABQShqKQMANwMAIAIgASkDCDcDUCABKQMAIQcgAkH4AGpBBHIgAUE0ah\
BxIAIgASgCMDYCeCACQQhqIAJB+ABqQcQAEKABGgJAQfgAEAgiAQ0AQfgAQQhBACgC3OlAIgJBAiAC\
GxEEAAALIAEgBzcDACABIAIpA1A3AwggAUEQaiADKQMANwMAIAFBGGogBCkDADcDACABQSBqIAUpAw\
A3AwAgAUEoaiAGKQMANwMAIAFBMGogAkEIakHEABCgARogAEGklsAANgIEIAAgATYCACACQcABaiQA\
C6MCAgR/An4gACAAKQMAIgcgAq1CA4Z8Igg3AwAgAEEIaiIDIAMpAwAgCCAHVK18NwMAAkACQEGAAS\
AAKAJQIgNrIgQgAksNACAAQRBqIQUCQCADRQ0AIANBgQFPDQIgAEHUAGoiBiADaiABIAQQoAEaIABB\
ADYCUCAFIAZBARACIAIgBGshAiABIARqIQELIAUgASACQQd2EAIgAEHUAGogASACQYB/cWogAkH/AH\
EiAhCgARogACACNgJQDwsCQAJAIAMgAmoiBCADSQ0AIARBgAFLDQEgAEHQAGogA2pBBGogASACEKAB\
GiAAIAAoAlAgAmo2AlAPCyADIARB5J7AABCRAQALIARBgAFB5J7AABCNAQALIANBgAFB9J7AABCMAQ\
ALnQIBBH8gACAAKQMAIAKtfDcDAAJAAkBBwAAgACgCICIDayIEIAJLDQAgAEEIaiEFAkAgA0UNACAD\
QcEATw0CIABBJGoiBiADaiABIAQQoAEaIAUgBhAJIAIgBGshAiABIARqIQELIAJBP3EhAyABIAJBQH\
EiAmohBAJAIAJFDQBBACACayECA0AgBSABEAkgAUHAAGohASACQcAAaiICDQALCyAAQSRqIAQgAxCg\
ARogACADNgIgDwsCQAJAIAMgAmoiBSADSQ0AIAVBwABLDQEgAEEgaiADakEEaiABIAIQoAEaIAAgAC\
gCICACajYCIA8LIAMgBUH4osAAEJEBAAsgBUHAAEH4osAAEI0BAAsgA0HAAEGIo8AAEIwBAAueAgEE\
fyAAIAApAwAgAq18NwMAAkACQEHAACAAKAIIIgNrIgQgAksNACAAQcwAaiEFAkAgA0UNACADQcEATw\
0CIABBDGoiBiADaiABIAQQoAEaIAUgBhAMIAIgBGshAiABIARqIQELIAJBP3EhAyABIAJBQHEiAmoh\
BAJAIAJFDQBBACACayECA0AgBSABEAwgAUHAAGohASACQcAAaiICDQALCyAAQQxqIAQgAxCgARogAC\
ADNgIIDwsCQAJAIAMgAmoiBSADSQ0AIAVBwABLDQEgAEEIaiADakEEaiABIAIQoAEaIAAgACgCCCAC\
ajYCCA8LIAMgBUH4osAAEJEBAAsgBUHAAEH4osAAEI0BAAsgA0HAAEGIo8AAEIwBAAueAgEEfyAAIA\
ApAwAgAq18NwMAAkACQEHAACAAKAIIIgNrIgQgAksNACAAQcwAaiEFAkAgA0UNACADQcEATw0CIABB\
DGoiBiADaiABIAQQoAEaIAUgBhAQIAIgBGshAiABIARqIQELIAJBP3EhAyABIAJBQHEiAmohBAJAIA\
JFDQBBACACayECA0AgBSABEBAgAUHAAGohASACQcAAaiICDQALCyAAQQxqIAQgAxCgARogACADNgII\
DwsCQAJAIAMgAmoiBSADSQ0AIAVBwABLDQEgAEEIaiADakEEaiABIAIQoAEaIAAgACgCCCACajYCCA\
8LIAMgBUH4osAAEJEBAAsgBUHAAEH4osAAEI0BAAsgA0HAAEGIo8AAEIwBAAudAgEEfyAAIAApAwAg\
Aq18NwMAAkACQEHAACAAKAIcIgNrIgQgAksNACAAQQhqIQUCQCADRQ0AIANBwQBPDQIgAEEgaiIGIA\
NqIAEgBBCgARogBSAGEAUgAiAEayECIAEgBGohAQsgAkE/cSEDIAEgAkFAcSICaiEEAkAgAkUNAEEA\
IAJrIQIDQCAFIAEQBSABQcAAaiEBIAJBwABqIgINAAsLIABBIGogBCADEKABGiAAIAM2AhwPCwJAAk\
AgAyACaiIFIANJDQAgBUHAAEsNASAAQRxqIANqQQRqIAEgAhCgARogACAAKAIcIAJqNgIcDwsgAyAF\
QfiiwAAQkQEACyAFQcAAQfiiwAAQjQEACyADQcAAQYijwAAQjAEAC50CAQR/IAAgACkDACACrXw3Aw\
ACQAJAQcAAIAAoAjAiA2siBCACSw0AIABBCGohBQJAIANFDQAgA0HBAE8NAiAAQTRqIgYgA2ogASAE\
EKABGiAFIAYQBCACIARrIQIgASAEaiEBCyACQT9xIQMgASACQUBxIgJqIQQCQCACRQ0AQQAgAmshAg\
NAIAUgARAEIAFBwABqIQEgAkHAAGoiAg0ACwsgAEE0aiAEIAMQoAEaIAAgAzYCMA8LAkACQCADIAJq\
IgUgA0kNACAFQcAASw0BIABBMGogA2pBBGogASACEKABGiAAIAAoAjAgAmo2AjAPCyADIAVB+KLAAB\
CRAQALIAVBwABB+KLAABCNAQALIANBwABBiKPAABCMAQALpwICA38CfiMAQcAAayICJAAgAkEQakEM\
akIANwIAIAJCADcCFCACQRA2AhAgAkEoakEQaiACQRBqQRBqKAIANgIAIAJBKGpBCGogAkEQakEIai\
kDADcDACACQQhqIgMgAkEoakEMaikCADcDACACIAIpAxA3AyggAiACKQIsNwMAIAEgAhBkIAFBADYC\
CCABQgA3AwAgAUHUAGpBACkCsJxAIgU3AgAgAUEAKQKonEAiBjcCTAJAQRAQCCIEDQBBEEEBQQAoAt\
zpQCICQQIgAhsRBAAACyAEIAIpAwA3AAAgBEEIaiADKQMANwAAIAFBADYCCCABQgA3AwAgAUHMAGoi\
AUEIaiAFNwIAIAEgBjcCACAAQRA2AgQgACAENgIAIAJBwABqJAALpwICA38CfiMAQcAAayICJAAgAk\
EQakEMakIANwIAIAJCADcCFCACQRA2AhAgAkEoakEQaiACQRBqQRBqKAIANgIAIAJBKGpBCGogAkEQ\
akEIaikDADcDACACQQhqIgMgAkEoakEMaikCADcDACACIAIpAxA3AyggAiACKQIsNwMAIAEgAhBlIA\
FBADYCCCABQgA3AwAgAUHUAGpBACkCsJxAIgU3AgAgAUEAKQKonEAiBjcCTAJAQRAQCCIEDQBBEEEB\
QQAoAtzpQCICQQIgAhsRBAAACyAEIAIpAwA3AAAgBEEIaiADKQMANwAAIAFBADYCCCABQgA3AwAgAU\
HMAGoiAUEIaiAFNwIAIAEgBjcCACAAQRA2AgQgACAENgIAIAJBwABqJAALmgIBBH8jAEGQAWsiAiQA\
IAJB+ABqQRRqQQA2AgAgAkH4AGpBDGpCADcCACACQgA3AnwgAkEUNgJ4IAJBGGpBEGogAkH4AGpBEG\
opAwA3AwAgAkEYakEIaiACQfgAakEIaikDADcDACACQQhqIgMgAkEYakEMaikCADcDACACQRBqIgQg\
AkEYakEUaigCADYCACACIAIpA3g3AxggAiACKQIcNwMAIAJBGGogAUHgABCgARogAkEYaiACECECQE\
EUEAgiBQ0AQRRBAUEAKALc6UAiAkECIAIbEQQAAAsgBSACKQMANwAAIAVBEGogBCgCADYAACAFQQhq\
IAMpAwA3AAAgARAPIABBFDYCBCAAIAU2AgAgAkGQAWokAAuaAgEEfyMAQZABayICJAAgAkH4AGpBFG\
pBADYCACACQfgAakEMakIANwIAIAJCADcCfCACQRQ2AnggAkEYakEQaiACQfgAakEQaikDADcDACAC\
QRhqQQhqIAJB+ABqQQhqKQMANwMAIAJBCGoiAyACQRhqQQxqKQIANwMAIAJBEGoiBCACQRhqQRRqKA\
IANgIAIAIgAikDeDcDGCACIAIpAhw3AwAgAkEYaiABQeAAEKABGiACQRhqIAIQXgJAQRQQCCIFDQBB\
FEEBQQAoAtzpQCICQQIgAhsRBAAACyAFIAIpAwA3AAAgBUEQaiAEKAIANgAAIAVBCGogAykDADcAAC\
ABEA8gAEEUNgIEIAAgBTYCACACQZABaiQAC6QCAgR/AX4gAEEIaiECIAApAwAhBgJAAkACQAJAIAAo\
AhwiA0HAAEcNACACIABBIGoQBUEAIQMgAEEANgIcDAELIANBP0sNAQsgAEEgaiIEIANqQYABOgAAIA\
AgACgCHCIFQQFqIgM2AhwCQCADQcEATw0AIABBHGogA2pBBGpBAEE/IAVrEKgBGgJAQcAAIAAoAhxr\
QQhPDQAgAiAEEAUgACgCHCIDQcEATw0DIARBACADEKgBGgsgAEHYAGogBkIDhjcDACACIAQQBSAAQQ\
A2AhwgASAAKAIINgAAIAEgAEEMaikCADcABCABIABBFGopAgA3AAwPCyADQcAAQYSfwAAQjAEACyAD\
QcAAQZSfwAAQjwEACyADQcAAQaSfwAAQjQEAC5oCAQN/IwBBEGsiAiQAAkAgACgCyAEiA0HnAEsNAC\
AAIANqQcwBakEBOgAAAkAgA0EBaiIEQegARg0AIAAgBGpBzAFqQQBB5wAgA2sQqAEaC0EAIQMgAEEA\
NgLIASAAQbMCaiIEIAQtAABBgAFyOgAAA0AgACADaiIEIAQtAAAgBEHMAWotAABzOgAAIANBAWoiA0\
HoAEcNAAsgABATIAEgACkAADcAACABQShqIABBKGopAAA3AAAgAUEgaiAAQSBqKQAANwAAIAFBGGog\
AEEYaikAADcAACABQRBqIABBEGopAAA3AAAgAUEIaiAAQQhqKQAANwAAIAJBEGokAA8LQbSfwABBFy\
ACQQhqQcyfwABBxKDAABCCAQALmgIBA38jAEEQayICJAACQCAAKALIASIDQecASw0AIAAgA2pBzAFq\
QQY6AAACQCADQQFqIgRB6ABGDQAgACAEakHMAWpBAEHnACADaxCoARoLQQAhAyAAQQA2AsgBIABBsw\
JqIgQgBC0AAEGAAXI6AAADQCAAIANqIgQgBC0AACAEQcwBai0AAHM6AAAgA0EBaiIDQegARw0ACyAA\
EBMgASAAKQAANwAAIAFBKGogAEEoaikAADcAACABQSBqIABBIGopAAA3AAAgAUEYaiAAQRhqKQAANw\
AAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgAkEQaiQADwtBtJ/AAEEXIAJBCGpBzJ/A\
AEGEocAAEIIBAAuFAgEEfwJAAkBBECAAKAIAIgNrIgQgAksNACAAQRRqIQUCQCADRQ0AIANBEU8NAi\
AAQQRqIgYgA2ogASAEEKABGiAFIAYQDSACIARrIQIgASAEaiEBCyACQQ9xIQMgASACQXBxIgJqIQQC\
QCACRQ0AQQAgAmshAgNAIAUgARANIAFBEGohASACQRBqIgINAAsLIABBBGogBCADEKABGiAAIAM2Ag\
APCwJAAkAgAyACaiIFIANJDQAgBUEQSw0BIAAgA2pBBGogASACEKABGiAAIAAoAgAgAmo2AgAPCyAD\
IAVB+KLAABCRAQALIAVBEEH4osAAEI0BAAsgA0EQQYijwAAQjAEAC6UCAgJ/An4jAEGQAmsiAiQAIA\
FBCGopAwAhBCABKQMAIQUgAkGIAWpBBHIgAUHUAGoQiAEgAiABKAJQNgKIASACIAJBiAFqQYQBEKAB\
IQMCQEHYARAIIgINAEHYAUEIQQAoAtzpQCIBQQIgARsRBAAACyACIAU3AwAgAiAENwMIIAIgASkDED\
cDECACQRhqIAFBGGopAwA3AwAgAkEgaiABQSBqKQMANwMAIAJBKGogAUEoaikDADcDACACQTBqIAFB\
MGopAwA3AwAgAkE4aiABQThqKQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABqIAFByABqKQMANw\
MAIAJB0ABqIANBhAEQoAEaIABBtJfAADYCBCAAIAI2AgAgA0GQAmokAAulAgICfwJ+IwBBkAJrIgIk\
ACABQQhqKQMAIQQgASkDACEFIAJBiAFqQQRyIAFB1ABqEIgBIAIgASgCUDYCiAEgAiACQYgBakGEAR\
CgASEDAkBB2AEQCCICDQBB2AFBCEEAKALc6UAiAUECIAEbEQQAAAsgAiAFNwMAIAIgBDcDCCACIAEp\
AxA3AxAgAkEYaiABQRhqKQMANwMAIAJBIGogAUEgaikDADcDACACQShqIAFBKGopAwA3AwAgAkEwai\
ABQTBqKQMANwMAIAJBOGogAUE4aikDADcDACACQcAAaiABQcAAaikDADcDACACQcgAaiABQcgAaikD\
ADcDACACQdAAaiADQYQBEKABGiAAQdiXwAA2AgQgACACNgIAIANBkAJqJAALmQICBH8BfiAAQcwAai\
ECIAApAwAhBgJAAkACQAJAIAAoAggiA0HAAEcNACACIABBDGoQDEEAIQMgAEEANgIIDAELIANBP0sN\
AQsgAEEMaiIEIANqQYABOgAAIAAgACgCCCIFQQFqIgM2AggCQCADQcEATw0AIABBCGogA2pBBGpBAE\
E/IAVrEKgBGgJAQcAAIAAoAghrQQhPDQAgAiAEEAwgACgCCCIDQcEATw0DIARBACADEKgBGgsgAEHE\
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\
KQIANwIAIAIgASkCTDcCTCAAQeyWwAA2AgQgACACNgIAIANBkAFqJAAL0gECAn8BfiMAQZABayICJA\
AgASkDACEEIAJByABqQQRyIAFBDGoQcSACIAEoAgg2AkggAiACQcgAakHEABCgASEDAkBB8AAQCCIC\
DQBB8ABBCEEAKALc6UAiAUECIAEbEQQAAAsgAiAENwMAIAJBCGogA0HEABCgARogAkHkAGogAUHkAG\
opAgA3AgAgAkHcAGogAUHcAGopAgA3AgAgAkHUAGogAUHUAGopAgA3AgAgAiABKQJMNwJMIABBkJfA\
ADYCBCAAIAI2AgAgA0GQAWokAAu8AQICfwF+IwBBkAFrIgIkACABKQMAIQQgAkHIAGpBBHIgAUEkah\
BxIAIgASgCIDYCSCACIAJByABqQcQAEKABIQMCQEHoABAIIgINAEHoAEEIQQAoAtzpQCIBQQIgARsR\
BAAACyACIAQ3AwAgAiABKQMINwMIIAJBEGogAUEQaikDADcDACACQRhqIAFBGGopAwA3AwAgAkEgai\
ADQcQAEKABGiAAQcyUwAA2AgQgACACNgIAIANBkAFqJAALrgECAn8BfiMAQZABayICJAAgASkDACEE\
IAJByABqQQRyIAFBDGoQcSACIAEoAgg2AkggAiACQcgAakHEABCgASEDAkBB4AAQCCICDQBB4ABBCE\
EAKALc6UAiAUECIAEbEQQAAAsgAiAENwMAIAJBCGogA0HEABCgARogAkHUAGogAUHUAGopAgA3AgAg\
AiABKQJMNwJMIABB8JTAADYCBCAAIAI2AgAgA0GQAWokAAuuAQICfwF+IwBBkAFrIgIkACABKQMAIQ\
QgAkHIAGpBBHIgAUEMahBxIAIgASgCCDYCSCACIAJByABqQcQAEKABIQMCQEHgABAIIgINAEHgAEEI\
QQAoAtzpQCIBQQIgARsRBAAACyACIAQ3AwAgAkEIaiADQcQAEKABGiACQdQAaiABQdQAaikCADcCAC\
ACIAEpAkw3AkwgAEG4lcAANgIEIAAgAjYCACADQZABaiQAC5gBAQF/QQAhAwJAAkAgAUEASA0AAkAC\
QAJAAkACQCACKAIAIgNFDQACQCACKAIEDQAgAQ0CDAQLIAMgARAVIQIMAgsgAUUNAgsgARAIIQILAk\
AgAkUNACABIQMMAgsgACABNgIEQQEhAwwCC0EBIQJBACEDCyAAIAI2AgRBACEBDAELQQEhAQsgACAB\
NgIAIABBCGogAzYCAAuVAQEBfyMAQTBrIgJBCWogASkABTcAACACQRFqIAEvAA07AAAgAkETaiABLQ\
APOgAAIAIgAS0AADoABCACIAEoAAE2AAUgAkEQNgIAIAJBGGpBCGogAkEIaikDADcDACACQRhqQRBq\
IAJBEGooAgA2AgAgAiACKQMANwMYIAAgAikCHDcAACAAQQhqIAJBJGopAgA3AAALmwEBAX8jAEHwA2\
siAiQAIAJBCGogAUHIARCgARogAkHgAmpBBHIgAUHMAWoQhwEgAiABKALIATYC4AIgAkEIakHIAWog\
AkHgAmpBjAEQoAEaAkBB2AIQCCIBDQBB2AJBCEEAKALc6UAiAkECIAIbEQQAAAsgASACQQhqQdgCEK\
ABIQEgAEGsksAANgIEIAAgATYCACACQfADaiQAC5sBAQF/IwBBgARrIgIkACACQQhqIAFByAEQoAEa\
IAJB6AJqQQRyIAFBzAFqEIsBIAIgASgCyAE2AugCIAJBCGpByAFqIAJB6AJqQZQBEKABGgJAQeACEA\
giAQ0AQeACQQhBACgC3OlAIgJBAiACGxEEAAALIAEgAkEIakHgAhCgASEBIABB0JLAADYCBCAAIAE2\
AgAgAkGABGokAAubAQEBfyMAQfACayICJAAgAkEIaiABQcgBEKABGiACQaACakEEciABQcwBahCKAS\
ACIAEoAsgBNgKgAiACQQhqQcgBaiACQaACakHMABCgARoCQEGYAhAIIgENAEGYAkEIQQAoAtzpQCIC\
QQIgAhsRBAAACyABIAJBCGpBmAIQoAEhASAAQfSSwAA2AgQgACABNgIAIAJB8AJqJAALmwEBAX8jAE\
GwA2siAiQAIAJBCGogAUHIARCgARogAkHAAmpBBHIgAUHMAWoQiQEgAiABKALIATYCwAIgAkEIakHI\
AWogAkHAAmpB7AAQoAEaAkBBuAIQCCIBDQBBuAJBCEEAKALc6UAiAkECIAIbEQQAAAsgASACQQhqQb\
gCEKABIQEgAEGYk8AANgIEIAAgATYCACACQbADaiQAC5sBAQF/IwBBgARrIgIkACACQQhqIAFByAEQ\
oAEaIAJB6AJqQQRyIAFBzAFqEIsBIAIgASgCyAE2AugCIAJBCGpByAFqIAJB6AJqQZQBEKABGgJAQe\
ACEAgiAQ0AQeACQQhBACgC3OlAIgJBAiACGxEEAAALIAEgAkEIakHgAhCgASEBIABBvJPAADYCBCAA\
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\
IANBLGpBBTYCACADQgI3AgwgA0G0j8AANgIIIANBBTYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAz\
YCICADQQhqIAIQpgEAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEF\
NgIAIANCAzcCDCADQcyRwAA2AgggA0EFNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCG\
ogAhCmAQALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQU2AgAgA0IC\
NwIMIANB1IzAADYCCCADQQU2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEKYBAA\
tkAQJ/IwBBIGsiAiQAIAFBHGooAgAhAyABKAIYIQEgAkEIakEQaiAAQRBqKQIANwMAIAJBCGpBCGog\
AEEIaikCADcDACACIAApAgA3AwggASADIAJBCGoQHCEAIAJBIGokACAAC20BAX8jAEEwayIDJAAgAy\
ABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEFNgIAIANCAjcCDCADQYSRwAA2AgggA0EFNgIkIAMg\
A0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhCmAQALbAAgAEIANwMAIAAgACkDcDcDCCAAQS\
BqIABBiAFqKQMANwMAIABBGGogAEGAAWopAwA3AwAgAEEQaiAAQfgAaikDADcDACAAQShqQQBBwgAQ\
qAEaAkAgAEHwDmoiAC0AAEUNACAAQQA6AAALC3YBAn9BASEAQQBBACgCiOZAIgFBAWo2AojmQAJAAk\
BBACgC0OlAQQFHDQBBACgC1OlAQQFqIQAMAQtBAEEBNgLQ6UALQQAgADYC1OlAAkAgAUEASA0AIABB\
AksNAEEAKALY6UBBf0wNACAAQQFLDQAQzQEACwALYwEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIak\
EQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakG4h8AAIAJBCGoQ\
HCEBIAJBIGokACABC2YBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQQhqQRBqIAJBEGopAgA3Aw\
AgBEEIakEIaiACQQhqKQIANwMAIAQgAikCADcDCCAEQYTlwAAgBEEEakGE5cAAIARBCGogAxBIAAtl\
AgF/AX4jAEEQayICJAACQAJAIAFFDQAgASgCAA0BIAFBfzYCACACQQhqIAEoAgQgAUEIaigCACgCEB\
EEACACKQMIIQMgAUEANgIAIAAgAzcDACACQRBqJAAPCxC6AQALELsBAAtRAQJ/AkAgACgCACIDQQRq\
KAIAIANBCGoiBCgCACIAayACTw0AIAMgACACEHIgBCgCACEACyADKAIAIABqIAEgAhCgARogBCAAIA\
JqNgIAQQALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEg\
AkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLUQECfwJAAkAgAEUNACAAKAIADQEgAEEANgIAIAAoAgQhAS\
AAKAIIIQIgABAPIAEgAigCABEBAAJAIAIoAgRFDQAgARAPCw8LELoBAAsQuwEAC04AAkACQCAARQ0A\
IAAoAgANASAAQX82AgAgACgCBCABIAIgAEEIaigCACgCDBEGAAJAIAJFDQAgARAPCyAAQQA2AgAPCx\
C6AQALELsBAAtUAQF/AkACQAJAIAFBgIDEAEYNAEEBIQQgACgCGCABIABBHGooAgAoAhARBQANAQsg\
Ag0BQQAhBAsgBA8LIAAoAhggAiADIABBHGooAgAoAgwRBwALWAAgAEIANwMAIABBADYCMCAAQQApA7\
icQDcDCCAAQRBqQQApA8CcQDcDACAAQRhqQQApA8icQDcDACAAQSBqQQApA9CcQDcDACAAQShqQQAp\
A9icQDcDAAtIAQF/IwBBIGsiAyQAIANBFGpBADYCACADQaShwAA2AhAgA0IBNwIEIAMgATYCHCADIA\
A2AhggAyADQRhqNgIAIAMgAhCmAQALTAAgAEEANgIIIABCADcDACAAQQApAvScQDcCTCAAQdQAakEA\
KQL8nEA3AgAgAEHcAGpBACkChJ1ANwIAIABB5ABqQQApAoydQDcCAAtMACAAQQA2AgggAEIANwMAIA\
BBACkDmJ1ANwJMIABB1ABqQQApA6CdQDcCACAAQdwAakEAKQOonUA3AgAgAEHkAGpBACkDsJ1ANwIA\
CzYBAX8CQCACRQ0AIAAhAwNAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIAJBf2oiAg0ACwsgAAs5AQ\
N/IwBBEGsiASQAIAAoAgwhAiAAKAIIEK8BIQMgASACNgIIIAEgADYCBCABIAM2AgAgARCnAQALKwAC\
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\
cgAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvcgAHAA\
AAAAAAAAEAAABzAAAAJAQQABgAAABHAgAAHAAAAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5yc0wEEABJ\
AAAAZQEAAAkAAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjOD\
IzL2JsYWtlMy0wLjMuOC9zcmMvbGliLnJzAAAATAQQAEkAAAALAgAACgAAAEwEEABJAAAAOQIAAAkA\
AABMBBAASQAAAK4CAAAZAAAATAQQAEkAAACwAgAACQAAAEwEEABJAAAAsAIAADgAAABhc3NlcnRpb2\
4gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKQAMERAATQAAAOMFAAAJAAAATAQQAEkAAACDAgAACQAA\
AEwEEABJAAAAigIAAAoAAABMBBAASQAAAJoDAAAyAAAATAQQAEkAAABVBAAAFgAAAEwEEABJAAAAZw\
QAABYAAABMBBAASQAAAJgEAAASAAAATAQQAEkAAACiBAAAEgAAAAcAAAAEAAAABAAAAHQAAACsBRAA\
SwAAAM0AAAAgAAAAfi8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYz\
gyMy9hcnJheXZlYy0wLjUuMi9zcmMvbGliLnJzAAcAAAAgAAAAAQAAAHUAAAAHAAAABAAAAAQAAAB0\
AAAAPQYQAA0AAAAoBhAAFQAAAGluc3VmZmljaWVudCBjYXBhY2l0eUNhcGFjaXR5RXJyb3JQYWRFcn\
JvcgAAdAYQACAAAACUBhAAEgAAAAcAAAAAAAAAAQAAAHYAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0\
aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIDAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxND\
E1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0\
NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNz\
M3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AACABxAA\
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\
KimaYhfdcDBaAVmROVkO99jsLxUxC8D/ZyYzZxEVWGiHSrSOp4/5ZA0uDNukT/q+HUi1RwjJvPNn5g\
lqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4Ftj\
YWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAJgREABPAAAAOgAAAA0AAA\
CYERAATwAAAEEAAAANAAAAmBEQAE8AAACHAAAAFwAAAJgREABPAAAAhAAAAAkAAACYERAATwAAAIsA\
AAAbAAAAd2UgbmV2ZXIgdXNlIGlucHV0X2xhenkABwAAAAAAAAABAAAAdwAAAOwPEABHAAAAQQAAAA\
EAAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NoYTMt\
MC45LjEvc3JjL2xpYi5ycwDsDxAARwAAAEgAAAABAAAA7A8QAEcAAABPAAAAAQAAAOwPEABHAAAAVg\
AAAAEAAADsDxAARwAAAGYAAAABAAAA7A8QAEcAAABtAAAAAQAAAOwPEABHAAAAdAAAAAEAAADsDxAA\
RwAAAHsAAAABAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQDgEB\
AAHAAAAAICAAAeAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5ycwwREABNAAAA8gsAAA0AAAAv\
cnVzdGMvYzhkZmNmZTA0NmE3NjgwNTU0YmY0ZWI2MTJiYWQ4NDBlNzYzMWM0Yi9saWJyYXJ5L2Nvcm\
Uvc3JjL3NsaWNlL21vZC5ycwAAAAAAAADvzauJZ0UjARAyVHaYutz+h+Gyw7SllvCYERAATwAAABsA\
AAANAAAAmBEQAE8AAAAiAAAADQAAAH4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2\
M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuOS4wL3NyYy9saWIucnMAXgzp93yxqgLsqEPiA0tC\
rNP81Q3jW81yOn/59pObAW2TkR/S/3iZzeIpgHDJoXN1w4MqkmsyZLFwWJEE7j6IRubsA3EF46zqXF\
OjCLhpQcV8xN6NkVTnTAz0Ddzf9KIK+r5NpxhvtxBqq9FaI7bMxv/iL1chYXITHpKdGW+MSBrKBwDa\
9PnJS8dBUuj25vUmtkdZ6tt5kIWSjJ7JxYUYT0uGb6kedo7XfcG1UoxCNo7BYzA3J2jPaW7FtJs9yQ\
e26rV2DnYOgn1C3H/wxpxcZOBCMyR4oDi/BH0unTw0a1/GDgtg64rC8qy8VHJf2A5s5U/bpIEiWXGf\
7Q/OafpnGdtFZbn4k1L9C2Cn8tfpechOGZMBkkgChrPAnC07U/mkE3aVFWyDU5DxezX8is9t21cPN3\
p66r4YZpC5UMoXcQM1SkJ0lwqzapskJeMCL+n04cocBgfbOXcFKqTsnLTz2HMvOFE/vla9KLuwQ1jt\
+kWDH78RXD2BHGmhX9e25PCKmZmth6QY7jMQRMmx6ugmPPkiqMArEBC1OxLmDDHvHhRUsd1ZALll/A\
fm4MVAhhXgz6PDJpgHToj9NcUjlQ0NkwArmk51jWM11Z1GQM/8hUBMOuKL0nqxxC5qPmr88LLKzT+U\
axqXYChGBOMS4m7ePa5lF+Aq8yJi/giDR7ULVV0qou2gjanvqacNxIYWp1HDhHyGnG1YBRFTKKL9he\
7/3HbvXiwm0PvMAdKQicuU8rp12foq9WSU5hQ+E9+vE7CUWMkjKKPRpwYZEfYwUf6Vb8AGLEZOsyrZ\
0nF8iDPee+0+ORhlbm10eSkzcV04GaRbZHWpSLmmG3xnrP17GXyYMQI9BUvEI2zeTdYC0P5JHFhxFS\
Y4Y01H3WLQc+TDRkWqYPhVlDTOj5LZlKvKuhsWSGhvDncwJJFjHGTGAualyG4r3X0zFSUohxtwSwNC\
a9osbQnLgcE3PbBvHMdmgkMI4VWyUevHgDErvIvAli+4kt+68zKmwMhoXFYFPRyGzARVj2uyX+Wkv6\
u0zrqzCouEQTJdRKpzojSzgdhaqPCWprxs1Si1Zez2JEpS9JAuUeEMWtMGVZ3XnU55l87G+gWJJTOb\
ED5bKRkgzFSgc4tHqfiwfkE0+fIkKcQbbVN9NZM5i/+2HcIaqDi/FmB98fvER/XjZ3bdqg8eluuLk2\
L/vHrJecGPlK2Npw3lESm3mB+PkRoSJ66O5GEImIUxrfdiTevqXO9Fo+vszoSWvF6yzvUhYve3DOIz\
9uSTgqsG3yyjpCzupSwgWpixj4rMR4QLz6NZmJdEUnafFwAkobEW1agmx127PrrXCznbarhVykvlY4\
BHbP06eh3dnmbnCMaeUSOqSdGiFVcOlPGPhHFFfRciTAFBMl+17sIubjqhXF4PYcP1dXuSKYA25NbD\
q58TrS9Az0yp8V0NyN+lvkjZiz5+9z+9V9OgpUX2dB8lLtGigqCBXlKe/WZJemh/zpAMLsU7l7q+vO\
jCX3QJ5bwBAADWs9rmu3c3QrVu8K5+HGbR2M+qTTUfeKH8rxYrSigRLR8difpnT/zx2gqSy13C7HNR\
JqHCIgxhroq3VtMQqOCWD4fnLx84mlowVU7p7WKt1ScUjTbo5SXSMUavx3B7l2VP1zneson4mUPR4V\
S/MD8jlzym2dN1lpqo+TTzT1VwVIhWT0p0y2oWra7ksqpMx3ASTSlvZJHQ8NExQGiJKrhXawu+YVpa\
2e+a8vJp6RK9L+if//4TcNObBloI1gQEmz8V/mwW88FASfve881NLFQJ41zNhYMhxbRBpmJE3Lc1yT\
+2046m+Bc0QFshWylZCbhyhYw779qc+V25/PgUBowB8806Gs2sFBstc7sA8nHUhBba6JUOEaPBuIIa\
vyByCkMOId85DQl+t51e0DyfvfReRKRXftr2T534pdSD4WAd2keOmReEw4eyhhizGxLcPv7vywyYzD\
z+xwP9mxiQtW/k3FdMmkb9MjdlrfF8oAD3flmIHaNoRMZZ9mFb1LSwL3YYdwSZ0K5bFaa6UD1MXnVo\
37TYIn9OIen0lawuU7/dKgkBvbQJOa4yUDSOsDf1TYONciBCqJ0g+vcj/p6bHWmef42uxIjSRgRbeG\
nhJMVMe4UTyjUBf9ghpYp7Ew9Au86+lgdYZisuJ96wwiVBJhI2svserb0CdwXpS/isjru61HvGG2Q5\
MViRJOA2gOAt3IvtaJ/0VoE8YBFR79v3NtL3gB7SilnEJ5fXXwpnlgiKoMup6wlDj0rLoTZwD0tWr4\
G9mhl4p5q5wFLpyD/IHp+VuYFKeXdQUIzwOGMFj6/KOnhnemJQP7QHd8zs9UmrREqY7nm25NbDO4wQ\
FM/R1MCcoMhrIAvABkSJLdfIVIihgixDPFyzZuNn8jcrEGHdI7kdJ4TYeSerVq8lFf+w4YO+qUl+Id\
RlfPvU50ht5+Dba54X2UWHgt8INL1T3Zpq6iIKICJWHBRu4+5Qt4wbXYB/N+hYn6XH5a88wrFPapl/\
4tDwdQf7fYbTGomIbt5z5tAlbLivnus6EpW4RcHV1fEw52ly7i1KQ7s4+jH57GfLeJy/OzJyAzvzdJ\
wn+zZj1lKqTvsKrDNfUIfhzKKZzaXouzAtHoB0SVOQbYfVEVctjY4DvJEoQRofSGblgh3n4ta3MndJ\
OmwDdKv1YWPZfraJogLq8diV7f891GQU1jsr5yBI3AsXDzCmeqd47WCHwes4IaEFWr6m5ph8+LSlIq\
G1kGkLFIlgPFbVXR85LstGTDSUt8nbrTLZ9a8VIORw6gjxjEc+Z6Zl15mNJ6t+dfvEkgZuLYbGEd8W\
O38N8YTr3QTqZaYE9i5vs9/g8A8PjkpRurw9+O7tpR43pA4qCk/8KYSzXKgdPujiHBu6gviP3A3oU4\
NeUEXNFwfb1ACa0RgBgfOl7c+gNPLKh4hRfucLNlHEszgUNB75zImQ9JdX4BQdWfKdP9L/zcWVhSLa\
PVQzKgWZ/YEfZnZ7D9tB5jaHB1OOQSV3IhX6si4WRn9f4v7ZE2wSsqhI6m7nkhdU3K+PidHGvxLZAx\
v1gxv6qrEx2bcq5JYnrPGs69L816ejQMW8+wptE1YQhQxtmt3hiXiqdHkqeCU105vAigcJXeKn0O3G\
6rM4Qb1wnutxvr8Kklxiwk/10KWio5ASC2vjVMArk/5i/1nd9n2sqBFFNTc11Nz6cpFehMrcIJ0yYC\
v4hBgvZ83hLMZ5LGQk0a2iCYsm59kZaunB0AxQqUubanha80NMYzYDAg4i2GbrSkd7wcKqm+zjGnNq\
WAKE4HpmJoKl7MqRdlbUZ7WtdUhcFZQd3z+BW5j9AG0GzXS3/G4oUa9Epx9HNIheLq5h566gLPea4O\
iuzeRAvmX2GFG7C5fpZBnfM+tLbnJilxkpBwA7cKcw7/UW2DFGvqYEFbW1gLhsS9h+w5MXZJZ96fZ3\
7SF7c2v5LjEGY3f082/oSIlSrvj4o4by19tTYxD8TOfcyhbdxlL6vRlcANNq1GRdj4ZoahgezyxRnT\
quYFY4wmJ+Ntex3Hfq51njbr6adHMHbFJLc5/Q+eVac6iLVYrMxz9JRatBMFPBubC9WQpHulgZMpPD\
Rl8LsC2F5bA20yubIJGf8Z5lfU9gbiTLLHjiipq5x8QUyLYq9cx7chG+r9knR02zIQEMDZV+H0etcF\
ZDb3VJaFphQtSt9XqVuYCZ4IdOVeOuUN+hzypW1S/9OiaY2NaPDNhNkvTIOhdKdT3Kmc88v5GvrHtH\
/i3BkNb2cVPtlHBoXihcGoOkoAg3CsnTxYBl0Bc3kH8Pf/L9uBO7+RlDKFBNG2+9sRJA/4+jG3YcOx\
/i4sQwFQ2KLDenac5DiWbOtf4RThjlIWZzvYDbi2ELTVeL1ropfVv+5iU+YbuBP5EHvBCcHAeXLawJ\
eeu+x1fXxTs1jeXD6GGP85J4AesawhybnPvv1Kv3lPQmfXKZAz5rlaJj4KMwnKBKmotKnbQPCQDVt2\
o/wIomV6DywJzRQr/tLZ3uPXKpYHnISQ8zQRtChwJyssacNgB8wJ7FCiU0NctJrE7v2CkB704kUPS2\
3vTK5UbMivdjkphjq/4veEV6Xf65fI81RmNOZPfYWwDJLb8Vc3pCHCYlIarE0BdQjlGTbEiSOcPU16\
Lg/su0jd1dLCDWdXxhbFvj2JXC2xkrAwLTabNgMkHk3F9oQs4QVvbdud3zBvBI4bUd0qSOb0nNL+b8\
sCAx7rBYI5EbLAij9Ri4F4Oyz9KmnBgenKjI26pqVxhrDOP6mRKp6l225ycQf0t5K/vrWztEfzHkBK\
bQOVkyLYVL/H8g++5rrtV008eBsoKWMHW0w5ShCeO6BZ+0E3v5w4xnOSn4L0KpmHz/dhCwFksk7mc9\
ZhxXv/ihDePuWGcNH7e53nrZEbbJoldse4jVr7fhT5hrhK6QYv2lwazeTN+U/zpIxdFbigU3PLpCwW\
wWY0Bv97JuUriNTm0NbwOACOEdMR2XySMFnpHWfMwkKOxFyYIj5lmDW1eVmYjEDUCe+mgVckXLPoLR\
LwgGgjuY/drLqIYjCCl9qoh1uANEzZ8m4NG9KPf1kRv2AQIEOZ9m5N5K8IwhfB16zuWc1yk8YmWxC8\
CWkERoI7oDpZ2H8ZurjgVYpLHsI7zMHkC7Ad9Ymj0UX6ho6HCgniPyfTCI8U+DEWQatGXVFAIWcFJ0\
MxPuCV4oP889DpVTCci5VAKTWW3aMIlAmfI7hxNpUz+UVamEh8upyt5eoaDpKzUnIRQp+3pO/x838H\
YoIk8nUPQ5AouGXh3wOge7wZYOwXEFyL8jLiJohQhn0rC1gI7Uo3GWgbuT4YrTtVW4BIuh0OI6aV8z\
1a3stEhcyqEWSRk7dP3EmL40gQF3Ja2kVDzoh3nnueEz2hQQ4SgTomoinsUMJ2BfGm11X0lxd++vYP\
tT6Ju/PUT3p4bHrYKasnNhRQQJXr0ywmZ6vFiyyDpnjFUG8yp3ybbGOfZB2jXan+nvbSEV5nscxwxk\
ESdVXFaUNsSTOXh3RmKOA+ppJD5azvOr+dIS0w+Ndh50xlLWzoO4RAFShT+jW1oLwp1aQ8MzluYa7P\
2MCKSMopcg9JYePKQkiEan7m6mL2E3Wg7P+WWxTGtK+6ugBhyqQ2t5YvFvwk1/D5vtVI7Mumw+JbvS\
7/+3pk+dorCVvCUujDjx3oul1oZU8LZ2xUrX3l2ARSu8vTCAiZJN6XCvgTzbADGe2m3/PkeIzN+fw4\
2zfrgXjVKFOBJCtrFA0g7a8qn5S9Xc+s5E5n48Qw4gEhNIx3g6T8j8n7t2hSRyH83w5M84NgV0aexM\
TuwMfLanK+0yzuXzTS+sEUzqJkPRM8u8WH7HTATppO/8NNmTMlFfRFTlBlVkyV0K5H0xj0HeUFni3W\
kas4w4hgqCVTSotC3pGnGEHqkQkHGDSbG38PdNeXGXwKsuKtYOXI2ql8D6Ipvz2vEvzJ/0gZLyb8bV\
f0g/qNz8Zwaj6GPO/NLjS5sswrv7k0v3P9pmunD+0mWhL9STDpd54gOhcV7ksHfszb6X5IU5ch60zx\
dQ914Cqgq34LhAOPAJI9R5hYk10Br8jsWrsuILksaWcpFaN2NBr2b7J3HK3Kt0IUH/ckqmzjyzpWYw\
CDNJSvD1mijXzQqXjV7CyDHg6JaPR12HdiLA/vPdkGEFEPN77JEUD7uusK31kojVD4X4UJvoTbdYg0\
h1SWEcU5H2TzWj7sbSgeS7AgeY7e19BST7iQLploUTdTCs7XInF4A1LR0Nw2uOwo9z6yZDBGOP71RY\
vjvdWjJSXJ4jRlwyz1OqkGfQnTRRTdLBJKaepu7PUSBPfi6GCg8iE2RI4ASUOTnOt/yGcKQsxNnM5w\
OKI9JaaNvxL6uyhGQG7Hm/73Bdnf5UGEic3bkTW60JFe111PAVUZjHDgbN6wv4tzoYkWeM1eTu81JQ\
fBjR/4JO5ZIRXcmibKy5TKHuhl19Z1OxvoU0KkmMH3gdGd3564SnumYI9nSM0KI7ZI9RInwI4VbpUo\
iNrhDEjctopxqO7L8mdwQ4qkU7zbQ4d6YZ3g3sHGkWrQcuRoCTMdTGOBmmC22HpcVA2I+lH/q5FhhP\
pzwXsYoYHwKcyZgv2qsW6EoTq4AFPrtaZHO3BTtf9vJ1Vb6iASWpi35OAHQvG1PZ6HEDWNccME52Yp\
XYbn89AG9Z/yZZsbnWxag9KWWfTPiQ1k3wzm6IrzP/XyeCRwEIgj8IMxTktfkamkD+Df1rOdssNKMl\
Q1KyAbNifueKWmFVZp+eb8MJLNOSLVpFhYV0R0mp3sfyup6jM8G0z2NiVLxuzECwg7Ams/3IVJQ7jN\
f/h55q9VbGK/SZDZTCLS1uCWsJ3/eYv1LYOh7gphkLtNTby5ypQlnF6UWvmJmlhjHZB+iVYjZz96H6\
GxhIax0KehXiV+wf1Rog9mpEZ0Z18LDPyusV5ngHKWhPH/O4HtEiztY+cSI7ycMup8FXMC8fP3zDrE\
bLDvWqAv2TuNvPnwtgLtkfM9Y66khh+Zik6oNqi25C2KjcXHO3dLKJoBFKUh5zs/aHSWfJy+UIiBGU\
05uxx+QGmQyiJJt+f+2vp0Q2697qCWXeDu/o0/EebLSPeelDfcm5oygMdITX8qJvVpdhR5aEe50GX7\
bm41t6EG++eO0wY/kVagd65w3m7tCbi6BK7ksrTom4xz6mVmr0/jS6WRMSAvwDNyj4mb9MyDCvDDVx\
gDl6aBfwiXqn0Gk1Qp7rqcHxmYHuLSh2eYy9eh/dpTcXXYD6qQk8Q1NP2aF831MMi/p3y2yIvNzZPy\
BHG6l8kUDA39zR+UIB0H1YezhPHfx2hANlMfPF5/gjOXPj50QiKgNLp/VQ16WHXC6ZmDbETCsIPPZY\
uOx7kd/abfhb/LhwMnbdtSm7cq4QKzYAd07JaleP+x7G2hLRGiek+sUOwxtpQ3EyzBFjJP8GMuUwjj\
ZCMZajLOAxDjhx8XatCpZcjZU2pW3BMPTW+NLh5xs/0f/I4dtNAGaueHVG5nsGAT+DBW1Y/juttTS7\
8Jcrock0XwmoDNYlRbZ6JNF3dAHzxtvcTdLK3tQULkrrHgq+2ea1vasBQ3n3cH4q/UAFJ4ot9N7BIk\
yjwI4HAYdjwfQaUd7lCjOavVI6u341ZH2qV3hpdzJMrgMWg04AEuN4rSAQoufyILRqDKdBneZBEeoY\
bOAoKGtPmL2MstKDnW5EbF+3Jn+NQU2MVke6jj0Y5r+tC9hEYBZff20gDj7KyxE5pFjivMAdskYXOn\
LTzdf1VKjKx5wdJj2IMqx8LJS6I2TCkHa4QoBHJFXlF584olZ2R77goC2rZ16bKE0x/buPnCuGRGUT\
FJ0EyHy0k8eRKzYbLILY3xP7VUaxTnup4hQHusseFF/eXJ1FQ2GJrPDV8fuoUwBbXhzYBOqX87P91K\
iBIWIIEipXQdO86YrlzEOGJREUpODGpP7FRJEPYs9lZdAzDaGcIZ9IjaRUIchjbaxePsSvDXdyOoty\
qe+H3yB7TpPX5YY+GrYDVeME1RnI+yHjyqa/YKyzUJoSw7affupoXs3HsYOUGZAcsGw3lcLVPOk9E6\
25Kt8u1a6EeKDAEvVgLskQYuOjhj28zlE5FpudJjX6tc3QKm59DDNXf9iXYuhZ57CNiSHyjil+qqXR\
KQAAVUUbBrXhisCLOnCSbCscw8JC7yWva1nMlFYEVCLbcx0KmhfE2fmgtgRgPD2uoq/978SWlLRbB8\
j349QcHRTHxZw0VY4hOBa9eGokUPhoFfGyKbwClfq8+u0bBSPa8uVseXxTk9ywKOGqrilL7qA9STrX\
lWhBLGvftTd/LRIlvav8scRdEFgLgXCQKoj3N90P4Vw/ilG1yk1SWyVRhIeFnjziNL0ZgYIpQMvsPF\
1vW6B0yj7hQhUCELas4lkv0Xn5D1DM+eQn2jdgfYTxDVqXkl7+I+bTkOFt1kiAVnu41jJQbiE1gs63\
NppKS/YkeiongPcWaYyL7e+TVRXOTPS/3TclvZlLXduVS8AvgWmh/dOStgtmkJpKGvuyuaRGaRkMc2\
jaSX+qieKBX6Cxgw+aZmSL9ESWff+zJ7N1to1cYWvMlb7rvLkgT2eCWWV1giMxbwXPRT5xiORaVxHC\
VJmfYb/p6qhAYMS66s3BwPLpb0xFHGkSZEn2nEFwD1sm7zvc056KV8P1YA5tVTwyJoVgDlv1WRv6qc\
FGGvqPTHyhReKp11Up21lRymXCrzXOdgrbBUU9Eal+x+qBDQqstor4jlL/43tZU6KeoFbNSKyz3w1D\
b+Rc9Hqms8Re0OL72M/OTvA1mbMQb/U+xhnWnILWIgtpIN90Ckb9F0DtEIWOzPhsp8puOr8kyNZJcI\
EaWD0kYaJjwbu2rIsEMsxEfcKKo9mrEPSqW//df0uCBKhaSW2tlJ+MLU+npuHj6N41EoX31JPYQGWI\
f0v92r+kKgQgfCR8MtEXxaFuCYVmGja0ZmnVfQUhEsOlfSf3zzqkk5jVlIEiwM0cxfBk24lh/8S8Mz\
3xauZMGMsF4OqbuR0dzVz/D5hC/qdUuLCfS41xamrUe4z9pSLMqA/RMb3kK5WEFNNHOCTLX5f6xwfE\
Rlge7YZIBAu3HnnbzSh/QXP14guwwnf4gCFFkJVcAOtw8//da3qk1tnWOJ5QzgKnf2QAD+vrBm9gds\
8GzB0K/4aii/LZ5GLCGMldMFrYVF8iMocdW0f+tcxoFrVPLSC6K9fZuXmmpUMtkQ0chFPopBK/SKp+\
O98dL/JHDh54cwm1CuYM8u9Ct/+d0WHSIDkuKgYDK6EWlQRlOSLrYBm4uA7V/hYcJW4BJvgww8CacX\
Y+lWUmFe1wlTamlDHWAofJsZSD8HRQ4VyykIxZunD2QpcLgRVKeWyMr/zpJVkNTnRo2GxxZzAbc9fo\
d7AKkWEvxFrbu2FqZxWF8Ps+UZPV6YOeS3KU9I1kCVyY4Yfo/Qw3dcbTsTRdJQ28M+Q13OAbEzRCuK\
rQr36LtFAqBAg1q6NE7sSXmdCZFyBJe5qCQUTFtweDOyambGr99JUvdeXGCCxAF3KS7tmVp1S3iio9\
lHIvVfdCpAgSeBlOMzEskWLu6nyNqU8Js11mL4bDVfOxU10XEAa9Jz9BQLhs/kZZ+gzfkjfgP49euC\
43AOfPGOG8recpvqfdMYTeXO5E5T6H8UEbG3iK5/DSoHhMyaUoB7Z3KC5BOSymya/zXiahxQYlagx3\
wrwSzuHc1W22OjdbZ0rQmVTmFtK/gTRSj32J8xXs/GRvD8gTW4thvu90HT4nFLeC3KwXnRkD4L9A3f\
hh4OdXkuk3qlp3BGliUvr5Vj1GOva7i2RuokMVPwHwmMieh59+MKjMdwEVpCdMzEgzHcosL0MbE6Bv\
n48fHd7W3adHoAJmYMeyHMxkqzfS09H8JXKOk5t29A+OcANO7C3BAz3a+7L+mohD7tLOC65DT/vrI4\
nLIm059zwBDTZpIuDU0gI2XoVMeB/QugU4B0b1UjgTeuEzOLbHigV0SN9KoYpnnLKSus2t+mzHn+gM\
NJ4zCAlOnV+5I1kfKemv8V8mSg/2gDRuHISbsio6v+6ttJGPqDgZ4sPTxkX4799X8qos9gtrAC947n\
Vv73n0YqkWiRzUWqURU9T+hJDSKfLmALAWe8LxQnTAI5h0dh8rYFN0wqPsdku9kRa5Y/SYjGrmrfE8\
ybwUl4NFbT4hhYgRR00n8H0XjlEpP1C1c5u0a2v5w2iBFhCusMpjO5Y9DhTboVVWS/yNXN4UbjXxif\
fB2lFOr2g+aNkPS42dT6jJ0fmgUj/gkTaAjofhRm7YXlBx0JkOGnE8EJNODLJlCFouaPDkH/z7Vpvf\
XhDjXY3qehh5I7H9q3Gce+e+4Z25LiNFzzPqwOwhoccFGFLXpFlyfK5W6/WWONx1j7E9j2OqjoDpq4\
01OZ+scgvAkfret5ItSWL9QVVrW00u+ejexm1+6r7Eq1c/Nc6QVtrWaVdzhBQ5QqZKIwqdDfgogFD5\
9hXys3qiGeO4TRo0URGcrTEFWO97pSI8dzOGlgcaVsdFNr6dJJ7aE/loTKZ4my1l2u80wzt/qSdM9B\
dr5iASYnYLfc2aiUN3loJn7eDKW+7z/HnIADZ1n0C2bZK1OZrQBojFejGwroNvIR84hkrK5gElMJ/R\
YjT/Zvs7/d0kfCBy6+Ls4tO29kreCOrHvk2ZnMSLmrCX5axJupcHz2ZHjLN1KnzFc5MbE1gek2HOLI\
KxDBy6CblVdZ3SEX2T3a9/EuSSbcatO9opvOzCVHHVwaIk/vaCTRPFWE8nYltR4zocJoHLAS7IB+nL\
f+MTGQnt+MlGAMj52EkyY/uI4+2bz4Ce8WwRmlOBGFck1Wv38wNRqPdHrvXmtxXPnH7U3sbX2xq7KA\
JBXOVEmU7bXiXUR7Yw/Kq4K4gRXSoh0ym7iwn1s5YC6RTqtY9aAt1XIZR7Z7WskKPA51j7AUq9g0xn\
04k7ufNL36QtnilIq4wyHsT8UixYupaM8wOyXdh/vb3RyoOugmDBQrS7sJrapWvoX7k/qXE3ZwQust\
hSMUnJWFOEHlS0l4ZIKr5maY7TLdyilSuFPJKsESzAe6jyDZmxiCO+N08b+giAfAPlVE3I0HAf1FfO\
fuytkFQ6OgbZJzwrAL+iMICEo65+wAMg7W0yAsaGQKlpfSing4p69TDLX3rFeefreeREaLXpvNwFD7\
Rzo+IOV4hueBrXoPbovc26nIcvo2TBvNFql4vXZpZe4iGrPMPl5apjEJCQjWlIRLMYmLuKHj6uh2Tj\
tNw7iTH5va8Z1btf3KBFY8pllJsm/iiG7FGcP2ABXR63SVChBkDkTbHLdvflcGy/7StV7/IYEkGjNl\
pwCAcMy0RgmE91FE3nDiioDkPZVs1lUF9T15ElwZbvCnLxIzLIH6Vjc285oMMBAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwyEA\
BIAAAATQAAAA0AAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVj\
ODIzL3RpZ2VyLTAuMS4wL3NyYy9saWIucnMHAAAABAAAAAQAAAB4AAAAbnVsbCBwb2ludGVyIHBhc3\
NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQg\
bGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAAABAAAAAAAAAAA1emAgAAEbmFtZQHK6YCAAN\
ABADZ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fc3RyaW5nX25ldzo6aGQ5ZjZmNjUzOTRjYjJhYWQB\
MXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDRlNTI2YThmMzFhZjQ1MDYCL3NoYTI6On\
NoYTUxMjo6c29mdDo6Y29tcHJlc3M6OmhlY2JhMjdhNzgzMTlmOTE2Ay9zaGEyOjpzaGEyNTY6OnNv\
ZnQ6OmNvbXByZXNzOjpoMzkzODkyZjYwM2UzMGVlZgQ2cmlwZW1kMzIwOjpibG9jazo6cHJvY2Vzc1\
9tc2dfYmxvY2s6OmgxMTE0MGYzNDZjMjBkYzEyBTZyaXBlbWQxNjA6OmJsb2NrOjpwcm9jZXNzX21z\
Z19ibG9jazo6aDYzZTVlNWNlYWZhZTlhZWQGC2NyZWF0ZV9oYXNoBytzaGExOjpjb21wcmVzczo6Y2\
9tcHJlc3M6Omg5ZDFiMmQ1ZDkxYjM4NzhhCDpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+\
OjptYWxsb2M6Omg4MTdkMGJkYmU3NDg5OTRkCSl0aWdlcjo6VGlnZXI6OmNvbXByZXNzOjpoZTI3NG\
M5ZGEwNmYzMWNiYgo2Ymxha2UzOjpwb3J0YWJsZTo6Y29tcHJlc3NfaW5fcGxhY2U6Omg4ZThhMGYz\
NmI2NmYxNjQxCz88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aG\
U4ZDRhZDI3YjJlNjI3ZTcMJ21kNTo6dXRpbHM6OmNvbXByZXNzOjpoNDVkOGYwOTM2OTk2NTk4MA0v\
bWQyOjpNZDJTdGF0ZTo6cHJvY2Vzc19ibG9jazo6aGExMDE5ZmViMzk2YWQ2NTMOMGJsYWtlMzo6Y2\
9tcHJlc3Nfc3VidHJlZV93aWRlOjpoMDNjMGRmMzEzZWRiMzgxNg84ZGxtYWxsb2M6OmRsbWFsbG9j\
OjpEbG1hbGxvYzxBPjo6ZnJlZTo6aDM3ZjJjY2IxMjYwODQ5YjYQL21kNDo6TWQ0U3RhdGU6OnByb2\
Nlc3NfYmxvY2s6Omg3YWMxYzZjNmIyOTY0ZDllEUFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9j\
PEE+OjpkaXNwb3NlX2NodW5rOjpoYjE5YmE0ZjU3Yzg2MmQxMhIrYmxha2UzOjpIYXNoZXI6OmZpbm\
FsaXplOjpoZTY2NzE0ZjVjNWU5OTcwMRMga2VjY2FrOjpmMTYwMDo6aDExYTgwOWMzMmI4MTEwMmQU\
LGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWQ6OmgzODFiN2M5ZWVmMDE1ZThiFQ5fX3J1c3RfcmVhbG\
xvYxZhPHNoYTI6OnNoYTUxMjo6U2hhNTEyIGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGly\
dHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoY2Q3NDBiNTQ4MTQ4ZDE4OBcxYmxha2UzOjpIYXNoZX\
I6Om1lcmdlX2N2X3N0YWNrOjpoMDNiNmQwNzlmN2I1NTE0YxhHPEQgYXMgZGlnZXN0OjpkeW5fZGln\
ZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aDU2YTBkZGZhYjEzM2EzYjIZRzxEIGFzIG\
RpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6OmhhOWFkM2FmZTc0\
N2I2NThhGkc8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2\
V0OjpoYjUwOTAwMjlmZTY0MGFhMhtZPHRpZ2VyOjpUaWdlciBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhl\
ZE91dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aDVhNmU1NTUxZTU5ZjA3YzYcI2Nvcm\
U6OmZtdDo6d3JpdGU6Omg5YjlhYTIzZTdkMzU3MDJjHTVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFk\
X2ludGVncmFsOjpoMDhlM2U1M2EwZGU1MTdhMR5hPHNoYTI6OnNoYTUxMjo6U2hhMzg0IGFzIGRpZ2\
VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoYjNmN2E1\
OWQ4ZjY5MmZlZh9CPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbm\
U6Omg5NWYxYTJjMTMzNWZlOWZlIEc8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46\
OmZpbmFsaXplX3Jlc2V0OjpoY2Q1ZDRhNDZiNjllZDEyMCFXPHNoYTE6OlNoYTEgYXMgZGlnZXN0Oj\
pmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6Omg3NmJlMjliNWU0\
MjgzY2E5IjRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFyYWxsZWw6OmhjMTE3M2JmNWE3ZGYwYz\
M3I0c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0Ojpo\
NzM0YTEwYzFhMWVkNjBmNCRBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW\
5hbGl6ZTo6aGNjZDE4ZWNjMmEyNzJhOWQlQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGln\
ZXN0Pjo6ZmluYWxpemU6OmhmNGM2MmFiOWYxYTEzNTI2JkE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3\
Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoNDUwN2Y0MDlmZjIzZTIwNCdHPEQgYXMgZGlnZXN0Ojpk\
eW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aDRmY2U4MWVjZWQ4ZWU2ZDQoRz\
xEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6OmhhYmE0\
ZDYxYjQ4NGYxMTFjKUE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaX\
plOjpoNjZlZjNiNDc5ZTAwNmQ4MCpBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+\
OjpmaW5hbGl6ZTo6aGE3OTNlNjc2ODJjMDQ1ZDMrQTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RH\
luRGlnZXN0Pjo6ZmluYWxpemU6Omg1MDE5YmZkMTM2ZDkyNjIzLEc8RCBhcyBkaWdlc3Q6OmR5bl9k\
aWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoOWZiZGRmOWQ2ZTE2OGRhNS1HPEQgYX\
MgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aGZmOTFlZWQ1\
OWE3OGJmN2QuRzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcm\
VzZXQ6OmgzNWIyODdhMDc1NGViZDFkL2E8c2hhMjo6c2hhMjU2OjpTaGEyNTYgYXMgZGlnZXN0Ojpm\
aXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6Omg3MTQwM2IxNzJmZT\
lmYWRiMEE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoZTE4\
ODgyYzM1MTFiZTU0NzFHPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbG\
l6ZV9yZXNldDo6aGEyZjYxOWJiYTVmZGVhOTEyMnNoYTI6OnNoYTUxMjo6RW5naW5lNTEyOjpmaW5p\
c2g6Omg1ZDdmZmFlN2MzYjA1MzU3MwxfX3J1c3RfYWxsb2M0QTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2\
VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmgxZjg2MDhhNDdlYzc0YjZiNUc8RCBhcyBkaWdlc3Q6\
OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoMzI3MjJmZDcwN2U4NzViZT\
ZBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aDFmN2Q5NjNj\
ZjRkOTAzZDA3QTxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6Om\
hlYTRhNTViY2I1NjEzZDlmOEE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZp\
bmFsaXplOjpoNWFhZDMzODkwNTA5MzUyNjlHPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaW\
dlc3Q+OjpmaW5hbGl6ZV9yZXNldDo6aDEyY2IzYTZmOGQ2OGZmN2M6RzxEIGFzIGRpZ2VzdDo6ZHlu\
X2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6Omg1MWQ1MmEzNDY1MDEyM2QyO0I8RC\
BhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDgxNTZiMDA2NTA3\
YzM1MGM8LWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpoNGExYWY4ZjZlYzY3NjU0Mj07PCZtdX\
QgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aDYwZjQ4N2UyY2VkMDA0MWY+RzxE\
IGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6Omg5NDNiYj\
I2MTc1NWMxZWRiP0c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXpl\
X3Jlc2V0OjpoOWY3ZjM5ZTU2NTk2ODRhN0BhPHNoYTI6OnNoYTI1Njo6U2hhMjI0IGFzIGRpZ2VzdD\
o6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoZmYyMjZiYTgz\
MWI4ZGQ1NEE/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6OmgxMj\
U2ZmM2ZGE0ZWE4MDVhQj88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0\
ZTo6aDE0MzdlZjg1Y2VhMjZlYzFDPzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pj\
o6dXBkYXRlOjpoMjI1ZjdiNjhlMWQ1ODkyNUQ/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5E\
aWdlc3Q+Ojp1cGRhdGU6Omg0YTdlODhiYTE3Mzg0MmUyRUE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3\
Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoOGRkY2Y3ZDg3N2YyYTcwMUZBPEQgYXMgZGlnZXN0Ojpk\
eW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aGY2YjJkYmZjMDc0MzJkMDhHQTxEIGFzIG\
RpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmgyOTdiMmQxMjFkZTM1MTE5\
SDdjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWRfaW5uZXI6Omg4OGEyYThiMzZiODU5MjZjSU\
c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplX3Jlc2V0OjpoN2Iy\
NTk3ZTVjOTQ1MDE4Y0pHPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbG\
l6ZV9yZXNldDo6aGIwNmYxYWM1MGYyNGNmNTFLL2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6\
OmhmMDQ2OTQzMWRhY2U0MDQ2TDJzaGEyOjpzaGEyNTY6OkVuZ2luZTI1Njo6ZmluaXNoOjpoODk4Nz\
ljNGZlYTNkNDQ1YU0wPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjZDNhNjgwYTEyZjA3\
N2I0TmE8cmlwZW1kMzIwOjpSaXBlbWQzMjAgYXMgZGlnZXN0OjpmaXhlZDo6Rml4ZWRPdXRwdXREaX\
J0eT46OmZpbmFsaXplX2ludG9fZGlydHk6Omg3NzA0NjVlN2YxMDZhNWM1T1s8c2hhMzo6U2hhM181\
MTIgYXMgZGlnZXN0OjpmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydH\
k6OmhiZWUxNjA2YmNmMjk5ZTFiUFw8c2hhMzo6S2VjY2FrNTEyIGFzIGRpZ2VzdDo6Zml4ZWQ6OkZp\
eGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoNjM0NWZmYmRkODVlODk2NlFBPE\
QgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aDJhMGJkMTYzNGZj\
ZWVmY2NSPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6Omg2NjY3ZG\
JjNTJiOTY0YzlhU0I8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9u\
ZTo6aDQxMTIxNjJlMWQxNGFmN2JUPzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pj\
o6dXBkYXRlOjpoNTM0ZjYzNGYzYWNmODJiYVU/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5E\
aWdlc3Q+Ojp1cGRhdGU6Omg4ZWQxYWYwMGM3MmZkMDdlVj88RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3\
Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aGM3ODAwYzA4ZjgwMzhiMzdXPzxEIGFzIGRpZ2VzdDo6ZHlu\
X2RpZ2VzdDo6RHluRGlnZXN0Pjo6dXBkYXRlOjpoMTE3NDAxNDAxZTg3YTcwMlg/PEQgYXMgZGlnZX\
N0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6Omg0ZWNiM2UzZjEwYWVjMjI4WT88RCBh\
cyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnVwZGF0ZTo6aDg4ZDk2MTUzODM3YzY2M2\
NaRzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemVfcmVzZXQ6Omgx\
MDE5NTBiZmFjZWVkN2Q0W0c8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbm\
FsaXplX3Jlc2V0OjpoODFhZTA3ZDA5MTdiNzNhOVxBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpE\
eW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aDYwNjI3NWI5NGIwZDk1NjhdQTxEIGFzIGRpZ2VzdDo6ZHluX2\
RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmhkYjk3OTFkZTc5ZGE4ZTgzXmE8cmlwZW1kMTYw\
OjpSaXBlbWQxNjAgYXMgZGlnZXN0OjpmaXhlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2\
ludG9fZGlydHk6OmgzMzEwZjQ1ZmI1NjJmM2FmX1w8c2hhMzo6S2VjY2FrMzg0IGFzIGRpZ2VzdDo6\
Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoZjZlZTdiZjI2ND\
EzODdmNmBbPHNoYTM6OlNoYTNfMzg0IGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+\
OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoNTQ5ZWI4YmI3MzAzMGNjYWE/PEQgYXMgZGlnZXN0OjpkeW\
5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojp1cGRhdGU6Omg0NGMwZTQ0ZmY3NDlmNTkxYkI8RCBhcyBkaWdl\
c3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDNlYjUyYTA1OWY2NTA5ZGZjQj\
xEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpoYjU3MjMxN2Mx\
MDdkNmQxZGRVPG1kNTo6TWQ1IGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW\
5hbGl6ZV9pbnRvX2RpcnR5OjpoNzIwN2Q4ZTYyY2IyMjE0NWVVPG1kNDo6TWQ0IGFzIGRpZ2VzdDo6\
Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoMmQ4ZmMzZjAyMz\
A5MzIxYmZBPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpmaW5hbGl6ZTo6aDli\
NmIzNDIwYmZhZGY5MDlnPzxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6dXBkYX\
RlOjpoNGE1MzA4NzNlOTc3OGE2N2g/PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+\
Ojp1cGRhdGU6OmhmNmIxYTliM2NmYWVlZmRmaVs8c2hhMzo6U2hhM18yNTYgYXMgZGlnZXN0OjpmaX\
hlZDo6Rml4ZWRPdXRwdXREaXJ0eT46OmZpbmFsaXplX2ludG9fZGlydHk6OmhjYTYxNDk0ZjUxNGEx\
NWZjalw8c2hhMzo6S2VjY2FrMjU2IGFzIGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+Oj\
pmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoN2Y0OTA0MjYxZTE0ZjA1M2tbPHNoYTM6OlNoYTNfMjI0IGFz\
IGRpZ2VzdDo6Zml4ZWQ6OkZpeGVkT3V0cHV0RGlydHk+OjpmaW5hbGl6ZV9pbnRvX2RpcnR5OjpoNW\
FkNDE2MWMzOTRiNzNjNGxcPHNoYTM6OktlY2NhazIyNCBhcyBkaWdlc3Q6OmZpeGVkOjpGaXhlZE91\
dHB1dERpcnR5Pjo6ZmluYWxpemVfaW50b19kaXJ0eTo6aGUzZjM5NzU2N2M4ODg1ZjltQTxEIGFzIG\
RpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6ZmluYWxpemU6OmhhMTczZmQzNjQzMzQ0MmNl\
bkE8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmZpbmFsaXplOjpoZjBjZTMzYz\
A2OWVlMmYwM29CPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6\
OmgxMWQ5MzBiMjkwOTBlZGFhcEI8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om\
JveF9jbG9uZTo6aGVjN2Q0NjJlYzBlNmNmOTlxbmdlbmVyaWNfYXJyYXk6OmltcGxzOjo8aW1wbCBj\
b3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6OkdlbmVyaWNBcnJheTxULE4+Pjo6Y2\
xvbmU6OmgwYTkxZDYxN2VlZDNhNGQ5ck5hbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2Vy\
dmU6OmRvX3Jlc2VydmVfYW5kX2hhbmRsZTo6aDMwNmI0NDRhYWViNWFkYzVzQjxEIGFzIGRpZ2VzdD\
o6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpoMjgzMzVkYzM4NmQ5MTY3OXRCPEQg\
YXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6Omg2OWQ4ZmVmZWQzZm\
JjMDM1dUI8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDVm\
NTQyMjJmYWJlZjk4M2J2QjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2\
Nsb25lOjpoOGNlNWExNzNjN2U4ZDUwYXdCPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdl\
c3Q+Ojpib3hfY2xvbmU6OmhmYTg2YzJmZWQ4MzNmNzFmeC5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2\
dyb3c6OmhmZjZhMjI0N2ViYjIxNzM1eW5nZW5lcmljX2FycmF5OjppbXBsczo6PGltcGwgY29yZTo6\
Y2xvbmU6OkNsb25lIGZvciBnZW5lcmljX2FycmF5OjpHZW5lcmljQXJyYXk8VCxOPj46OmNsb25lOj\
poNWFlM2RhOWY2ODg1ZjI5OXpCPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpi\
b3hfY2xvbmU6OmgwMGY5MWZlMGJjMGI3MmY1e0I8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bk\
RpZ2VzdD46OmJveF9jbG9uZTo6aDVkYThmMmM3MDYxY2NkYmN8QjxEIGFzIGRpZ2VzdDo6ZHluX2Rp\
Z2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpoNzE2YTljNTZhYTllMDkyN31CPEQgYXMgZGlnZX\
N0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Ojpib3hfY2xvbmU6Omg4ZWI1ZmQyMzU1MzI0NDlifkI8\
RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OmJveF9jbG9uZTo6aDlmY2QyODAyMj\
MxNmU1MDd/QjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym94X2Nsb25lOjpo\
YzlhNWRhZmRhYzA0M2EyMYABQjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6Ym\
94X2Nsb25lOjpoZTQxYzM0MTY1MWIzMWQwMIEBQjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHlu\
RGlnZXN0Pjo6Ym94X2Nsb25lOjpoZjAzNzkwNGY4NGMwNDhhZIIBLmNvcmU6OnJlc3VsdDo6dW53cm\
FwX2ZhaWxlZDo6aDI3ZjQzZDk5M2MzODY0YTGDAVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlF\
cnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYWYwNDdiNjQ3MDUwYjlhOYQBUDxhcn\
JheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6\
OmhjYzhlMzY1MDY0NTc5M2Q2hQE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+Oj\
pyZXNldDo6aDM4NzRmMDFkMzBkMjBiMzWGAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRp\
Z2VzdD46OnJlc2V0OjpoYzc2YmEwZTUyMGJiNGJkY4cBbmdlbmVyaWNfYXJyYXk6OmltcGxzOjo8aW\
1wbCBjb3JlOjpjbG9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6OkdlbmVyaWNBcnJheTxULE4+\
Pjo6Y2xvbmU6Omg3MjI2M2YxY2UxODhjNGZliAFuZ2VuZXJpY19hcnJheTo6aW1wbHM6OjxpbXBsIG\
NvcmU6OmNsb25lOjpDbG9uZSBmb3IgZ2VuZXJpY19hcnJheTo6R2VuZXJpY0FycmF5PFQsTj4+Ojpj\
bG9uZTo6aDdiMjhiOWE4NmU0NDkxZDaJAW5nZW5lcmljX2FycmF5OjppbXBsczo6PGltcGwgY29yZT\
o6Y2xvbmU6OkNsb25lIGZvciBnZW5lcmljX2FycmF5OjpHZW5lcmljQXJyYXk8VCxOPj46OmNsb25l\
OjpoOGFlNGU3YTk5OGNjMDczZYoBbmdlbmVyaWNfYXJyYXk6OmltcGxzOjo8aW1wbCBjb3JlOjpjbG\
9uZTo6Q2xvbmUgZm9yIGdlbmVyaWNfYXJyYXk6OkdlbmVyaWNBcnJheTxULE4+Pjo6Y2xvbmU6Omhh\
NjU4OWVlMTkzMjk4ZTFkiwFuZ2VuZXJpY19hcnJheTo6aW1wbHM6OjxpbXBsIGNvcmU6OmNsb25lOj\
pDbG9uZSBmb3IgZ2VuZXJpY19hcnJheTo6R2VuZXJpY0FycmF5PFQsTj4+OjpjbG9uZTo6aGQ3YWFj\
NmEwZDUzYTg5MDeMAUFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYW\
lsOjpoZWYzZTMzN2Q2ZTg1OWJiNI0BP2NvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4\
X2xlbl9mYWlsOjpoMTkyNTA1YTE1YWM0YjM0NY4BTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3\
B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoMTNiZjVhMGUxNDA3YjE0ZI8BNmNvcmU6\
OnBhbmlja2luZzo6cGFuaWNfYm91bmRzX2NoZWNrOjpoODA4YjUyNGFmMTc2NDBiMZABRDxjb3JlOj\
pmbXQ6OkFyZ3VtZW50cyBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg2ZjQzNDIwZjcwNzA3\
MTI2kQE9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoNzFlMjQ3ZG\
VjM2YyNjZmZpIBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6Omgz\
ODE0NjVhZjYwNjQxMDZlkwE3c3RkOjpwYW5pY2tpbmc6OnJ1c3RfcGFuaWNfd2l0aF9ob29rOjpoZT\
liZmUwMzIxOWQ3MTViYZQBOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6\
aGJlMTAwZDQ2NDRmYzA5M2aVATFjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWQ6OmhkOTAxMm\
ViNmM3NDhmYjJllgELZGlnZXN0X2hhc2iXATo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3\
cml0ZV9zdHI6Omg2OGI3NmIxZjk4ZDM2ZDg4mAEGbWVtY21wmQETX193YmdfZGVub2hhc2hfZnJlZZ\
oBC3VwZGF0ZV9oYXNomwFDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6d3JpdGVf\
cHJlZml4OjpoYWI4YzlkMDdmNDk3M2E4NJwBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRG\
lnZXN0Pjo6cmVzZXQ6OmgzMDc5MTNkMDU2ZTFlYzFinQEpY29yZTo6cGFuaWNraW5nOjpwYW5pYzo6\
aDJmZDM4NWE4ODdjOGJmMTOeAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46On\
Jlc2V0OjpoYTIzOGM2ZmM5NmY0ODgwOJ8BPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGln\
ZXN0Pjo6cmVzZXQ6OmhjOWRhMDQyZGVkNmFiNzZioAEGbWVtY3B5oQERcnVzdF9iZWdpbl91bndpbm\
SiARFfX3diaW5kZ2VuX21hbGxvY6MBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0\
Pjo6cmVzZXQ6OmhkMmM2NGQ0MTViMDJhMTE1pAE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW\
5EaWdlc3Q+OjpyZXNldDo6aGUwNDEyM2YxNGUzYTgwYjKlAT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdl\
c3Q6OkR5bkRpZ2VzdD46OnJlc2V0OjpoZWJhOGI5ZTg3OTUxMzM5ZaYBLWNvcmU6OnBhbmlja2luZz\
o6cGFuaWNfZm10OjpoYmYyMWEzZDRiYmI4MmJmOKcBSXN0ZDo6c3lzX2NvbW1vbjo6YmFja3RyYWNl\
OjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0cmFjZTo6aGYzMTA0OTE2OWJlZGExNzGoAQZtZW1zZXSpAT\
48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnJlc2V0OjpoMzY5NGMyNWMzY2Q5\
OWQyZaoBQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aD\
NlNmRiN2M2NzRlNzkyMDOrARJfX3diaW5kZ2VuX3JlYWxsb2OsATtjb3JlOjpwdHI6OmRyb3BfaW5f\
cGxhY2U8Ymxha2UzOjpIYXNoZXI+OjpoMWFlNmNlM2VjNjFjYzIwYa0BRTxibG9ja19wYWRkaW5nOj\
pQYWRFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNDE1OTMyZjRlY2QyM2Q5Mq4BPjxj\
b3JlOjpmbXQ6OkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhkY2ViYzBhMDM4NTBjYT\
MwrwEyY29yZTo6b3B0aW9uOjpPcHRpb248VD46OnVud3JhcDo6aDEzMzczODZlMzFlMDY5ZmKwATA8\
JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGU5OThkNmU3M2UyODU1OGKxATI8JlQgYXMgY2\
9yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNTZjMzY0MjYwNGI3MWUzNLIBD19fd2JpbmRnZW5fZnJl\
ZbMBNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDUxMzEyMDA0YTMxZjBlYTa0AT\
ljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDQ0YTUzM2EwODAzODg2NDG1\
AT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46OnJlc2V0OjpoMjBlZmJlODQ2Nm\
NhNDU1MLYBPjxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6cmVzZXQ6OmgzNTFl\
NmMwNGY4ZDA3MWRmtwE+PEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpyZXNldD\
o6aDViZjQ0Yjk2MzliZDRjMzG4AT48RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46\
OnJlc2V0OjpoNjRjYTNiMmQzZTY1ZDRkZrkBH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZX\
K6ATF3YXNtX2JpbmRnZW46Ol9fcnQ6OnRocm93X251bGw6Omg4NzZlNzY2NTk3MGNiMmE4uwEyd2Fz\
bV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDViMjBhMGI0ODAzNjM1NDK8AU5jb3JlOjpmbX\
Q6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHUzMj46OmZtdDo6aDg0ZjA3\
NmM1ZTVkODM5ZWW9ASp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aGQ4ZGEzZTgwOWIyNWNhYzS+AT\
E8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmhjOTA3ZjQwMzRkYmQwYTY0vwFEPEQgYXMg\
ZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpvdXRwdXRfc2l6ZTo6aDA5ZmZkOGZkZjE2ZT\
ExNjfAAUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpo\
MWZkYTdhZTFmNjA0NmE3ZsEBRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3\
V0cHV0X3NpemU6Omg3ZmEzNDJhOTEzNzc2YzZjwgFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpE\
eW5EaWdlc3Q+OjpvdXRwdXRfc2l6ZTo6aDgxMzA1OTVjMDE3MTRiMWPDAUQ8RCBhcyBkaWdlc3Q6Om\
R5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoM2Q3YjAxYjNjNTI5MjE1Y8QBRDxE\
IGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3V0cHV0X3NpemU6Omg3ODJiYzA2Yz\
U0NTdlM2NlxQFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpvdXRwdXRfc2l6\
ZTo6aDQwZjBmOTE1MWQ3MjliOWbGAUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD\
46Om91dHB1dF9zaXplOjpoNGNiZTc1NTE1ZjgxNTAwMMcBRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2Vz\
dDo6RHluRGlnZXN0Pjo6b3V0cHV0X3NpemU6Omg2NGNlMTRiMDA0OTI2NzkxyAFEPEQgYXMgZGlnZX\
N0OjpkeW5fZGlnZXN0OjpEeW5EaWdlc3Q+OjpvdXRwdXRfc2l6ZTo6aDgzNjZjMjZjZDY2ZDgxNTPJ\
AUQ8RCBhcyBkaWdlc3Q6OmR5bl9kaWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoMGFiNT\
YwY2NkZDZlNTY0MsoBRDxEIGFzIGRpZ2VzdDo6ZHluX2RpZ2VzdDo6RHluRGlnZXN0Pjo6b3V0cHV0\
X3NpemU6Omg0ZGY1ZTliZDM5NTRmMDJhywFEPEQgYXMgZGlnZXN0OjpkeW5fZGlnZXN0OjpEeW5EaW\
dlc3Q+OjpvdXRwdXRfc2l6ZTo6aDBhYWIzNzE0ZjBlNzlmMmLMAUQ8RCBhcyBkaWdlc3Q6OmR5bl9k\
aWdlc3Q6OkR5bkRpZ2VzdD46Om91dHB1dF9zaXplOjpoMzU3YjE3ZjM0YmRkMTA5ZM0BCnJ1c3RfcG\
FuaWPOATdzdGQ6OmFsbG9jOjpkZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6OmhjYzhmNmMxNGExY2Yw\
MjBhzwFvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waW\
VkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46OmgzZTliNzFhMDc5ZDE2ZTAz\
AO+AgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS41NS\
4wIChjOGRmY2ZlMDQgMjAyMS0wOS0wNikGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4GMC4yLjgx\
\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
const hexTable = new TextEncoder().encode("0123456789abcdef");
function encode(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode1(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
class Hash {
    #hash;
    #digested;
    constructor(algorithm){
        this.#hash = instantiate().create_hash(algorithm);
        this.#digested = false;
    }
    update(message) {
        let view;
        if (message instanceof Uint8Array) {
            view = message;
        } else if (typeof message === "string") {
            view = new TextEncoder().encode(message);
        } else if (ArrayBuffer.isView(message)) {
            view = new Uint8Array(message.buffer, message.byteOffset, message.byteLength);
        } else if (message instanceof ArrayBuffer) {
            view = new Uint8Array(message);
        } else {
            throw new Error("hash: `data` is invalid type");
        }
        const chunkSize = 65_536;
        const updateHash = instantiate().update_hash;
        for(let offset = 0; offset < view.byteLength; offset += chunkSize){
            updateHash(this.#hash, new Uint8Array(view.buffer, view.byteOffset + offset, Math.min(65_536, view.byteLength - offset)));
        }
        return this;
    }
    digest() {
        if (this.#digested) throw new Error("hash: already digested");
        this.#digested = true;
        return instantiate().digest_hash(this.#hash);
    }
    toString(format = "hex") {
        const finalized = new Uint8Array(this.digest());
        switch(format){
            case "hex":
                return new TextDecoder().decode(encode(finalized));
            case "base64":
                return encode1(finalized);
            default:
                throw new Error("hash: invalid format");
        }
    }
}
function createHash(algorithm) {
    return new Hash(algorithm);
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
class BytesList {
    #len = 0;
    #chunks = [];
    constructor(){}
    size() {
        return this.#len;
    }
    add(value, start = 0, end = value.byteLength) {
        if (value.byteLength === 0 || end - start === 0) {
            return;
        }
        checkRange(start, end, value.byteLength);
        this.#chunks.push({
            value,
            end,
            start,
            offset: this.#len
        });
        this.#len += end - start;
    }
    shift(n) {
        if (n === 0) {
            return;
        }
        if (this.#len <= n) {
            this.#chunks = [];
            this.#len = 0;
            return;
        }
        const idx = this.getChunkIndex(n);
        this.#chunks.splice(0, idx);
        const [chunk] = this.#chunks;
        if (chunk) {
            const diff = n - chunk.offset;
            chunk.start += diff;
        }
        let offset = 0;
        for (const chunk1 of this.#chunks){
            chunk1.offset = offset;
            offset += chunk1.end - chunk1.start;
        }
        this.#len = offset;
    }
    getChunkIndex(pos) {
        let max = this.#chunks.length;
        let min = 0;
        while(true){
            const i = min + Math.floor((max - min) / 2);
            if (i < 0 || this.#chunks.length <= i) {
                return -1;
            }
            const { offset , start , end  } = this.#chunks[i];
            const len = end - start;
            if (offset <= pos && pos < offset + len) {
                return i;
            } else if (offset + len <= pos) {
                min = i + 1;
            } else {
                max = i - 1;
            }
        }
    }
    get(i) {
        if (i < 0 || this.#len <= i) {
            throw new Error("out of range");
        }
        const idx = this.getChunkIndex(i);
        const { value , offset , start  } = this.#chunks[idx];
        return value[start + i - offset];
    }
    *iterator(start = 0) {
        const startIdx = this.getChunkIndex(start);
        if (startIdx < 0) return;
        const first = this.#chunks[startIdx];
        let firstOffset = start - first.offset;
        for(let i = startIdx; i < this.#chunks.length; i++){
            const chunk = this.#chunks[i];
            for(let j = chunk.start + firstOffset; j < chunk.end; j++){
                yield chunk.value[j];
            }
            firstOffset = 0;
        }
    }
    slice(start, end = this.#len) {
        if (end === start) {
            return new Uint8Array();
        }
        checkRange(start, end, this.#len);
        const result = new Uint8Array(end - start);
        const startIdx = this.getChunkIndex(start);
        const endIdx = this.getChunkIndex(end - 1);
        let written = 0;
        for(let i = startIdx; i < endIdx; i++){
            const chunk = this.#chunks[i];
            const len = chunk.end - chunk.start;
            result.set(chunk.value.subarray(chunk.start, chunk.end), written);
            written += len;
        }
        const last = this.#chunks[endIdx];
        const rest = end - start - written;
        result.set(last.value.subarray(last.start, last.start + rest), written);
        return result;
    }
    concat() {
        const result = new Uint8Array(this.#len);
        let sum = 0;
        for (const { value , start , end  } of this.#chunks){
            result.set(value.subarray(start, end), sum);
            sum += end - start;
        }
        return result;
    }
}
function checkRange(start, end, len) {
    if (start < 0 || len < start || end < 0 || len < end || end < start) {
        throw new Error("invalid range");
    }
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
    #tryGrowByReslice(n) {
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    }
    #reslice(len) {
        assert(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    readSync(p) {
        if (this.empty()) {
            this.reset();
            if (p.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy(this.#buf.subarray(this.#off), p);
        this.#off += nread;
        return nread;
    }
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = this.#grow(p.byteLength);
        return copy(p, this.#buf, m);
    }
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
    #grow(n1) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n1);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n1 <= Math.floor(c / 2) - m) {
            copy(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n1 > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n1, MAX_SIZE));
            copy(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n1, MAX_SIZE));
        return m;
    }
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
}
const DEFAULT_BUFFER_SIZE = 32 * 1024;
function readerFromStreamReader(streamReader) {
    const buffer = new Buffer();
    return {
        async read (p) {
            if (buffer.empty()) {
                const res = await streamReader.read();
                if (res.done) {
                    return null;
                }
                await writeAll(buffer, res.value);
            }
            return buffer.read(p);
        }
    };
}
async function readAll(r) {
    const buf = new Buffer();
    await buf.readFrom(r);
    return buf.bytes();
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
async function copy1(src, dst, options) {
    let n = 0;
    const bufSize = options?.bufSize ?? DEFAULT_BUFFER_SIZE;
    const b = new Uint8Array(bufSize);
    let gotEOF = false;
    while(gotEOF === false){
        const result = await src.read(b);
        if (result === null) {
            gotEOF = true;
        } else {
            let nwritten = 0;
            while(nwritten < result){
                nwritten += await dst.write(b.subarray(nwritten, result));
            }
            n += nwritten;
        }
    }
    return n;
}
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
BigInt(Number.MAX_SAFE_INTEGER);
new TextDecoder();
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1  } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;
const consoleLogger = {
    type: 'logger',
    log (args) {
        this.output('log', args);
    },
    warn (args) {
        this.output('warn', args);
    },
    error (args) {
        this.output('error', args);
    },
    output (type, args) {
        if (console && console[type]) console[type].apply(console, args);
    }
};
class Logger {
    constructor(concreteLogger, options = {}){
        this.init(concreteLogger, options);
    }
    init(concreteLogger, options = {}) {
        this.prefix = options.prefix || 'i18next:';
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
    }
    setDebug(bool) {
        this.debug = bool;
    }
    log(...args) {
        return this.forward(args, 'log', '', true);
    }
    warn(...args) {
        return this.forward(args, 'warn', '', true);
    }
    error(...args) {
        return this.forward(args, 'error', '');
    }
    deprecate(...args) {
        return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
    forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (typeof args[0] === 'string') args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
    }
    create(moduleName) {
        return new Logger(this.logger, {
            ...{
                prefix: `${this.prefix}:${moduleName}:`
            },
            ...this.options
        });
    }
}
const __default = new Logger();
class EventEmitter {
    constructor(){
        this.observers = {};
    }
    on(events, listener) {
        events.split(' ').forEach((event)=>{
            this.observers[event] = this.observers[event] || [];
            this.observers[event].push(listener);
        });
        return this;
    }
    off(event, listener) {
        if (!this.observers[event]) return;
        if (!listener) {
            delete this.observers[event];
            return;
        }
        this.observers[event] = this.observers[event].filter((l)=>l !== listener);
    }
    emit(event, ...args) {
        if (this.observers[event]) {
            const cloned = [].concat(this.observers[event]);
            cloned.forEach((observer)=>{
                observer(...args);
            });
        }
        if (this.observers['*']) {
            const cloned1 = [].concat(this.observers['*']);
            cloned1.forEach((observer)=>{
                observer.apply(observer, [
                    event,
                    ...args
                ]);
            });
        }
    }
}
function defer() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject)=>{
        res = resolve;
        rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
}
function makeString(object) {
    if (object == null) return '';
    return '' + object;
}
function copy2(a, s, t) {
    a.forEach((m)=>{
        if (s[m]) t[m] = s[m];
    });
}
function getLastOfPath(object, path, Empty) {
    function cleanKey(key) {
        return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
    }
    function canNotTraverseDeeper() {
        return !object || typeof object === 'string';
    }
    const stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
    while(stack.length > 1){
        if (canNotTraverseDeeper()) return {};
        const key = cleanKey(stack.shift());
        if (!object[key] && Empty) object[key] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key)) {
            object = object[key];
        } else {
            object = {};
        }
    }
    if (canNotTraverseDeeper()) return {};
    return {
        obj: object,
        k: cleanKey(stack.shift())
    };
}
function setPath(object, path, newValue) {
    const { obj , k  } = getLastOfPath(object, path, Object);
    obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
    const { obj , k  } = getLastOfPath(object, path, Object);
    obj[k] = obj[k] || [];
    if (concat) obj[k] = obj[k].concat(newValue);
    if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
    const { obj , k  } = getLastOfPath(object, path);
    if (!obj) return undefined;
    return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
    const value = getPath(data, key);
    if (value !== undefined) {
        return value;
    }
    return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
    for(const prop in source){
        if (prop !== '__proto__' && prop !== 'constructor') {
            if (prop in target) {
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                    if (overwrite) target[prop] = source[prop];
                } else {
                    deepExtend(target[prop], source[prop], overwrite);
                }
            } else {
                target[prop] = source[prop];
            }
        }
    }
    return target;
}
function regexEscape(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var _entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
};
function escape(data) {
    if (typeof data === 'string') {
        return data.replace(/[&<>"'\/]/g, (s)=>_entityMap[s]);
    }
    return data;
}
const isIE10 = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
const chars = [
    ' ',
    ',',
    '?',
    '!',
    ';'
];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
    nsSeparator = nsSeparator || '';
    keySeparator = keySeparator || '';
    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
    if (possibleChars.length === 0) return true;
    const r = new RegExp(`(${possibleChars.map((c)=>c === '?' ? '\\?' : c).join('|')})`);
    let matched = !r.test(key);
    if (!matched) {
        const ki = key.indexOf(keySeparator);
        if (ki > 0 && !r.test(key.substring(0, ki))) {
            matched = true;
        }
    }
    return matched;
}
function deepFind(obj, path, keySeparator = '.') {
    if (!obj) return undefined;
    if (obj[path]) return obj[path];
    const paths = path.split(keySeparator);
    let current = obj;
    for(let i = 0; i < paths.length; ++i){
        if (!current) return undefined;
        if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
            return undefined;
        }
        if (current[paths[i]] === undefined) {
            let j = 2;
            let p = paths.slice(i, i + j).join(keySeparator);
            let mix = current[p];
            while(mix === undefined && paths.length > i + j){
                j++;
                p = paths.slice(i, i + j).join(keySeparator);
                mix = current[p];
            }
            if (mix === undefined) return undefined;
            if (typeof mix === 'string') return mix;
            if (p && typeof mix[p] === 'string') return mix[p];
            const joinedPath = paths.slice(i + j).join(keySeparator);
            if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
            return undefined;
        }
        current = current[paths[i]];
    }
    return current;
}
class ResourceStore extends EventEmitter {
    constructor(data, options = {
        ns: [
            'translation'
        ],
        defaultNS: 'translation'
    }){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.data = data || {};
        this.options = options;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        if (this.options.ignoreJSONStructure === undefined) {
            this.options.ignoreJSONStructure = true;
        }
    }
    addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
        }
    }
    removeNamespaces(ns) {
        const index = this.options.ns.indexOf(ns);
        if (index > -1) {
            this.options.ns.splice(index, 1);
        }
    }
    getResource(lng, ns, key, options = {}) {
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path = [
            lng,
            ns
        ];
        if (key && typeof key !== 'string') path = path.concat(key);
        if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
        }
        const result = getPath(this.data, path);
        if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
    addResource(lng, ns, key, value, options = {
        silent: false
    }) {
        let keySeparator = this.options.keySeparator;
        if (keySeparator === undefined) keySeparator = '.';
        let path = [
            lng,
            ns
        ];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            value = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options.silent) this.emit('added', lng, ns, key, value);
    }
    addResources(lng, ns, resources, options = {
        silent: false
    }) {
        for(const m in resources){
            if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
                silent: true
            });
        }
        if (!options.silent) this.emit('added', lng, ns, resources);
    }
    addResourceBundle(lng, ns, resources, deep, overwrite, options = {
        silent: false
    }) {
        let path = [
            lng,
            ns
        ];
        if (lng.indexOf('.') > -1) {
            path = lng.split('.');
            deep = resources;
            resources = ns;
            ns = path[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path) || {};
        if (deep) {
            deepExtend(pack, resources, overwrite);
        } else {
            pack = {
                ...pack,
                ...resources
            };
        }
        setPath(this.data, path, pack);
        if (!options.silent) this.emit('added', lng, ns, resources);
    }
    removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit('removed', lng, ns);
    }
    hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== undefined;
    }
    getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS;
        if (this.options.compatibilityAPI === 'v1') return {
            ...{},
            ...this.getResource(lng, ns)
        };
        return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
        return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n = data && Object.keys(data) || [];
        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);
    }
    toJSON() {
        return this.data;
    }
}
const __default1 = {
    processors: {},
    addPostProcessor (module) {
        this.processors[module.name] = module;
    },
    handle (processors, value, key, options, translator) {
        processors.forEach((processor)=>{
            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
        });
        return value;
    }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
    constructor(services, options = {}){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        copy2([
            'resourceStore',
            'languageUtils',
            'pluralResolver',
            'interpolator',
            'backendConnector',
            'i18nFormat',
            'utils'
        ], services, this);
        this.options = options;
        if (this.options.keySeparator === undefined) {
            this.options.keySeparator = '.';
        }
        this.logger = __default.create('translator');
    }
    changeLanguage(lng) {
        if (lng) this.language = lng;
    }
    exists(key, options = {
        interpolation: {}
    }) {
        if (key === undefined || key === null) {
            return false;
        }
        const resolved = this.resolve(key, options);
        return resolved && resolved.res !== undefined;
    }
    extractFromKey(key, options) {
        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === undefined) nsSeparator = ':';
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        let namespaces = options.ns || this.options.defaultNS;
        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            const m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
                return {
                    key,
                    namespaces
                };
            }
            const parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
            key = parts.join(keySeparator);
        }
        if (typeof namespaces === 'string') namespaces = [
            namespaces
        ];
        return {
            key,
            namespaces
        };
    }
    translate(keys, options, lastKey) {
        if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
            options = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (!options) options = {};
        if (keys === undefined || keys === null) return '';
        if (!Array.isArray(keys)) keys = [
            String(keys)
        ];
        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        const { key , namespaces  } = this.extractFromKey(keys[keys.length - 1], options);
        const namespace = namespaces[namespaces.length - 1];
        const lng = options.lng || this.language;
        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng && lng.toLowerCase() === 'cimode') {
            if (appendNamespaceToCIMode) {
                const nsSeparator = options.nsSeparator || this.options.nsSeparator;
                return namespace + nsSeparator + key;
            }
            return key;
        }
        const resolved = this.resolve(keys, options);
        let res = resolved && resolved.res;
        const resUsedKey = resolved && resolved.usedKey || key;
        const resExactUsedKey = resolved && resolved.exactUsedKey || key;
        const resType = Object.prototype.toString.apply(res);
        const noObject = [
            '[object Number]',
            '[object Function]',
            '[object RegExp]'
        ];
        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
            if (!options.returnObjects && !this.options.returnObjects) {
                if (!this.options.returnedObjectHandler) {
                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                }
                return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
                    ...options,
                    ns: namespaces
                }) : `key '${key} (${this.language})' returned an object instead of string.`;
            }
            if (keySeparator) {
                const resTypeIsArray = resType === '[object Array]';
                const copy = resTypeIsArray ? [] : {};
                let newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                for(const m in res){
                    if (Object.prototype.hasOwnProperty.call(res, m)) {
                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;
                        copy[m] = this.translate(deepKey, {
                            ...options,
                            ...{
                                joinArrays: false,
                                ns: namespaces
                            }
                        });
                        if (copy[m] === deepKey) copy[m] = res[m];
                    }
                }
                res = copy;
            }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
            res = res.join(joinArrays);
            if (res) res = this.extendTranslation(res, keys, options, lastKey);
        } else {
            let usedDefault = false;
            let usedKey = false;
            const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            const hasDefaultValue = Translator.hasDefaultValue(options);
            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
            const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options.defaultValue;
            if (!this.isValidLookup(res) && hasDefaultValue) {
                usedDefault = true;
                res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
                usedKey = true;
                res = key;
            }
            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
                this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                if (keySeparator) {
                    const fk = this.resolve(key, {
                        ...options,
                        keySeparator: false
                    });
                    if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                }
                let lngs = [];
                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                    for(let i = 0; i < fallbackLngs.length; i++){
                        lngs.push(fallbackLngs[i]);
                    }
                } else if (this.options.saveMissingTo === 'all') {
                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                } else {
                    lngs.push(options.lng || this.language);
                }
                const send = (l, k, fallbackValue)=>{
                    if (this.options.missingKeyHandler) {
                        this.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : resForMissing, updateMissing, options);
                    } else if (this.backendConnector && this.backendConnector.saveMissing) {
                        this.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : resForMissing, updateMissing, options);
                    }
                    this.emit('missingKey', l, namespace, k, res);
                };
                if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                        lngs.forEach((language)=>{
                            this.pluralResolver.getSuffixes(language).forEach((suffix)=>{
                                send([
                                    language
                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
                            });
                        });
                    } else {
                        send(lngs, key, defaultValue);
                    }
                }
            }
            res = this.extendTranslation(res, keys, options, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        }
        return res;
    }
    extendTranslation(res, key, options, resolved, lastKey) {
        if (this.i18nFormat && this.i18nFormat.parse) {
            res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                resolved
            });
        } else if (!options.skipInterpolation) {
            if (options.interpolation) this.interpolator.init({
                ...options,
                ...{
                    interpolation: {
                        ...this.options.interpolation,
                        ...options.interpolation
                    }
                }
            });
            const skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
            let nestBef;
            if (skipOnVariables) {
                const nb = res.match(this.interpolator.nestingRegexp);
                nestBef = nb && nb.length;
            }
            let data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
            if (this.options.interpolation.defaultVariables) data = {
                ...this.options.interpolation.defaultVariables,
                ...data
            };
            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
            if (skipOnVariables) {
                const na = res.match(this.interpolator.nestingRegexp);
                const nestAft = na && na.length;
                if (nestBef < nestAft) options.nest = false;
            }
            if (options.nest !== false) res = this.interpolator.nest(res, (...args)=>{
                if (lastKey && lastKey[0] === args[0] && !options.context) {
                    this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
                    return null;
                }
                return this.translate(...args, key);
            }, options);
            if (options.interpolation) this.interpolator.reset();
        }
        const postProcess = options.postProcess || this.options.postProcess;
        const postProcessorNames = typeof postProcess === 'string' ? [
            postProcess
        ] : postProcess;
        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
            res = __default1.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
                i18nResolved: resolved,
                ...options
            } : options, this);
        }
        return res;
    }
    resolve(keys, options = {}) {
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (typeof keys === 'string') keys = [
            keys
        ];
        keys.forEach((k)=>{
            if (this.isValidLookup(found)) return;
            const extracted = this.extractFromKey(k, options);
            const key = extracted.key;
            usedKey = key;
            let namespaces = extracted.namespaces;
            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
            const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
            const needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
            namespaces.forEach((ns)=>{
                if (this.isValidLookup(found)) return;
                usedNS = ns;
                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;
                    this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                }
                codes.forEach((code)=>{
                    if (this.isValidLookup(found)) return;
                    usedLng = code;
                    let finalKey = key;
                    const finalKeys = [
                        finalKey
                    ];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                    } else {
                        let pluralSuffix;
                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
                        if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
                        if (needsContextHandling) finalKeys.push(finalKey += `${this.options.contextSeparator}${options.context}`);
                        if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
                    }
                    let possibleKey;
                    while(possibleKey = finalKeys.pop()){
                        if (!this.isValidLookup(found)) {
                            exactUsedKey = possibleKey;
                            found = this.getResource(code, ns, possibleKey, options);
                        }
                    }
                });
            });
        });
        return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
        };
    }
    isValidLookup(res) {
        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
    getResource(code, ns, key, options = {}) {
        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
        return this.resourceStore.getResource(code, ns, key, options);
    }
    static hasDefaultValue(options) {
        const prefix = 'defaultValue';
        for(const option in options){
            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
                return true;
            }
        }
        return false;
    }
}
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
class LanguageUtil {
    constructor(options){
        this.options = options;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = __default.create('languageUtils');
    }
    getScriptPartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return null;
        const p = code.split('-');
        if (p.length === 2) return null;
        p.pop();
        if (p[p.length - 1].toLowerCase() === 'x') return null;
        return this.formatLanguageCode(p.join('-'));
    }
    getLanguagePartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return code;
        const p = code.split('-');
        return this.formatLanguageCode(p[0]);
    }
    formatLanguageCode(code) {
        if (typeof code === 'string' && code.indexOf('-') > -1) {
            const specialCases = [
                'hans',
                'hant',
                'latn',
                'cyrl',
                'cans',
                'mong',
                'arab'
            ];
            let p = code.split('-');
            if (this.options.lowerCaseLng) {
                p = p.map((part)=>part.toLowerCase());
            } else if (p.length === 2) {
                p[0] = p[0].toLowerCase();
                p[1] = p[1].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
            } else if (p.length === 3) {
                p[0] = p[0].toLowerCase();
                if (p[1].length === 2) p[1] = p[1].toUpperCase();
                if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
            }
            return p.join('-');
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
    isSupportedCode(code) {
        if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
    getBestMatchFromCodes(codes) {
        if (!codes) return null;
        let found;
        codes.forEach((code)=>{
            if (found) return;
            let cleanedLng = this.formatLanguageCode(code);
            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
            codes.forEach((code)=>{
                if (found) return;
                let lngOnly = this.getLanguagePartFromCode(code);
                if (this.isSupportedCode(lngOnly)) return found = lngOnly;
                found = this.options.supportedLngs.find((supportedLng)=>{
                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
                });
            });
        }
        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
    }
    getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
        if (typeof fallbacks === 'string') fallbacks = [
            fallbacks
        ];
        if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
        if (!code) return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found) found = fallbacks.default;
        return found || [];
    }
    toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c)=>{
            if (!c) return;
            if (this.isSupportedCode(c)) {
                codes.push(c);
            } else {
                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
            }
        };
        if (typeof code === 'string' && code.indexOf('-') > -1) {
            if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
            if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === 'string') {
            addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc)=>{
            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
        });
        return codes;
    }
}
let sets = [
    {
        lngs: [
            'ach',
            'ak',
            'am',
            'arn',
            'br',
            'fil',
            'gun',
            'ln',
            'mfe',
            'mg',
            'mi',
            'oc',
            'pt',
            'pt-BR',
            'tg',
            'tl',
            'ti',
            'tr',
            'uz',
            'wa'
        ],
        nr: [
            1,
            2
        ],
        fc: 1
    },
    {
        lngs: [
            'af',
            'an',
            'ast',
            'az',
            'bg',
            'bn',
            'ca',
            'da',
            'de',
            'dev',
            'el',
            'en',
            'eo',
            'es',
            'et',
            'eu',
            'fi',
            'fo',
            'fur',
            'fy',
            'gl',
            'gu',
            'ha',
            'hi',
            'hu',
            'hy',
            'ia',
            'it',
            'kk',
            'kn',
            'ku',
            'lb',
            'mai',
            'ml',
            'mn',
            'mr',
            'nah',
            'nap',
            'nb',
            'ne',
            'nl',
            'nn',
            'no',
            'nso',
            'pa',
            'pap',
            'pms',
            'ps',
            'pt-PT',
            'rm',
            'sco',
            'se',
            'si',
            'so',
            'son',
            'sq',
            'sv',
            'sw',
            'ta',
            'te',
            'tk',
            'ur',
            'yo'
        ],
        nr: [
            1,
            2
        ],
        fc: 2
    },
    {
        lngs: [
            'ay',
            'bo',
            'cgg',
            'fa',
            'ht',
            'id',
            'ja',
            'jbo',
            'ka',
            'km',
            'ko',
            'ky',
            'lo',
            'ms',
            'sah',
            'su',
            'th',
            'tt',
            'ug',
            'vi',
            'wo',
            'zh'
        ],
        nr: [
            1
        ],
        fc: 3
    },
    {
        lngs: [
            'be',
            'bs',
            'cnr',
            'dz',
            'hr',
            'ru',
            'sr',
            'uk'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 4
    },
    {
        lngs: [
            'ar'
        ],
        nr: [
            0,
            1,
            2,
            3,
            11,
            100
        ],
        fc: 5
    },
    {
        lngs: [
            'cs',
            'sk'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 6
    },
    {
        lngs: [
            'csb',
            'pl'
        ],
        nr: [
            1,
            2,
            5
        ],
        fc: 7
    },
    {
        lngs: [
            'cy'
        ],
        nr: [
            1,
            2,
            3,
            8
        ],
        fc: 8
    },
    {
        lngs: [
            'fr'
        ],
        nr: [
            1,
            2
        ],
        fc: 9
    },
    {
        lngs: [
            'ga'
        ],
        nr: [
            1,
            2,
            3,
            7,
            11
        ],
        fc: 10
    },
    {
        lngs: [
            'gd'
        ],
        nr: [
            1,
            2,
            3,
            20
        ],
        fc: 11
    },
    {
        lngs: [
            'is'
        ],
        nr: [
            1,
            2
        ],
        fc: 12
    },
    {
        lngs: [
            'jv'
        ],
        nr: [
            0,
            1
        ],
        fc: 13
    },
    {
        lngs: [
            'kw'
        ],
        nr: [
            1,
            2,
            3,
            4
        ],
        fc: 14
    },
    {
        lngs: [
            'lt'
        ],
        nr: [
            1,
            2,
            10
        ],
        fc: 15
    },
    {
        lngs: [
            'lv'
        ],
        nr: [
            1,
            2,
            0
        ],
        fc: 16
    },
    {
        lngs: [
            'mk'
        ],
        nr: [
            1,
            2
        ],
        fc: 17
    },
    {
        lngs: [
            'mnk'
        ],
        nr: [
            0,
            1,
            2
        ],
        fc: 18
    },
    {
        lngs: [
            'mt'
        ],
        nr: [
            1,
            2,
            11,
            20
        ],
        fc: 19
    },
    {
        lngs: [
            'or'
        ],
        nr: [
            2,
            1
        ],
        fc: 2
    },
    {
        lngs: [
            'ro'
        ],
        nr: [
            1,
            2,
            20
        ],
        fc: 20
    },
    {
        lngs: [
            'sl'
        ],
        nr: [
            5,
            1,
            2,
            3
        ],
        fc: 21
    },
    {
        lngs: [
            'he',
            'iw'
        ],
        nr: [
            1,
            2,
            20,
            21
        ],
        fc: 22
    }
];
let _rulesPluralsTypes = {
    1: function(n) {
        return Number(n > 1);
    },
    2: function(n) {
        return Number(n != 1);
    },
    3: function(n) {
        return 0;
    },
    4: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    5: function(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
    },
    6: function(n) {
        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
    },
    7: function(n) {
        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    8: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
    },
    9: function(n) {
        return Number(n >= 2);
    },
    10: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
    },
    11: function(n) {
        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
    },
    12: function(n) {
        return Number(n % 10 != 1 || n % 100 == 11);
    },
    13: function(n) {
        return Number(n !== 0);
    },
    14: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
    },
    15: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    16: function(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
    },
    17: function(n) {
        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
    },
    18: function(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
    },
    19: function(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
    },
    20: function(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
    },
    21: function(n) {
        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
    },
    22: function(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
    }
};
const deprecatedJsonVersions = [
    'v1',
    'v2',
    'v3'
];
const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
};
function createRules() {
    const rules = {};
    sets.forEach((set)=>{
        set.lngs.forEach((l)=>{
            rules[l] = {
                numbers: set.nr,
                plurals: _rulesPluralsTypes[set.fc]
            };
        });
    });
    return rules;
}
class PluralResolver {
    constructor(languageUtils, options = {}){
        this.languageUtils = languageUtils;
        this.options = options;
        this.logger = __default.create('pluralResolver');
        if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
            this.options.compatibilityJSON = 'v3';
            this.logger.error('Your environment seems not to be Inlt API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
        }
        this.rules = createRules();
    }
    addRule(lng, obj) {
        this.rules[lng] = obj;
    }
    getRule(code, options = {}) {
        if (this.shouldUseIntlApi()) {
            try {
                return new Intl.PluralRules(code, {
                    type: options.ordinal ? 'ordinal' : 'cardinal'
                });
            } catch  {
                return;
            }
        }
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
    needsPlural(code, options = {}) {
        const rule = this.getRule(code, options);
        if (this.shouldUseIntlApi()) {
            return rule && rule.resolvedOptions().pluralCategories.length > 1;
        }
        return rule && rule.numbers.length > 1;
    }
    getPluralFormsOfKey(code, key, options = {}) {
        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);
    }
    getSuffixes(code, options = {}) {
        const rule = this.getRule(code, options);
        if (!rule) {
            return [];
        }
        if (this.shouldUseIntlApi()) {
            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${pluralCategory}`);
        }
        return rule.numbers.map((number)=>this.getSuffix(code, number, options));
    }
    getSuffix(code, count, options = {}) {
        const rule = this.getRule(code, options);
        if (rule) {
            if (this.shouldUseIntlApi()) {
                return `${this.options.prepend}${rule.select(count)}`;
            }
            return this.getSuffixRetroCompatible(rule, count);
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return '';
    }
    getSuffixRetroCompatible(rule, count) {
        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        let suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
                suffix = 'plural';
            } else if (suffix === 1) {
                suffix = '';
            }
        }
        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
        if (this.options.compatibilityJSON === 'v1') {
            if (suffix === 1) return '';
            if (typeof suffix === 'number') return `_plural_${suffix.toString()}`;
            return returnSuffix();
        } else if (this.options.compatibilityJSON === 'v2') {
            return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
    shouldUseIntlApi() {
        return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
}
class Interpolator {
    constructor(options = {}){
        this.logger = __default.create('interpolator');
        this.options = options;
        this.format = options.interpolation && options.interpolation.format || ((value)=>value);
        this.init(options);
    }
    init(options = {}) {
        if (!options.interpolation) options.interpolation = {
            escapeValue: true
        };
        const iOpts = options.interpolation;
        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
        this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
        this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
        this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
        this.resetRegExp();
    }
    reset() {
        if (this.options) this.init(this.options);
    }
    resetRegExp() {
        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
        this.regexp = new RegExp(regexpStr, 'g');
        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
        this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
        this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
    interpolate(str, data, lng, options) {
        let match;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        function regexSafe(val) {
            return val.replace(/\$/g, '$$$$');
        }
        const handleFormat = (key)=>{
            if (key.indexOf(this.formatSeparator) < 0) {
                const path = getPathWithDefaults(data, defaultData, key);
                return this.alwaysFormat ? this.format(path, undefined, lng, {
                    ...options,
                    ...data,
                    interpolationkey: key
                }) : path;
            }
            const p = key.split(this.formatSeparator);
            const k = p.shift().trim();
            const f = p.join(this.formatSeparator).trim();
            return this.format(getPathWithDefaults(data, defaultData, k), f, lng, {
                ...options,
                ...data,
                interpolationkey: k
            });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        const todos = [
            {
                regex: this.regexpUnescape,
                safeValue: (val)=>regexSafe(val)
            },
            {
                regex: this.regexp,
                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
            }
        ];
        todos.forEach((todo)=>{
            replaces = 0;
            while(match = todo.regex.exec(str)){
                value = handleFormat(match[1].trim());
                if (value === undefined) {
                    if (typeof missingInterpolationHandler === 'function') {
                        const temp = missingInterpolationHandler(str, match, options);
                        value = typeof temp === 'string' ? temp : '';
                    } else if (skipOnVariables) {
                        value = match[0];
                        continue;
                    } else {
                        this.logger.warn(`missed to pass in variable ${match[1]} for interpolating ${str}`);
                        value = '';
                    }
                } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
                    value = makeString(value);
                }
                const safeValue = todo.safeValue(value);
                str = str.replace(match[0], safeValue);
                if (skipOnVariables) {
                    todo.regex.lastIndex += safeValue.length;
                    todo.regex.lastIndex -= match[0].length;
                } else {
                    todo.regex.lastIndex = 0;
                }
                replaces++;
                if (replaces >= this.maxReplaces) {
                    break;
                }
            }
        });
        return str;
    }
    nest(str, fc, options = {}) {
        let match;
        let value;
        let clonedOptions = {
            ...options
        };
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        function handleHasOptions(key, inheritedOptions) {
            const sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0) return key;
            const c = key.split(new RegExp(`${sep}[ ]*{`));
            let optionsString = `{${c[1]}`;
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            optionsString = optionsString.replace(/'/g, '"');
            try {
                clonedOptions = JSON.parse(optionsString);
                if (inheritedOptions) clonedOptions = {
                    ...inheritedOptions,
                    ...clonedOptions
                };
            } catch (e) {
                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
                return `${key}${sep}${optionsString}`;
            }
            delete clonedOptions.defaultValue;
            return key;
        }
        while(match = this.nestingRegexp.exec(str)){
            let formatters = [];
            let doReduce = false;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());
                match[1] = r.shift();
                formatters = r;
                doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && typeof value !== 'string') return value;
            if (typeof value !== 'string') value = makeString(value);
            if (!value) {
                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
                value = '';
            }
            if (doReduce) {
                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {
                        ...options,
                        interpolationkey: match[1].trim()
                    }), value.trim());
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
        }
        return str;
    }
}
function remove(arr, what) {
    let found = arr.indexOf(what);
    while(found !== -1){
        arr.splice(found, 1);
        found = arr.indexOf(what);
    }
}
class Connector extends EventEmitter {
    constructor(backend, store, services, options = {}){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.backend = backend;
        this.store = store;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options;
        this.logger = __default.create('backendConnector');
        this.state = {};
        this.queue = [];
        if (this.backend && this.backend.init) {
            this.backend.init(services, options.backend, options);
        }
    }
    queueLoad(languages, namespaces, options, callback) {
        const toLoad = [];
        const pending = [];
        const toLoadLanguages = [];
        const toLoadNamespaces = [];
        languages.forEach((lng)=>{
            let hasAllNamespaces = true;
            namespaces.forEach((ns)=>{
                const name = `${lng}|${ns}`;
                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
                    this.state[name] = 2;
                } else if (this.state[name] < 0) {} else if (this.state[name] === 1) {
                    if (pending.indexOf(name) < 0) pending.push(name);
                } else {
                    this.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending.indexOf(name) < 0) pending.push(name);
                    if (toLoad.indexOf(name) < 0) toLoad.push(name);
                    if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
                }
            });
            if (!hasAllNamespaces) toLoadLanguages.push(lng);
        });
        if (toLoad.length || pending.length) {
            this.queue.push({
                pending,
                loaded: {},
                errors: [],
                callback
            });
        }
        return {
            toLoad,
            pending,
            toLoadLanguages,
            toLoadNamespaces
        };
    }
    loaded(name, err, data) {
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        if (err) this.emit('failedLoading', lng, ns, err);
        if (data) {
            this.store.addResourceBundle(lng, ns, data);
        }
        this.state[name] = err ? -1 : 2;
        const loaded = {};
        this.queue.forEach((q)=>{
            pushPath(q.loaded, [
                lng
            ], ns);
            remove(q.pending, name);
            if (err) q.errors.push(err);
            if (q.pending.length === 0 && !q.done) {
                Object.keys(q.loaded).forEach((l)=>{
                    if (!loaded[l]) loaded[l] = [];
                    if (q.loaded[l].length) {
                        q.loaded[l].forEach((ns)=>{
                            if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
                        });
                    }
                });
                q.done = true;
                if (q.errors.length) {
                    q.callback(q.errors);
                } else {
                    q.callback();
                }
            }
        });
        this.emit('loaded', loaded);
        this.queue = this.queue.filter((q)=>!q.done);
    }
    read(lng, ns, fcName, tried = 0, wait = 350, callback) {
        if (!lng.length) return callback(null, {});
        return this.backend[fcName](lng, ns, (err, data)=>{
            if (err && data && tried < 5) {
                setTimeout(()=>{
                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
                }, wait);
                return;
            }
            callback(err, data);
        });
    }
    prepareLoading(languages, namespaces, options = {}, callback) {
        if (!this.backend) {
            this.logger.warn('No backend was added via i18next.use. Will not load resources.');
            return callback && callback();
        }
        if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === 'string') namespaces = [
            namespaces
        ];
        const toLoad = this.queueLoad(languages, namespaces, options, callback);
        if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length) callback();
            return null;
        }
        toLoad.toLoad.forEach((name)=>{
            this.loadOne(name);
        });
    }
    load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
    }
    reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
            reload: true
        }, callback);
    }
    loadOne(name, prefix = '') {
        const s = name.split('|');
        const lng = s[0];
        const ns = s[1];
        this.read(lng, ns, 'read', undefined, undefined, (err, data)=>{
            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
            this.loaded(name, err, data);
        });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}) {
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
            return;
        }
        if (key === undefined || key === null || key === '') return;
        if (this.backend && this.backend.create) {
            this.backend.create(languages, namespace, key, fallbackValue, null, {
                ...options,
                isUpdate
            });
        }
        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
}
function get() {
    return {
        debug: false,
        initImmediate: true,
        ns: [
            'translation'
        ],
        defaultNS: [
            'translation'
        ],
        fallbackLng: [
            'dev'
        ],
        fallbackNS: false,
        supportedLngs: false,
        nonExplicitSupportedLngs: false,
        load: 'all',
        preload: false,
        simplifyPluralSuffix: true,
        keySeparator: '.',
        nsSeparator: ':',
        pluralSeparator: '_',
        contextSeparator: '_',
        partialBundledLanguages: false,
        saveMissing: false,
        updateMissing: false,
        saveMissingTo: 'fallback',
        saveMissingPlurals: true,
        missingKeyHandler: false,
        missingInterpolationHandler: false,
        postProcess: false,
        postProcessPassResolved: false,
        returnNull: true,
        returnEmptyString: true,
        returnObjects: false,
        joinArrays: false,
        returnedObjectHandler: false,
        parseMissingKeyHandler: false,
        appendNamespaceToMissingKey: false,
        appendNamespaceToCIMode: false,
        overloadTranslationOptionHandler: function handle(args) {
            var ret = {};
            if (typeof args[1] === 'object') ret = args[1];
            if (typeof args[1] === 'string') ret.defaultValue = args[1];
            if (typeof args[2] === 'string') ret.tDescription = args[2];
            if (typeof args[2] === 'object' || typeof args[3] === 'object') {
                var options = args[3] || args[2];
                Object.keys(options).forEach(function(key) {
                    ret[key] = options[key];
                });
            }
            return ret;
        },
        interpolation: {
            escapeValue: true,
            format: (value, format, lng, options)=>value,
            prefix: '{{',
            suffix: '}}',
            formatSeparator: ',',
            unescapePrefix: '-',
            nestingPrefix: '$t(',
            nestingSuffix: ')',
            nestingOptionsSeparator: ',',
            maxReplaces: 1000,
            skipOnVariables: true
        }
    };
}
function transformOptions(options) {
    if (typeof options.ns === 'string') options.ns = [
        options.ns
    ];
    if (typeof options.fallbackLng === 'string') options.fallbackLng = [
        options.fallbackLng
    ];
    if (typeof options.fallbackNS === 'string') options.fallbackNS = [
        options.fallbackNS
    ];
    if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
        options.supportedLngs = options.supportedLngs.concat([
            'cimode'
        ]);
    }
    return options;
}
function noop() {}
class I18n extends EventEmitter {
    constructor(options = {}, callback){
        super();
        if (isIE10) {
            EventEmitter.call(this);
        }
        this.options = transformOptions(options);
        this.services = {};
        this.logger = __default;
        this.modules = {
            external: []
        };
        if (callback && !this.isInitialized && !options.isClone) {
            if (!this.options.initImmediate) {
                this.init(options, callback);
                return this;
            }
            setTimeout(()=>{
                this.init(options, callback);
            }, 0);
        }
    }
    init(options = {}, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (!options.defaultNS && options.ns) {
            if (typeof options.ns === 'string') {
                options.defaultNS = options.ns;
            } else if (options.ns.indexOf('translation') < 0) {
                options.defaultNS = options.ns[0];
            }
        }
        this.options = {
            ...get(),
            ...this.options,
            ...transformOptions(options)
        };
        if (options.keySeparator !== undefined) {
            this.options.userDefinedKeySeparator = options.keySeparator;
        }
        this.format = this.options.interpolation.format;
        if (!callback) callback = noop;
        function createClassOnDemand(ClassOrObject) {
            if (!ClassOrObject) return null;
            if (typeof ClassOrObject === 'function') return new ClassOrObject();
            return ClassOrObject;
        }
        if (!this.options.isClone) {
            if (this.modules.logger) {
                __default.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
                __default.init(null, this.options);
            }
            const lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            const s = this.services;
            s.logger = __default;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            s.interpolator = new Interpolator(this.options);
            s.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on('*', (event, ...args)=>{
                this.emit(event, ...args);
            });
            if (this.modules.languageDetector) {
                s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                if (s.i18nFormat.init) s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on('*', (event, ...args)=>{
                this.emit(event, ...args);
            });
            this.modules.external.forEach((m)=>{
                if (m.init) m.init(this);
            });
        }
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn('init: no languageDetector is used and no lng is defined');
        }
        const storeApi = [
            'getResource',
            'hasResourceBundle',
            'getResourceBundle',
            'getDataByLanguage'
        ];
        storeApi.forEach((fcName)=>{
            this[fcName] = (...args)=>this.store[fcName](...args);
        });
        const storeApiChained = [
            'addResource',
            'addResources',
            'addResourceBundle',
            'removeResourceBundle'
        ];
        storeApiChained.forEach((fcName)=>{
            this[fcName] = (...args)=>{
                this.store[fcName](...args);
                return this;
            };
        });
        const deferred = defer();
        const load = ()=>{
            const finish = (err, t)=>{
                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
                this.isInitialized = true;
                if (!this.options.isClone) this.logger.log('initialized', this.options);
                this.emit('initialized', this.options);
                deferred.resolve(t);
                callback(err, t);
            };
            if (this.languages && this.options.compatibilityAPI !== 'v1' && !this.isInitialized) return finish(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initImmediate) {
            load();
        } else {
            setTimeout(load, 0);
        }
        return deferred;
    }
    loadResources(language, callback = noop) {
        let usedCallback = callback;
        let usedLng = typeof language === 'string' ? language : this.language;
        if (typeof language === 'function') usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
            const toLoad = [];
            const append = (lng)=>{
                if (!lng) return;
                const lngs = this.services.languageUtils.toResolveHierarchy(lng);
                lngs.forEach((l)=>{
                    if (toLoad.indexOf(l) < 0) toLoad.push(l);
                });
            };
            if (!usedLng) {
                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                fallbacks.forEach((l)=>append(l));
            } else {
                append(usedLng);
            }
            if (this.options.preload) {
                this.options.preload.forEach((l)=>append(l));
            }
            this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
        } else {
            usedCallback(null);
        }
    }
    reloadResources(lngs, ns, callback) {
        const deferred = defer();
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback) callback = noop;
        this.services.backendConnector.reload(lngs, ns, (err)=>{
            deferred.resolve();
            callback(err);
        });
        return deferred;
    }
    use(module) {
        if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
        if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
        if (module.type === 'backend') {
            this.modules.backend = module;
        }
        if (module.type === 'logger' || module.log && module.warn && module.error) {
            this.modules.logger = module;
        }
        if (module.type === 'languageDetector') {
            this.modules.languageDetector = module;
        }
        if (module.type === 'i18nFormat') {
            this.modules.i18nFormat = module;
        }
        if (module.type === 'postProcessor') {
            __default1.addPostProcessor(module);
        }
        if (module.type === '3rdParty') {
            this.modules.external.push(module);
        }
        return this;
    }
    changeLanguage(lng, callback) {
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit('languageChanging', lng);
        const setLngProps = (l)=>{
            this.language = l;
            this.languages = this.services.languageUtils.toResolveHierarchy(l);
            this.resolvedLanguage = undefined;
            if ([
                'cimode',
                'dev'
            ].indexOf(l) > -1) return;
            for(let li = 0; li < this.languages.length; li++){
                const lngInLngs = this.languages[li];
                if ([
                    'cimode',
                    'dev'
                ].indexOf(lngInLngs) > -1) continue;
                if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                    this.resolvedLanguage = lngInLngs;
                    break;
                }
            }
        };
        const done = (err, l)=>{
            if (l) {
                setLngProps(l);
                this.translator.changeLanguage(l);
                this.isLanguageChangingTo = undefined;
                this.emit('languageChanged', l);
                this.logger.log('languageChanged', l);
            } else {
                this.isLanguageChangingTo = undefined;
            }
            deferred.resolve((...args)=>this.t(...args));
            if (callback) callback(err, (...args)=>this.t(...args));
        };
        const setLng = (lngs)=>{
            if (!lng && !lngs && this.services.languageDetector) lngs = [];
            const l = typeof lngs === 'string' ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
            if (l) {
                if (!this.language) {
                    setLngProps(l);
                }
                if (!this.translator.language) this.translator.changeLanguage(l);
                if (this.services.languageDetector) this.services.languageDetector.cacheUserLanguage(l);
            }
            this.loadResources(l, (err)=>{
                done(err, l);
            });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            this.services.languageDetector.detect(setLng);
        } else {
            setLng(lng);
        }
        return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
        const fixedT = (key, opts, ...rest)=>{
            let options;
            if (typeof opts !== 'object') {
                options = this.options.overloadTranslationOptionHandler([
                    key,
                    opts
                ].concat(rest));
            } else {
                options = {
                    ...opts
                };
            }
            options.lng = options.lng || fixedT.lng;
            options.lngs = options.lngs || fixedT.lngs;
            options.ns = options.ns || fixedT.ns;
            const keySeparator = this.options.keySeparator || '.';
            const resultKey = keyPrefix ? `${keyPrefix}${keySeparator}${key}` : key;
            return this.t(resultKey, options);
        };
        if (typeof lng === 'string') {
            fixedT.lng = lng;
        } else {
            fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
    }
    t(...args) {
        return this.translator && this.translator.translate(...args);
    }
    exists(...args) {
        return this.translator && this.translator.exists(...args);
    }
    setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns, options = {}) {
        if (!this.isInitialized) {
            this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
            return false;
        }
        if (!this.languages || !this.languages.length) {
            this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
            return false;
        }
        const lng = this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === 'cimode') return true;
        const loadNotPending = (l, n)=>{
            const loadState = this.services.backendConnector.state[`${l}|${n}`];
            return loadState === -1 || loadState === 2;
        };
        if (options.precheck) {
            const preResult = options.precheck(this, loadNotPending);
            if (preResult !== undefined) return preResult;
        }
        if (this.hasResourceBundle(lng, ns)) return true;
        if (!this.services.backendConnector.backend) return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
        return false;
    }
    loadNamespaces(ns, callback) {
        const deferred = defer();
        if (!this.options.ns) {
            callback && callback();
            return Promise.resolve();
        }
        if (typeof ns === 'string') ns = [
            ns
        ];
        ns.forEach((n)=>{
            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
        });
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    loadLanguages(lngs, callback) {
        const deferred = defer();
        if (typeof lngs === 'string') lngs = [
            lngs
        ];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0);
        if (!newLngs.length) {
            if (callback) callback();
            return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err)=>{
            deferred.resolve();
            if (callback) callback(err);
        });
        return deferred;
    }
    dir(lng) {
        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
        if (!lng) return 'rtl';
        const rtlLngs = [
            'ar',
            'shu',
            'sqr',
            'ssh',
            'xaa',
            'yhd',
            'yud',
            'aao',
            'abh',
            'abv',
            'acm',
            'acq',
            'acw',
            'acx',
            'acy',
            'adf',
            'ads',
            'aeb',
            'aec',
            'afb',
            'ajp',
            'apc',
            'apd',
            'arb',
            'arq',
            'ars',
            'ary',
            'arz',
            'auz',
            'avl',
            'ayh',
            'ayl',
            'ayn',
            'ayp',
            'bbz',
            'pga',
            'he',
            'iw',
            'ps',
            'pbt',
            'pbu',
            'pst',
            'prp',
            'prd',
            'ug',
            'ur',
            'ydd',
            'yds',
            'yih',
            'ji',
            'yi',
            'hbo',
            'men',
            'xmn',
            'fa',
            'jpr',
            'peo',
            'pes',
            'prs',
            'dv',
            'sam',
            'ckb'
        ];
        return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
    }
    createInstance(options = {}, callback) {
        return new I18n(options, callback);
    }
    cloneInstance(options = {}, callback = noop) {
        const mergedOptions = {
            ...this.options,
            ...options,
            ...{
                isClone: true
            }
        };
        const clone = new I18n(mergedOptions);
        const membersToCopy = [
            'store',
            'services',
            'language'
        ];
        membersToCopy.forEach((m)=>{
            clone[m] = this[m];
        });
        clone.services = {
            ...this.services
        };
        clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        clone.translator = new Translator(clone.services, clone.options);
        clone.translator.on('*', (event, ...args)=>{
            clone.emit(event, ...args);
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = clone.options;
        clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        return clone;
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        };
    }
}
const __default2 = new I18n();
const $XML = Symbol("x/xml");
const schema = {
    comment: "#comment",
    text: "#text",
    attribute: {
        prefix: "@"
    },
    property: {
        prefix: "@"
    }
};
const SeekMode = Object.freeze({
    Current: Deno?.SeekMode?.Current ?? 0,
    Start: Deno?.SeekMode?.Start ?? 1,
    End: Deno?.SeekMode?.End ?? 2
});
const entities = {
    xml: {
        "&lt;": "<",
        "&gt;": ">",
        "&apos;": "'",
        "&quot;": '"',
        "&amp;": "&"
    },
    char: {
        "&": "&amp;",
        '"': "&quot;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&apos;"
    }
};
const tokens = {
    entity: {
        regex: {
            entities: /&#(?<hex>x?)(?<code>\d+);/g
        }
    },
    prolog: {
        start: "<?xml",
        end: "?>"
    },
    doctype: {
        start: "<!DOCTYPE",
        end: ">",
        elements: {
            start: "[",
            end: "]"
        },
        element: {
            start: "<!ELEMENT",
            end: ">",
            value: {
                start: "(",
                end: ")",
                regex: {
                    end: {
                        until: /\)/,
                        bytes: 1
                    }
                }
            }
        }
    },
    comment: {
        start: "<!--",
        end: "-->",
        regex: {
            end: {
                until: /(?<!-)-->/,
                bytes: 4
            }
        }
    },
    cdata: {
        start: "<![CDATA[",
        end: "]]>",
        regex: {
            end: {
                until: /\]\]>/,
                bytes: 3
            }
        }
    },
    tag: {
        start: "<",
        end: ">",
        close: {
            start: "</",
            end: ">",
            self: "/",
            regex: {
                start: /<\//,
                end: /\/?>/
            }
        },
        attribute: {
            regex: {
                name: {
                    until: /=/,
                    bytes: 1
                }
            }
        },
        regex: {
            name: {
                until: /[\s\/>]/,
                bytes: 1
            },
            start: {
                until: /</,
                bytes: 1
            }
        }
    },
    text: {
        regex: {
            end: {
                until: /(<\/)|(<!)/,
                bytes: 2
            }
        }
    }
};
class Parser {
    constructor(stream, options = {}){
        this.#stream = stream;
        this.#options = options;
        this.#options.reviver ??= function({ value  }) {
            return value;
        };
    }
    parse() {
        return this.#document();
    }
    #options;
    #debug(path2, string) {
        if (this.#options.debug) {
            console.debug(`${path2.map((node)=>node[$XML].name).join(" > ")} | ${string}`.trim());
        }
    }
    #document() {
        const document = {};
        const path11 = [];
        const comments = [];
        let root = false;
        let clean;
        this.#trim();
        try {
            while(true){
                clean = true;
                if (this.#peek(tokens.comment.start)) {
                    clean = false;
                    comments.push(this.#comment({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.prolog.start)) {
                    if (document.xml) {
                        throw new SyntaxError("Multiple prolog declaration found");
                    }
                    clean = false;
                    Object.assign(document, this.#prolog({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.doctype.start)) {
                    if (document.doctype) {
                        throw new SyntaxError("Multiple doctype declaration found");
                    }
                    clean = false;
                    Object.assign(document, this.#doctype({
                        path: path11
                    }));
                    continue;
                }
                if (this.#peek(tokens.tag.start)) {
                    if (root) {
                        throw new SyntaxError("Multiple root elements found");
                    }
                    clean = false;
                    Object.assign(document, this.#node({
                        path: path11
                    }));
                    this.#trim();
                    root = true;
                    continue;
                }
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof && clean) {
                if (comments.length) {
                    document[schema.comment] = comments;
                }
                return document;
            }
            throw error;
        }
    }
    #node({ path: path21  }) {
        if (this.#options.progress) {
            this.#options.progress(this.#stream.cursor);
        }
        if (this.#peek(tokens.comment.start)) {
            return {
                [schema.comment]: this.#comment({
                    path: path21
                })
            };
        }
        return this.#tag({
            path: path21
        });
    }
    #prolog({ path: path3  }) {
        this.#debug(path3, "parsing prolog");
        const prolog = this.#make.node({
            name: "xml",
            path: path3
        });
        this.#consume(tokens.prolog.start);
        while(!this.#peek(tokens.prolog.end)){
            Object.assign(prolog, this.#attribute({
                path: [
                    ...path3,
                    prolog
                ]
            }));
        }
        this.#consume(tokens.prolog.end);
        return {
            xml: prolog
        };
    }
    #doctype({ path: path4  }) {
        this.#debug(path4, "parsing doctype");
        const doctype = this.#make.node({
            name: "doctype",
            path: path4
        });
        Object.defineProperty(doctype, $XML, {
            enumerable: false,
            writable: true
        });
        this.#consume(tokens.doctype.start);
        while(!this.#peek(tokens.doctype.end)){
            if (this.#peek(tokens.doctype.elements.start)) {
                this.#consume(tokens.doctype.elements.start);
                while(!this.#peek(tokens.doctype.elements.end)){
                    Object.assign(doctype, this.#doctypeElement({
                        path: path4
                    }));
                }
                this.#consume(tokens.doctype.elements.end);
            } else {
                Object.assign(doctype, this.#property({
                    path: path4
                }));
            }
        }
        this.#stream.consume({
            content: tokens.doctype.end
        });
        return {
            doctype
        };
    }
    #doctypeElement({ path: path5  }) {
        this.#debug(path5, "parsing doctype element");
        this.#consume(tokens.doctype.element.start);
        const element = Object.keys(this.#property({
            path: path5
        })).shift().substring(schema.property.prefix.length);
        this.#debug(path5, `found doctype element "${element}"`);
        this.#consume(tokens.doctype.element.value.start);
        const value = this.#capture(tokens.doctype.element.value.regex.end);
        this.#consume(tokens.doctype.element.value.end);
        this.#debug(path5, `found doctype element value "${value}"`);
        this.#consume(tokens.doctype.element.end);
        return {
            [element]: value
        };
    }
    #tag({ path: path6  }) {
        this.#debug(path6, "parsing tag");
        const tag = this.#make.node({
            path: path6
        });
        this.#consume(tokens.tag.start);
        const name = this.#capture(tokens.tag.regex.name);
        Object.assign(tag[$XML], {
            name
        });
        this.#debug(path6, `found tag "${name}"`);
        while(!tokens.tag.close.regex.end.test(this.#stream.peek(2))){
            Object.assign(tag, this.#attribute({
                path: [
                    ...path6,
                    tag
                ]
            }));
        }
        const selfclosed = this.#peek(tokens.tag.close.self);
        if (selfclosed) {
            this.#debug(path6, `tag "${name}" is self-closed`);
            this.#consume(tokens.tag.close.self);
        }
        this.#consume(tokens.tag.end);
        if (!selfclosed) {
            if (this.#peek(tokens.cdata.start) || !this.#peek(tokens.tag.start)) {
                Object.assign(tag, this.#text({
                    close: name,
                    path: [
                        ...path6,
                        tag
                    ]
                }));
            } else {
                while(!tokens.tag.close.regex.start.test(this.#stream.peek(2))){
                    const child = this.#node({
                        path: [
                            ...path6,
                            tag
                        ]
                    });
                    const [key, value1] = Object.entries(child).shift();
                    if (Array.isArray(tag[key])) {
                        tag[key].push(value1);
                        this.#debug([
                            ...path6,
                            tag
                        ], `add new child "${key}" to array`);
                    } else if (key in tag) {
                        const array = [
                            tag[key],
                            value1
                        ];
                        Object.defineProperty(array, $XML, {
                            enumerable: false,
                            writable: true
                        });
                        if (tag[key]?.[$XML]) {
                            Object.assign(array, {
                                [$XML]: tag[key][$XML]
                            });
                        }
                        tag[key] = array;
                        this.#debug([
                            ...path6,
                            tag
                        ], `multiple children named "${key}", using array notation`);
                    } else {
                        Object.assign(tag, child);
                        this.#debug([
                            ...path6,
                            tag
                        ], `add new child "${key}"`);
                    }
                }
            }
            this.#consume(tokens.tag.close.start);
            this.#consume(name);
            this.#consume(tokens.tag.close.end);
            this.#debug(path6, `found closing tag for "${name}"`);
        }
        for (const [key1] of Object.entries(tag).filter(([_, value])=>typeof value === "undefined")){
            delete tag[key1];
        }
        if (!Object.keys(tag).includes(schema.text)) {
            const children = Object.keys(tag).filter((key)=>!key.startsWith(schema.attribute.prefix) && key !== schema.text);
            if (!children.length) {
                this.#debug(path6, `tag "${name}" has implictely obtained a text node as it has no children but has attributes`);
                tag[schema.text] = this.#revive({
                    key: schema.text,
                    value: "",
                    tag
                });
            }
        }
        if ((this.#options.flatten ?? true) && Object.keys(tag).includes(schema.text) && Object.keys(tag).length === 1) {
            this.#debug(path6, `tag "${name}" has been implicitely flattened as it only has a text node`);
            return {
                [name]: tag[schema.text]
            };
        }
        return {
            [name]: tag
        };
    }
    #attribute({ path: path7  }) {
        this.#debug(path7, "parsing attribute");
        const attribute = this.#capture(tokens.tag.attribute.regex.name);
        this.#debug(path7, `found attribute "${attribute}"`);
        this.#consume("=");
        const quote = this.#stream.peek();
        this.#consume(quote);
        const value2 = this.#capture({
            until: new RegExp(quote),
            bytes: quote.length
        });
        this.#consume(quote);
        this.#debug(path7, `found attribute value "${value2}"`);
        return {
            [`${schema.attribute.prefix}${attribute}`]: this.#revive({
                key: `${schema.attribute.prefix}${attribute}`,
                value: value2,
                tag: path7.at(-1)
            })
        };
    }
    #property({ path: path8  }) {
        this.#debug(path8, "parsing property");
        const quote1 = this.#stream.peek();
        const delimiter3 = /["']/.test(quote1) ? quote1 : " ";
        if (delimiter3.trim().length) {
            this.#consume(delimiter3);
        }
        const property = this.#capture({
            until: new RegExp(delimiter3),
            bytes: delimiter3.length
        });
        this.#debug(path8, `found property ${property}`);
        if (delimiter3.trim().length) {
            this.#consume(delimiter3);
        }
        return {
            [`${schema.property.prefix}${property}`]: true
        };
    }
    #text({ close , path: path9  }) {
        this.#debug(path9, "parsing text");
        const tag1 = this.#make.node({
            name: schema.text,
            path: path9
        });
        let text = "";
        const comments1 = [];
        while(this.#peek(tokens.cdata.start) || !this.#peeks([
            tokens.tag.close.start,
            close,
            tokens.tag.close.end
        ])){
            if (this.#peek(tokens.cdata.start)) {
                text += this.#cdata({
                    path: [
                        ...path9,
                        tag1
                    ]
                });
            } else if (this.#peek(tokens.comment.start)) {
                comments1.push(this.#comment({
                    path: [
                        ...path9,
                        tag1
                    ]
                }));
            } else {
                text += this.#capture(tokens.text.regex.end);
                if (this.#peek(tokens.cdata.start) || this.#peek(tokens.comment.start)) {
                    continue;
                }
                if (!this.#peeks([
                    tokens.tag.close.start,
                    close,
                    tokens.tag.close.end
                ])) {
                    text += tokens.tag.close.start;
                    this.#consume(tokens.tag.close.start);
                }
            }
        }
        this.#debug(path9, `parsed text "${text}"`);
        if (comments1.length) {
            this.#debug(path9, `parsed comments ${JSON.stringify(comments1)}`);
        }
        Object.assign(tag1, {
            [schema.text]: this.#revive({
                key: schema.text,
                value: text.trim(),
                tag: path9.at(-1)
            }),
            ...comments1.length ? {
                [schema.comment]: comments1
            } : {}
        });
        return tag1;
    }
    #cdata({ path: path10  }) {
        this.#debug(path10, "parsing cdata");
        this.#consume(tokens.cdata.start);
        const data = this.#capture(tokens.cdata.regex.end);
        this.#consume(tokens.cdata.end);
        return data;
    }
    #comment({ path: path111  }) {
        this.#debug(path111, "parsing comment");
        this.#consume(tokens.comment.start);
        const comment = this.#capture(tokens.comment.regex.end);
        this.#consume(tokens.comment.end);
        return comment;
    }
    #revive({ key: key2 , value: value3 , tag: tag2  }) {
        return this.#options.reviver.call(tag2, {
            key: key2,
            tag: tag2[$XML].name,
            properties: !(key2.startsWith(schema.attribute.prefix) || key2.startsWith(schema.property.prefix)) ? {
                ...tag2
            } : null,
            value: (()=>{
                switch(true){
                    case (this.#options.emptyToNull ?? true) && /^\s*$/.test(value3):
                        return null;
                    case (this.#options.reviveBooleans ?? true) && /^(?:true|false)$/i.test(value3):
                        return /^true$/i.test(value3);
                    case (this.#options.reviveNumbers ?? true) && Number.isFinite(Number(value3)):
                        return Number.parseFloat(value3);
                    default:
                        value3 = value3.replace(tokens.entity.regex.entities, (_, hex, code)=>String.fromCharCode(parseInt(code, hex ? 16 : 10)));
                        for (const [entity, character] of Object.entries(entities.xml)){
                            value3 = value3.replaceAll(entity, character);
                        }
                        return value3;
                }
            })()
        });
    }
    #make = {
        node ({ name ="" , path =[]  }) {
            const node = {
                [$XML]: {
                    name,
                    parent: path[path.length - 1] ?? null
                }
            };
            Object.defineProperty(node, $XML, {
                enumerable: false,
                writable: true
            });
            return node;
        }
    };
    #stream;
    #peek(token) {
        return this.#stream.peek(token.length) === token;
    }
    #peeks(tokens1) {
        let offset = 0;
        for(let i1 = 0; i1 < tokens1.length; i1++){
            const token1 = tokens1[i1];
            while(true){
                if (/\s/.test(this.#stream.peek(1, offset))) {
                    offset++;
                    continue;
                }
                if (this.#stream.peek(token1.length, offset) === token1) {
                    offset += token1.length;
                    break;
                }
                return false;
            }
        }
        return true;
    }
    #consume(token2) {
        return this.#stream.consume({
            content: token2
        });
    }
    #capture(token3) {
        return this.#stream.capture(token3);
    }
    #trim() {
        return this.#stream.trim();
    }
}
class Stream {
    constructor(content){
        this.#content = content;
    }
    #decoder = new TextDecoder();
    #encoder = new TextEncoder();
    #content;
    get cursor() {
        return this.#content.seekSync(0, SeekMode.Current);
    }
    peek(bytes = 1, offset = 0) {
        const buffer = new Uint8Array(bytes);
        const cursor = this.cursor;
        if (offset) {
            this.#content.seekSync(offset, SeekMode.Current);
        }
        if (this.#content.readSync(buffer)) {
            this.#content.seekSync(cursor, SeekMode.Start);
            return this.#decoder.decode(buffer);
        }
        throw new Deno.errors.UnexpectedEof();
    }
    read(bytes = 1) {
        const buffer = new Uint8Array(bytes);
        if (this.#content.readSync(buffer)) {
            return buffer;
        }
        throw new Deno.errors.UnexpectedEof();
    }
    capture({ until , bytes , trim =true  }) {
        if (trim) {
            this.trim();
        }
        const buffer = [];
        while(!until.test(this.peek(bytes))){
            buffer.push(this.read(1)[0]);
        }
        if (trim) {
            this.trim();
        }
        return this.#decoder.decode(Uint8Array.from(buffer));
    }
    consume({ content , trim =true  }) {
        if (trim) {
            this.trim();
        }
        const bytes = this.#encoder.encode(content).length;
        if (content === this.peek(bytes)) {
            this.read(bytes);
            if (trim) {
                this.trim();
            }
            return;
        }
        throw new SyntaxError(`Expected next sequence to be "${content}", got "${this.peek(bytes)}" instead`);
    }
    trim() {
        try {
            while(/\s/.test(this.peek())){
                this.read(1);
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof) {
                return;
            }
            throw error;
        }
    }
}
class Streamable {
    constructor(string){
        this.#buffer = new TextEncoder().encode(string);
    }
    #buffer;
    #cursor = 0;
    readSync(buffer) {
        const bytes = this.#buffer.slice(this.#cursor, this.#cursor + buffer.length);
        buffer.set(bytes);
        this.#cursor = Math.min(this.#cursor + bytes.length, this.#buffer.length);
        return bytes.length || null;
    }
    seekSync(offset, whence) {
        switch(whence){
            case SeekMode.Start:
                this.#cursor = offset;
                break;
            case SeekMode.Current:
                this.#cursor += offset;
                break;
            case SeekMode.End:
                this.#cursor = this.#buffer.length + offset;
                break;
        }
        return this.#cursor;
    }
}
function parse3(content, options) {
    if (typeof content === "string") {
        content = new Streamable(content);
    }
    return new Parser(new Stream(content), options).parse();
}
const noColor1 = globalThis.Deno?.noColor ?? true;
let enabled1 = !noColor1;
function code1(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run1(str, code) {
    return enabled1 ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run1(str, code1([
        1
    ], 22));
}
function red(str) {
    return run1(str, code1([
        31
    ], 39));
}
function green(str) {
    return run1(str, code1([
        32
    ], 39));
}
function white(str) {
    return run1(str, code1([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run1(str, code1([
        90
    ], 39));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
].join("|"), "g");
var DiffType1;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i = 0; i < Math.min(A.length, B.length); i += 1){
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        } else {
            return common;
        }
    }
    return common;
}
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [
        B,
        A
    ] : [
        A,
        B
    ];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType1.common,
                    value: c
                })),
            ...A.map((a)=>({
                    type: swapped ? DiffType1.added : DiffType1.removed,
                    value: a
                })),
            ...suffixCommon.map((c)=>({
                    type: DiffType1.common,
                    value: c
                }))
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = new Array(size).fill({
        y: -1
    });
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type) break;
            const prev = j;
            if (type === 1) {
                result.unshift({
                    type: swapped ? DiffType1.removed : DiffType1.added,
                    value: B[b]
                });
                b -= 1;
            } else if (type === 3) {
                result.unshift({
                    type: swapped ? DiffType1.added : DiffType1.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType1.common,
                    value: A[a]
                });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev1 = down.id;
            ptr++;
            routes[ptr] = prev1;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k, M);
        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp[delta + offset].y < N){
        p = p + 1;
        for(let k = -p; k < delta; ++k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for(let k1 = delta + p; k1 > delta; --k1){
            fp[k1 + offset] = snake(k1, fp[k1 - 1 + offset], fp[k1 + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType1.common,
                value: c
            })),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c)=>({
                type: DiffType1.common,
                value: c
            }))
    ];
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError1 extends Error {
    constructor(message){
        super(message);
        this.name = "AssertionError";
    }
}
function _format1(v) {
    return globalThis.Deno ? Deno.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
function createColor(diffType) {
    switch(diffType){
        case DiffType1.added:
            return (s)=>green(bold(s));
        case DiffType1.removed:
            return (s)=>red(bold(s));
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType1.added:
            return "+   ";
        case DiffType1.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult) {
    const messages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        messages.push(c(`${createSign(result.type)}${result.value}`));
    });
    messages.push("");
    return messages;
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k)=>k in x);
}
function equal(c, d) {
    const seen = new Map();
    return function compare(a, b) {
        if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return a.getTime() === b.getTime();
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                return false;
            }
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b.entries()){
                        if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
                            unmatchedEntries--;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b
            };
            for(const key in merged){
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
            }
            seen.set(a, b);
            return true;
        }
        return false;
    }(c, d);
}
function assertNotEquals(actual, expected, msg) {
    if (!equal(actual, expected)) {
        return;
    }
    let actualString;
    let expectedString;
    try {
        actualString = String(actual);
    } catch (e) {
        actualString = "[Cannot display]";
    }
    try {
        expectedString = String(expected);
    } catch (e1) {
        expectedString = "[Cannot display]";
    }
    if (!msg) {
        msg = `actual: ${actualString} expected: ${expectedString}`;
    }
    throw new AssertionError1(msg);
}
function assertStrictEquals(actual, expected, msg) {
    if (actual === expected) {
        return;
    }
    let message;
    if (msg) {
        message = msg;
    } else {
        const actualString = _format1(actual);
        const expectedString = _format1(expected);
        if (actualString === expectedString) {
            const withOffset = actualString.split("\n").map((l)=>`    ${l}`).join("\n");
            message = `Values have the same structure but are not reference-equal:\n\n${red(withOffset)}\n`;
        } else {
            try {
                const diffResult = diff(actualString.split("\n"), expectedString.split("\n"));
                const diffMsg = buildMessage(diffResult).join("\n");
                message = `Values are not strictly equal:\n${diffMsg}`;
            } catch (e) {
                message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
            }
        }
    }
    throw new AssertionError1(message);
}
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1  } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const sep3 = "\\";
const delimiter4 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join4(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert2(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename3(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator1(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("\\", pathObject);
}
function parse4(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = {
    sep: sep3,
    delimiter: delimiter4,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join4,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep4 = "/";
const delimiter5 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join5(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename4(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("/", pathObject);
}
function parse5(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = {
    sep: sep4,
    delimiter: delimiter5,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join5,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path12 = isWindows1 ? mod2 : mod3;
const { join: join6 , normalize: normalize6  } = path12;
const path13 = isWindows1 ? mod2 : mod3;
const { basename: basename5 , delimiter: delimiter6 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join7 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5  } = path13;
'use strict';
const align = {
    right: alignRight,
    center: alignCenter
};
const right = 1;
const left = 3;
class UI {
    constructor(opts){
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg)=>{
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' && /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map((row)=>row.split('\t'));
        let leftColumnWidth = 0;
        rows.forEach((columns)=>{
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        rows.forEach((columns)=>{
            this.div(...columns.map((r, i)=>{
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [
            0,
            noAnsi.match(/\s*$/)[0].length,
            0,
            noAnsi.match(/^\s*/)[0].length
        ];
    }
    toString() {
        const lines = [];
        this.rows.forEach((row)=>{
            this.rowToString(row, lines);
        });
        return lines.filter((line)=>!line.hidden).map((line)=>line.text).join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r)=>{
            let str = '';
            rrow.forEach((col, c)=>{
                const { width  } = row[c];
                const wrapWidth = this.negatePadding(row[c]);
                let ts = col;
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                    }
                }
                const padding = row[c].padding || [
                    0,
                    0,
                    0,
                    0
                ];
                if (padding[3]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[1]) {
                    str += ' '.repeat(padding[right]);
                }
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c)=>{
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), {
                    hard: true
                }).split('\n');
            } else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[0] || 0).fill(''));
                wrapped.push(...new Array(col.padding[2] || 0).fill(''));
            }
            wrapped.forEach((str, r)=>{
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for(let i = 0; i < c; i++){
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map((col)=>{
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col)=>{
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i)=>{
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[3] || 0) + (padding[1] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat(width - strWidth >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}
const ansi = new RegExp('\x1b(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|' + '\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)', 'g');
function stripAnsi(str) {
    return str.replace(ansi, '');
}
function wrap(str, width) {
    const [start, end] = str.match(ansi) || [
        '',
        ''
    ];
    str = stripAnsi(str);
    let wrapped = '';
    for(let i = 0; i < str.length; i++){
        if (i !== 0 && i % width === 0) {
            wrapped += '\n';
        }
        wrapped += str.charAt(i);
    }
    if (start && end) {
        wrapped = `${start}${wrapped}${end}`;
    }
    return wrapped;
}
function ui(opts) {
    return cliui(opts, {
        stringWidth: (str)=>{
            return [
                ...str
            ].length;
        },
        stripAnsi,
        wrap
    });
}
function toItems(dir) {
    let list = [];
    for (let tmp of Deno.readDirSync(dir)){
        list.push(tmp.name);
    }
    return list;
}
function __default3(start, callback) {
    let dir = resolve5('.', start);
    let stats = Deno.statSync(dir);
    if (!stats.isDirectory) {
        dir = dirname5(dir);
    }
    while(true){
        let tmp = callback(dir, toItems(dir));
        if (tmp) return resolve5(dir, tmp);
        dir = dirname5(tmp = dir);
        if (tmp === dir) break;
    }
}
function camelCase(str) {
    str = str.toLocaleLowerCase();
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    } else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for(let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++){
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toLocaleUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
                continue;
            } else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLocaleLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for(let i = 0; i < str.length; i++){
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined) return false;
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    if (x.length > 1 && x[0] === '0') return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map((e)=>typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for(let ii = 0; ii < argString.length; ii++){
        prevC = c;
        c = argString.charAt(ii);
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        if (c === opening) {
            opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i]) args[i] = '';
        args[i] += c;
    }
    return args;
}
let mixin1;
class YargsParser {
    constructor(_mixin){
        mixin1 = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        const args = tokenizeArgString(argsInput);
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin1.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            const assignment = Object.keys(opt).map(function(key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value])=>{
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value])=>{
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function(key) {
                    flags.configs[key] = true;
                });
            } else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value])=>{
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
            (flags.aliases[key] || []).forEach(function(alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), {
            _: []
        });
        const argvReturn = {};
        for(let i = 0; i < args.length; i++){
            const arg = args[i];
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            if (arg !== '--' && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
            } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        i = eatNargs(i, m[1], args, m[2]);
                    } else {
                        setArg(m[1], m[2]);
                    }
                }
            } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [
                        false
                    ] : false);
                }
            } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    } else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    } else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        } else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        } else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            } else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
            } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    } else {
                        setArg(key, defaultValue(key));
                    }
                }
            } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for(let j = 0; j < letters.length; j++){
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            i = eatArray(i, key, args, value);
                        } else if (checkAllAliases(key, flags.nargs) !== false) {
                            i = eatNargs(i, key, args, value);
                        } else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    } else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    } else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    } else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        } else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        } else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            } else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            } else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            } else {
                pushPositional(arg);
            }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function(key) {
            if (!hasKey(argv, key.split('.'))) setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter((key)=>key !== '--' && key.includes('-')).forEach((key)=>{
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map((k)=>aliases[k])).forEach((alias)=>{
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map((prop)=>camelCase(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            } else {
                for(ii = i + 1; ii < args.length; ii++){
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;
                    else break;
                }
                if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for(ii = i + 1; ii < consumed + i + 1; ii++){
                setArg(key, args[ii]);
            }
            return i + consumed;
        }
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
                argsToSet.push(true);
            } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [
                        defVal
                    ];
                }
            } else {
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign));
                }
                for(let ii = i + 1; ii < args.length; ii++){
                    if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
                    i = ii;
                    argsToSet.push(processValue(key, next));
                }
            }
            if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function(prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function(x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function(x) {
                    let keyProperties = x.split('.');
                    const a = [].concat(splitKey);
                    a.shift();
                    keyProperties = keyProperties.concat(a);
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [
                    key
                ].concat(flags.aliases[key] || []);
                keys.forEach(function(key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get () {
                            return val;
                        },
                        set (value) {
                            val = typeof value === 'string' ? mixin1.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [
                    alias
                ];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val) {
            if (typeof val === 'string' && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
                val = val.substring(1, val.length - 1);
            }
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string') val = val === 'true';
            }
            let value = Array.isArray(val) ? val.map(function(v) {
                return maybeCoerceNumber(key, v);
            }) : maybeCoerceNumber(key, val);
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val)) value = val.map((val)=>{
                    return mixin1.normalize(val);
                });
                else value = mixin1.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_') return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
                if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
                    value = Number(value);
                }
            }
            return value;
        }
        function setConfig(argv) {
            const configLookup = Object.create(null);
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function(configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin1.resolve(mixin1.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            } catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        } else {
                            config = mixin1.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    } catch (ex) {
                        if (ex.name === 'PermissionDenied') error = ex;
                        else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function(key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    setConfigObject(value, fullKey);
                } else {
                    if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function(configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined') return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin1.env();
            Object.keys(env).forEach(function(envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    const keys = envVar.split('__').map(function(key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function(key) {
                if (!applied.has(key)) {
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            [].concat(flags.aliases[key] || [], key).forEach((ali)=>{
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        } catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key)=>{
                if (~key.indexOf('.')) return;
                if (typeof argv[key] === 'undefined') argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function(key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog) defaulted[key] = true;
                    (aliases[key] || []).forEach(function(x) {
                        if (hasKey(obj, x.split('.'))) return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation']) keys = [
                keys.join('.')
            ];
            keys.slice(0, -1).forEach(function(key) {
                o = o[key] || {};
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object') return false;
            else return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation']) keys = [
                keys.join('.')
            ];
            keys.slice(0, -1).forEach(function(key) {
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    } else {
                        o[key] = [
                            o[key],
                            {}
                        ];
                    }
                    o = o[key][o[key].length - 1];
                } else {
                    o = o[key];
                }
            });
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            } else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [
                        o[key]
                    ]).concat([
                        value
                    ]);
                } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                } else {
                    o[key] = o[key].concat([
                        value
                    ]);
                }
            } else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [
                    value
                ];
            } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
                o[key] = [
                    o[key],
                    value
                ];
            } else {
                o[key] = value;
            }
        }
        function extendAliases(...args) {
            args.forEach(function(obj) {
                Object.keys(obj || {}).forEach(function(key) {
                    if (flags.aliases[key]) return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    flags.aliases[key].concat(key).forEach(function(x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].concat(key).forEach(function(x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function(x) {
                        flags.aliases[x] = [
                            key
                        ].concat(flags.aliases[key].filter(function(y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find((key)=>keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map((k)=>flags[k]));
            return toCheck.some(function(flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function(pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        function hasAllShortFlags(arg) {
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for(let j = 0; j < letters.length; j++){
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            if (arg.match(negative)) {
                return false;
            }
            if (hasAllShortFlags(arg)) {
                return false;
            }
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            const normalFlag = /^-+([^=]+?)$/;
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
                return defaults[key];
            } else {
                return defaultForType(guessType(key));
            }
        }
        function defaultForType(type) {
            const def = {
                boolean: true,
                string: '',
                number: undefined,
                array: []
            };
            return def[type];
        }
        function guessType(key) {
            let type = 'boolean';
            if (checkAllAliases(key, flags.strings)) type = 'string';
            else if (checkAllAliases(key, flags.numbers)) type = 'number';
            else if (checkAllAliases(key, flags.bools)) type = 'boolean';
            else if (checkAllAliases(key, flags.arrays)) type = 'array';
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        function checkConfiguration() {
            Object.keys(flags.counts).find((key)=>{
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                } else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    while(change){
        change = false;
        for(let i = 0; i < aliasArrays.length; i++){
            for(let ii = i + 1; ii < aliasArrays.length; ii++){
                const intersect = aliasArrays[i].filter(function(v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
    if (key === '__proto__') return '___proto___';
    return key;
}
const parser = new YargsParser({
    cwd: Deno.cwd,
    env: ()=>{
        Deno.env.toObject();
    },
    format: (str, arg)=>{
        return str.replace('%s', arg);
    },
    normalize: mod3.normalize,
    resolve: mod3.resolve,
    require: (path)=>{
        if (!path.match(/\.json$/)) {
            throw Error('only .json config files are supported in Deno');
        } else {
            return JSON.parse(Deno.readTextFileSync(path));
        }
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function(args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
let shim;
class Y18N {
    constructor(opts){
        opts = opts || {};
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        this.cache = {};
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function() {};
        if (typeof args[args.length - 1] === 'function') cb = args.pop();
        cb = cb || function() {};
        if (!this.cache[this.locale]) this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        } else {
            cb();
        }
        return shim.format.apply(shim.format, [
            this.cache[this.locale][str] || str
        ].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {};
        if (typeof args[args.length - 1] === 'function') cb = args.pop();
        if (!this.cache[this.locale]) this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        } else {
            cb();
        }
        var values = [
            str
        ];
        if (~str.indexOf('%d')) values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale]) this._readLocaleFile();
        for(const key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function(part, i) {
            var arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [
            str
        ].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1) this._processWriteQueue();
    }
    _processWriteQueue() {
        var _this = this;
        var work = this.writeQueue[0];
        var directory = work.directory;
        var locale = work.locale;
        var cb = work.cb;
        var languageFile = this._resolveLocaleFile(directory, locale);
        var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function(err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0) _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        var localeLookup = {};
        var languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
        } catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT') localeLookup = {};
            else throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        var file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            var languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile)) file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim.exists(file);
    }
}
function y18n(opts, _shim) {
    shim = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = new Array(args.length);
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch (RangeError) {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return fractional;
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        fractional = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        e = e.length == 1 ? "0" + e : e;
        const val = `${m[F.mantissa]}.${fractional}${upcase ? "E" : "e"}${m[F.esign]}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        const dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        fractional = this.roundFractionToPrecision(fractional, precision);
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
const __default4 = {
    fs: {
        readFileSync: (path)=>{
            try {
                return Deno.readTextFileSync(path);
            } catch (err) {
                err.code = 'ENOENT';
                throw err;
            }
        },
        writeFile: Deno.writeFile
    },
    format: sprintf,
    resolve: (base, p1, p2)=>{
        try {
            return mod3.resolve(base, p1, p2);
        } catch (err) {}
    },
    exists: (file)=>{
        try {
            return Deno.statSync(file).isFile;
        } catch (err) {
            return false;
        }
    }
};
const y18n1 = (opts)=>{
    return y18n(opts, __default4);
};
class YError extends Error {
    constructor(msg){
        super(msg || 'yargs error');
        this.name = 'YError';
        Error.captureStackTrace(this, YError);
    }
}
const importMeta = {
    url: "file:///data/Projets/Logiciels/deno/Studio-Pack-Generator/vendor/deno.land/x/yargs@v17.2.1-deno/lib/platform-shims/deno.ts",
    main: false
};
const REQUIRE_ERROR = 'require is not supported by ESM';
const REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM';
const argv = [
    'deno run',
    ...Deno.args
];
const __dirname = new URL('.', importMeta.url).pathname;
let cwd = '';
let env = {};
try {
    env = Deno.env.toObject();
    cwd = Deno.cwd();
} catch (err) {
    if (err.name !== 'PermissionDenied') {
        throw err;
    }
}
const path14 = {
    basename: basename5,
    dirname: dirname5,
    extname: extname5,
    relative: (p1, p2)=>{
        try {
            return mod3.relative(p1, p2);
        } catch (err) {
            if (err.name !== 'PermissionDenied') {
                throw err;
            }
            return p1;
        }
    },
    resolve: mod3.resolve
};
const __default5 = {
    assert: {
        notStrictEqual: assertNotEquals,
        strictEqual: assertStrictEquals
    },
    cliui: ui,
    findUp: __default3,
    getEnv: (key)=>{
        return env[key];
    },
    inspect: Deno.inspect,
    getCallerFile: ()=>undefined,
    getProcessArgvBin: ()=>{
        return 'deno';
    },
    mainFilename: cwd,
    Parser: yargsParser,
    path: path14,
    process: {
        argv: ()=>argv,
        cwd: ()=>cwd,
        emitWarning: (warning, type)=>{},
        execPath: ()=>{
            try {
                return Deno.execPath();
            } catch (_err) {
                return 'deno';
            }
        },
        exit: Deno.exit,
        nextTick: window.queueMicrotask,
        stdColumns: 80 ?? null
    },
    readFileSync: Deno.readTextFileSync,
    require: ()=>{
        throw new YError(REQUIRE_ERROR);
    },
    requireDirectory: ()=>{
        throw new YError(REQUIRE_DIRECTORY_ERROR);
    },
    stringWidth: (str)=>{
        return [
            ...str
        ].length;
    },
    y18n: y18n1({
        directory: mod3.resolve(__dirname, '../../locales'),
        updateFiles: false
    })
};
function assertNotStrictEqual(actual, expected, shim, message) {
    shim.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim) {
    shim.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) {
    return Object.keys(object);
}
const completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
const completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
function isPromise(maybePromise) {
    return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === 'function';
}
function parseCommand(cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand) throw new Error(`No command found in: ${cmd}`);
    const parsedCommand = {
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: []
    };
    splitCommand.forEach((cmd, i)=>{
        let variadic = false;
        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;
        if (/^\[/.test(cmd)) {
            parsedCommand.optional.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic
            });
        } else {
            parsedCommand.demanded.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic
            });
        }
    });
    return parsedCommand;
}
const positionName = [
    'first',
    'second',
    'third',
    'fourth',
    'fifth',
    'sixth'
];
function argsert(arg1, arg2, arg3) {
    function parseArgs() {
        return typeof arg1 === 'object' ? [
            {
                demanded: [],
                optional: []
            },
            arg1,
            arg2
        ] : [
            parseCommand(`cmd ${arg1}`),
            arg2,
            arg3
        ];
    }
    try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while(args.length && args[args.length - 1] === undefined)args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach((demanded)=>{
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = demanded.cmd.filter((type)=>type === observedType || type === '*');
            if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);
            position += 1;
        });
        parsed.optional.forEach((optional)=>{
            if (args.length === 0) return;
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = optional.cmd.filter((type)=>type === observedType || type === '*');
            if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);
            position += 1;
        });
    } catch (err) {
        console.warn(err.stack);
    }
}
function guessType(arg) {
    if (Array.isArray(arg)) {
        return 'array';
    } else if (arg === null) {
        return 'null';
    }
    return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);
}
class GlobalMiddleware {
    constructor(yargs){
        this.globalMiddleware = [];
        this.frozens = [];
        this.yargs = yargs;
    }
    addMiddleware(callback, applyBeforeValidation, global = true, mutates = false) {
        argsert('<array|function> [boolean] [boolean] [boolean]', [
            callback,
            applyBeforeValidation,
            global
        ], arguments.length);
        if (Array.isArray(callback)) {
            for(let i = 0; i < callback.length; i++){
                if (typeof callback[i] !== 'function') {
                    throw Error('middleware must be a function');
                }
                const m = callback[i];
                m.applyBeforeValidation = applyBeforeValidation;
                m.global = global;
            }
            Array.prototype.push.apply(this.globalMiddleware, callback);
        } else if (typeof callback === 'function') {
            const m1 = callback;
            m1.applyBeforeValidation = applyBeforeValidation;
            m1.global = global;
            m1.mutates = mutates;
            this.globalMiddleware.push(callback);
        }
        return this.yargs;
    }
    addCoerceMiddleware(callback, option) {
        const aliases = this.yargs.getAliases();
        this.globalMiddleware = this.globalMiddleware.filter((m)=>{
            const toCheck = [
                ...aliases[option] || [],
                option
            ];
            if (!m.option) return true;
            else return !toCheck.includes(m.option);
        });
        callback.option = option;
        return this.addMiddleware(callback, true, true, true);
    }
    getMiddleware() {
        return this.globalMiddleware;
    }
    freeze() {
        this.frozens.push([
            ...this.globalMiddleware
        ]);
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        if (frozen !== undefined) this.globalMiddleware = frozen;
    }
    reset() {
        this.globalMiddleware = this.globalMiddleware.filter((m)=>m.global);
    }
}
function commandMiddlewareFactory(commandMiddleware) {
    if (!commandMiddleware) return [];
    return commandMiddleware.map((middleware)=>{
        middleware.applyBeforeValidation = false;
        return middleware;
    });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
    return middlewares.reduce((acc, middleware)=>{
        if (middleware.applyBeforeValidation !== beforeValidation) {
            return acc;
        }
        if (middleware.mutates) {
            if (middleware.applied) return acc;
            middleware.applied = true;
        }
        if (isPromise(acc)) {
            return acc.then((initialObj)=>Promise.all([
                    initialObj,
                    middleware(initialObj, yargs)
                ])).then(([initialObj, middlewareObj])=>Object.assign(initialObj, middlewareObj));
        } else {
            const result = middleware(acc, yargs);
            return isPromise(result) ? result.then((middlewareObj)=>Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
        }
    }, argv);
}
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err)=>{
    throw err;
}) {
    try {
        const result = isFunction(getResult) ? getResult() : getResult;
        return isPromise(result) ? result.then((result)=>resultHandler(result)) : resultHandler(result);
    } catch (err) {
        return errorHandler(err);
    }
}
function isFunction(arg) {
    return typeof arg === 'function';
}
function whichModule(exported) {
    if (typeof require === 'undefined') return null;
    for(let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++){
        mod = require.cache[files[i]];
        if (mod.exports === exported) return mod;
    }
    return null;
}
function objFilter(original = {}, filter = ()=>true) {
    const obj = {};
    objectKeys(original).forEach((key)=>{
        if (filter(key, original[key])) {
            obj[key] = original[key];
        }
    });
    return obj;
}
function setBlocking(blocking) {
    if (typeof process === 'undefined') return;
    [
        process.stdout,
        process.stderr
    ].forEach((_stream)=>{
        const stream = _stream;
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
            stream._handle.setBlocking(blocking);
        }
    });
}
function isBoolean(fail) {
    return typeof fail === 'boolean';
}
function usage(yargs, shim) {
    const __ = shim.y18n.__;
    const self = {};
    const fails = [];
    self.failFn = function failFn(f) {
        fails.push(f);
    };
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
            return typeof arg1 === 'string' ? [
                true,
                arg1
            ] : [
                arg1,
                arg2
            ];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (fails.length) {
            for(let i = fails.length - 1; i >= 0; --i){
                const fail = fails[i];
                if (isBoolean(fail)) {
                    if (err) throw err;
                    else if (msg) throw Error(msg);
                } else {
                    fail(msg, err, self);
                }
            }
        } else {
            if (yargs.getExitProcess()) setBlocking(true);
            if (!failureOutput) {
                failureOutput = true;
                if (showHelpOnFail) {
                    yargs.showHelp('error');
                    logger.error();
                }
                if (msg || err) logger.error(msg || err);
                if (failMessage) {
                    if (msg || err) logger.error('');
                    logger.error(failMessage);
                }
            }
            err = err || new YError(msg);
            if (yargs.getExitProcess()) {
                return yargs.exit(1);
            } else if (yargs.getInternalMethods().hasParseCallback()) {
                return yargs.exit(1, err);
            } else {
                throw err;
            }
        }
    };
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description)=>{
        if (msg === null) {
            usageDisabled = true;
            usages = [];
            return self;
        }
        usageDisabled = false;
        usages.push([
            msg,
            description || ''
        ]);
        return self;
    };
    self.getUsage = ()=>{
        return usages;
    };
    self.getUsageDisabled = ()=>{
        return usageDisabled;
    };
    self.getPositionalGroupName = ()=>{
        return __('Positionals:');
    };
    let examples = [];
    self.example = (cmd, description)=>{
        examples.push([
            cmd,
            description || ''
        ]);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
            commands = commands.map((cmdArray)=>{
                cmdArray[2] = false;
                return cmdArray;
            });
        }
        commands.push([
            cmd,
            description || '',
            isDefault,
            aliases,
            deprecated
        ]);
    };
    self.getCommands = ()=>commands;
    let descriptions = {};
    self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
            keyOrKeys.forEach((k)=>{
                self.describe(k, desc);
            });
        } else if (typeof keyOrKeys === 'object') {
            Object.keys(keyOrKeys).forEach((k)=>{
                self.describe(k, keyOrKeys[k]);
            });
        } else {
            descriptions[keyOrKeys] = desc;
        }
    };
    self.getDescriptions = ()=>descriptions;
    let epilogs = [];
    self.epilog = (msg)=>{
        epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = (cols)=>{
        wrapSet = true;
        wrap = cols;
    };
    function getWrap() {
        if (!wrapSet) {
            wrap = windowWidth();
            wrapSet = true;
        }
        return wrap;
    }
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = (str)=>deferY18nLookupPrefix + str;
    self.help = function help() {
        if (cachedHelpMessage) return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName ? yargs.$0 : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key)=>{
            if (key !== '_') acc[key] = true;
            return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = shim.cliui({
            width: theWrap,
            wrap: !!theWrap
        });
        if (!usageDisabled) {
            if (usages.length) {
                usages.forEach((usage)=>{
                    ui.div({
                        text: `${usage[0].replace(/\$0/g, base$0)}`
                    });
                    if (usage[1]) {
                        ui.div({
                            text: `${usage[1]}`,
                            padding: [
                                1,
                                0,
                                0,
                                0
                            ]
                        });
                    }
                });
                ui.div();
            } else if (commands.length) {
                let u = null;
                if (demandedCommands._) {
                    u = `${base$0} <${__('command')}>\n`;
                } else {
                    u = `${base$0} [${__('command')}]\n`;
                }
                ui.div(`${u}`);
            }
        }
        if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
            ui.div(__('Commands:'));
            const context = yargs.getInternalMethods().getContext();
            const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';
            if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] === true) {
                commands = commands.sort((a, b)=>a[0].localeCompare(b[0]));
            }
            const prefix = base$0 ? `${base$0} ` : '';
            commands.forEach((command)=>{
                const commandString = `${prefix}${parentCommands}${command[0].replace(/^\$0 ?/, '')}`;
                ui.span({
                    text: commandString,
                    padding: [
                        0,
                        2,
                        0,
                        2
                    ],
                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
                }, {
                    text: command[1]
                });
                const hints = [];
                if (command[2]) hints.push(`[${__('default')}]`);
                if (command[3] && command[3].length) {
                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);
                }
                if (command[4]) {
                    if (typeof command[4] === 'string') {
                        hints.push(`[${__('deprecated: %s', command[4])}]`);
                    } else {
                        hints.push(`[${__('deprecated')}]`);
                    }
                }
                if (hints.length) {
                    ui.div({
                        text: hints.join(' '),
                        padding: [
                            0,
                            0,
                            0,
                            2
                        ],
                        align: 'right'
                    });
                } else {
                    ui.div();
                }
            });
            ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter((key)=>!yargs.parsed.newAliases[key] && aliasKeys.every((alias)=>(options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup]) groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw)=>/^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups).filter((groupName)=>groups[groupName].length > 0).map((groupName)=>{
            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key)=>{
                if (aliasKeys.includes(key)) return key;
                for(let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++){
                    if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
                }
                return key;
            });
            return {
                groupName,
                normalizedKeys
            };
        }).filter(({ normalizedKeys  })=>normalizedKeys.length > 0).map(({ groupName , normalizedKeys  })=>{
            const switches = normalizedKeys.reduce((acc, key)=>{
                acc[key] = [
                    key
                ].concat(options.alias[key] || []).map((sw)=>{
                    if (groupName === self.getPositionalGroupName()) return sw;
                    else {
                        return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;
                    }
                }).sort((sw1, sw2)=>isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(', ');
                return acc;
            }, {});
            return {
                groupName,
                normalizedKeys,
                switches
            };
        });
        const shortSwitchesUsed = displayedGroups.filter(({ groupName  })=>groupName !== self.getPositionalGroupName()).some(({ normalizedKeys , switches  })=>!normalizedKeys.every((key)=>isLongSwitch(switches[key])));
        if (shortSwitchesUsed) {
            displayedGroups.filter(({ groupName  })=>groupName !== self.getPositionalGroupName()).forEach(({ normalizedKeys , switches  })=>{
                normalizedKeys.forEach((key)=>{
                    if (isLongSwitch(switches[key])) {
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                    }
                });
            });
        }
        displayedGroups.forEach(({ groupName , normalizedKeys , switches  })=>{
            ui.div(groupName);
            normalizedKeys.forEach((key)=>{
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (desc.includes(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (options.boolean.includes(key)) type = `[${__('boolean')}]`;
                if (options.count.includes(key)) type = `[${__('count')}]`;
                if (options.string.includes(key)) type = `[${__('string')}]`;
                if (options.normalize.includes(key)) type = `[${__('string')}]`;
                if (options.array.includes(key)) type = `[${__('array')}]`;
                if (options.number.includes(key)) type = `[${__('number')}]`;
                const deprecatedExtra = (deprecated)=>typeof deprecated === 'string' ? `[${__('deprecated: %s', deprecated)}]` : `[${__('deprecated')}]`;
                const extra = [
                    key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
                    type,
                    key in demandedOptions ? `[${__('required')}]` : null,
                    options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,
                    defaultString(options.default[key], options.defaultDescription[key])
                ].filter(Boolean).join(' ');
                ui.span({
                    text: getText(kswitch),
                    padding: [
                        0,
                        2,
                        0,
                        2 + getIndentation(kswitch)
                    ],
                    width: maxWidth(switches, theWrap) + 4
                }, desc);
                if (extra) ui.div({
                    text: extra,
                    padding: [
                        0,
                        0,
                        0,
                        2
                    ],
                    align: 'right'
                });
                else ui.div();
            });
            ui.div();
        });
        if (examples.length) {
            ui.div(__('Examples:'));
            examples.forEach((example)=>{
                example[0] = example[0].replace(/\$0/g, base$0);
            });
            examples.forEach((example)=>{
                if (example[1] === '') {
                    ui.div({
                        text: example[0],
                        padding: [
                            0,
                            2,
                            0,
                            2
                        ]
                    });
                } else {
                    ui.div({
                        text: example[0],
                        padding: [
                            0,
                            2,
                            0,
                            2
                        ],
                        width: maxWidth(examples, theWrap) + 4
                    }, {
                        text: example[1]
                    });
                }
            });
            ui.div();
        }
        if (epilogs.length > 0) {
            const e = epilogs.map((epilog)=>epilog.replace(/\$0/g, base$0)).join('\n');
            ui.div(`${e}\n`);
        }
        return ui.toString().replace(/\s*$/, '');
    };
    function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
            table = Object.values(table).map((v)=>[
                    v
                ]);
        }
        table.forEach((v)=>{
            width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
    }
    function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach((key)=>{
            options.alias[key].forEach((alias)=>{
                if (descriptions[alias]) self.describe(key, descriptions[alias]);
                if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
                if (options.boolean.includes(alias)) yargs.boolean(key);
                if (options.count.includes(alias)) yargs.count(key);
                if (options.string.includes(alias)) yargs.string(key);
                if (options.normalize.includes(alias)) yargs.normalize(key);
                if (options.array.includes(alias)) yargs.array(key);
                if (options.number.includes(alias)) yargs.number(key);
            });
        });
    }
    let cachedHelpMessage;
    self.cacheHelpMessage = function() {
        cachedHelpMessage = this.help();
    };
    self.clearCachedHelpMessage = function() {
        cachedHelpMessage = undefined;
    };
    self.hasCachedHelpMessage = function() {
        return !!cachedHelpMessage;
    };
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group)=>{
            groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key)=>{
            toCheck = [
                key
            ].concat(aliases[key]);
            if (!toCheck.some((k)=>groupedKeys.indexOf(k) !== -1)) {
                groups[defaultGroup].push(key);
            }
        });
        return groupedKeys;
    }
    function filterHiddenOptions(key) {
        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
    }
    self.showHelp = (level)=>{
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level) level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
    };
    self.functionDescription = (fn)=>{
        const description = fn.name ? shim.Parser.decamelize(fn.name, '-') : __('generated-value');
        return [
            '(',
            description,
            ')'
        ].join('');
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length) return string;
        array.forEach((value)=>{
            if (string.length) string += sep;
            string += JSON.stringify(value);
        });
        return string;
    };
    function defaultString(value, defaultDescription) {
        let string = `[${__('default:')} `;
        if (value === undefined && !defaultDescription) return null;
        if (defaultDescription) {
            string += defaultDescription;
        } else {
            switch(typeof value){
                case 'string':
                    string += `"${value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
            }
        }
        return `${string}]`;
    }
    function windowWidth() {
        if (shim.process.stdColumns) {
            return Math.min(80, shim.process.stdColumns);
        } else {
            return 80;
        }
    }
    let version = null;
    self.version = (ver)=>{
        version = ver;
    };
    self.showVersion = (level)=>{
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level) level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(version);
    };
    self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, (k)=>!localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        if (!frozen) return;
        ({ failMessage , failureOutput , usages , usageDisabled , epilogs , examples , commands , descriptions  } = frozen);
    };
    return self;
}
function isIndentedText(text) {
    return typeof text === 'object';
}
function addIndentation(text, indent) {
    return isIndentedText(text) ? {
        text: text.text,
        indentation: text.indentation + indent
    } : {
        text,
        indentation: indent
    };
}
function getIndentation(text) {
    return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
    return isIndentedText(text) ? text.text : text;
}
function levenshtein(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    const matrix = [];
    let i;
    for(i = 0; i <= b.length; i++){
        matrix[i] = [
            i
        ];
    }
    let j;
    for(j = 0; j <= a.length; j++){
        matrix[0][j] = j;
    }
    for(i = 1; i <= b.length; i++){
        for(j = 1; j <= a.length; j++){
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
                    matrix[i][j] = matrix[i - 2][j - 2] + 1;
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                }
            }
        }
    }
    return matrix[b.length][a.length];
}
const specialKeys = [
    '$0',
    '--',
    '_'
];
function validation(yargs, usage, shim) {
    const __ = shim.y18n.__;
    const __n = shim.y18n.__n;
    const self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
            if (_s < demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
                } else {
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                }
            } else if (_s > demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
                } else {
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
        }
    };
    self.requiredArguments = function requiredArguments(argv, demandedOptions) {
        let missing = null;
        for (const key of Object.keys(demandedOptions)){
            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {
                missing = missing || {};
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key1 of Object.keys(missing)){
                const msg = missing[key1];
                if (msg && customMsgs.indexOf(msg) < 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        var _a;
        const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        Object.keys(argv).forEach((key)=>{
            if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach((key)=>{
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (checkPositionals) {
            const demandedCommands = yargs.getDemandedCommands();
            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
            const expected = currentContext.commands.length + maxNonOptDemanded;
            if (expected < argv._.length) {
                argv._.slice(expected).forEach((key)=>{
                    key = String(key);
                    if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
                        unknown.push(key);
                    }
                });
            }
        }
        if (unknown.length) {
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
            argv._.slice(currentContext.commands.length).forEach((key)=>{
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
        } else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        return [
            key,
            ...aliases[key]
        ].some((a)=>!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
    };
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length) return;
        Object.keys(argv).forEach((key)=>{
            if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach((value)=>{
                    if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length) return;
        let msg = __('Invalid values:');
        invalidKeys.forEach((key)=>{
            msg += `\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    let implied = {};
    self.implies = function implies(key, value) {
        argsert('<string|object> [array|number|string]', [
            key,
            value
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                self.implies(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i)=>self.implies(key, i));
            } else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') {
            val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !Object.prototype.hasOwnProperty.call(argv, val);
        } else {
            val = Object.prototype.hasOwnProperty.call(argv, val);
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key)=>{
            const origKey = key;
            (implied[key] || []).forEach((value)=>{
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) {
                    implyFail.push(` ${origKey} -> ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__('Implications failed:')}\n`;
            implyFail.forEach((value)=>{
                msg += value;
            });
            usage.fail(msg);
        }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert('<string|object> [array|string]', [
            key,
            value
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                self.conflicts(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i)=>self.conflicts(key, i));
            } else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = ()=>conflicting;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key)=>{
            if (conflicting[key]) {
                conflicting[key].forEach((value)=>{
                    if (value && argv[key] !== undefined && argv[value] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            }
        });
        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {
            Object.keys(conflicting).forEach((key)=>{
                conflicting[key].forEach((value)=>{
                    if (value && argv[shim.Parser.camelCase(key)] !== undefined && argv[shim.Parser.camelCase(value)] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            });
        }
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b)=>b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for(let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++){
            const d = levenshtein(cmd, candidate);
            if (d <= threshold && d < bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended) usage.fail(__('Did you mean %s?', recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, (k)=>!localLookup[k]);
        conflicting = objFilter(conflicting, (k)=>!localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            conflicting
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ implied , conflicting  } = frozen);
    };
    return self;
}
let previouslyVisitedConfigs = [];
let shim1;
function applyExtends(config, cwd, mergeExtends, _shim) {
    shim1 = _shim;
    let defaultConfig = {};
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
        if (typeof config.extends !== 'string') return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
            try {
                pathToDefault = require.resolve(config.extends);
            } catch (_err) {
                return config;
            }
        } else {
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath ? JSON.parse(shim1.readFileSync(pathToDefault, 'utf8')) : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim1.path.dirname(pathToDefault), mergeExtends, shim1);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
    }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
    return shim1.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
    const target = {};
    function isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)){
        if (isObject(config2[key]) && isObject(target[key])) {
            target[key] = mergeDeep(config1[key], config2[key]);
        } else {
            target[key] = config2[key];
        }
    }
    return target;
}
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
const DEFAULT_MARKER = /(^\*)|(^\$0)/;
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command, _YargsInstance_cwd, _YargsInstance_context, _YargsInstance_completion, _YargsInstance_completionCommand, _YargsInstance_defaultShowHiddenOpt, _YargsInstance_exitError, _YargsInstance_detectLocale, _YargsInstance_emittedWarnings, _YargsInstance_exitProcess, _YargsInstance_frozens, _YargsInstance_globalMiddleware, _YargsInstance_groups, _YargsInstance_hasOutput, _YargsInstance_helpOpt, _YargsInstance_logger, _YargsInstance_output, _YargsInstance_options, _YargsInstance_parentRequire, _YargsInstance_parserConfig, _YargsInstance_parseFn, _YargsInstance_parseContext, _YargsInstance_pkgs, _YargsInstance_preservedGroups, _YargsInstance_processArgs, _YargsInstance_recommendCommands, _YargsInstance_shim, _YargsInstance_strict, _YargsInstance_strictCommands, _YargsInstance_strictOptions, _YargsInstance_usage, _YargsInstance_versionOpt, _YargsInstance_validation;
function YargsFactory(_shim) {
    return (processArgs = [], cwd = _shim.process.cwd(), parentRequire)=>{
        const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
        Object.defineProperty(yargs, 'argv', {
            get: ()=>{
                return yargs.parse();
            },
            enumerable: true
        });
        yargs.help();
        yargs.version();
        return yargs;
    };
}
const kCopyDoubleDash = Symbol('copyDoubleDash');
const kCreateLogger = Symbol('copyDoubleDash');
const kDeleteFromParserHintObject = Symbol('deleteFromParserHintObject');
const kEmitWarning = Symbol('emitWarning');
const kFreeze = Symbol('freeze');
const kGetDollarZero = Symbol('getDollarZero');
const kGetParserConfiguration = Symbol('getParserConfiguration');
const kGuessLocale = Symbol('guessLocale');
const kGuessVersion = Symbol('guessVersion');
const kParsePositionalNumbers = Symbol('parsePositionalNumbers');
const kPkgUp = Symbol('pkgUp');
const kPopulateParserHintArray = Symbol('populateParserHintArray');
const kPopulateParserHintSingleValueDictionary = Symbol('populateParserHintSingleValueDictionary');
const kPopulateParserHintArrayDictionary = Symbol('populateParserHintArrayDictionary');
const kPopulateParserHintDictionary = Symbol('populateParserHintDictionary');
const kSanitizeKey = Symbol('sanitizeKey');
const kSetKey = Symbol('setKey');
const kUnfreeze = Symbol('unfreeze');
const kValidateAsync = Symbol('validateAsync');
const kGetCommandInstance = Symbol('getCommandInstance');
const kGetContext = Symbol('getContext');
const kGetHasOutput = Symbol('getHasOutput');
const kGetLoggerInstance = Symbol('getLoggerInstance');
const kGetParseContext = Symbol('getParseContext');
const kGetUsageInstance = Symbol('getUsageInstance');
const kGetValidationInstance = Symbol('getValidationInstance');
const kHasParseCallback = Symbol('hasParseCallback');
const kPostProcess = Symbol('postProcess');
const kRebase = Symbol('rebase');
const kReset = Symbol('reset');
const kRunYargsParserAndExecuteCommands = Symbol('runYargsParserAndExecuteCommands');
const kRunValidation = Symbol('runValidation');
const kSetHasOutput = Symbol('setHasOutput');
const kTrackManuallySetKeys = Symbol('kTrackManuallySetKeys');
function isYargsInstance(y) {
    return !!y && typeof y.getInternalMethods === 'function';
}
class CommandInstance {
    constructor(usage, validation, globalMiddleware, shim){
        this.requireCache = new Set();
        this.handlers = {};
        this.aliasMap = {};
        this.frozens = [];
        this.shim = shim;
        this.usage = usage;
        this.globalMiddleware = globalMiddleware;
        this.validation = validation;
    }
    addDirectory(dir, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== 'boolean') opts.recurse = false;
        if (!Array.isArray(opts.extensions)) opts.extensions = [
            'js'
        ];
        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o)=>o;
        opts.visit = (obj, joined, filename)=>{
            const visited = parentVisit(obj, joined, filename);
            if (visited) {
                if (this.requireCache.has(joined)) return visited;
                else this.requireCache.add(joined);
                this.addHandler(visited);
            }
            return visited;
        };
        this.shim.requireDirectory({
            require: req,
            filename: callerFile
        }, dir, opts);
    }
    addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (()=>{});
        if (Array.isArray(cmd)) {
            if (isCommandAndAliases(cmd)) {
                [cmd, ...aliases] = cmd;
            } else {
                for (const command of cmd){
                    this.addHandler(command);
                }
            }
        } else if (isCommandHandlerDefinition(cmd)) {
            let command1 = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : this.moduleName(cmd);
            if (cmd.aliases) command1 = [].concat(command1).concat(cmd.aliases);
            this.addHandler(command1, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
        } else if (isCommandBuilderDefinition(builder)) {
            this.addHandler([
                cmd
            ].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
        }
        if (typeof cmd === 'string') {
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map((alias)=>parseCommand(alias).cmd);
            let isDefault = false;
            const parsedAliases = [
                parsedCommand.cmd
            ].concat(aliases).filter((c)=>{
                if (DEFAULT_MARKER.test(c)) {
                    isDefault = true;
                    return false;
                }
                return true;
            });
            if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');
            if (isDefault) {
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
            }
            aliases.forEach((alias)=>{
                this.aliasMap[alias] = parsedCommand.cmd;
            });
            if (description !== false) {
                this.usage.command(cmd, description, isDefault, aliases, deprecated);
            }
            this.handlers[parsedCommand.cmd] = {
                original: cmd,
                description,
                handler,
                builder: builder || {},
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional
            };
            if (isDefault) this.defaultCommand = this.handlers[parsedCommand.cmd];
        }
    }
    getCommandHandlers() {
        return this.handlers;
    }
    getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
    }
    hasDefaultCommand() {
        return !!this.defaultCommand;
    }
    runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
        const commandHandler = this.handlers[command] || this.handlers[this.aliasMap[command]] || this.defaultCommand;
        const currentContext = yargs.getInternalMethods().getContext();
        const parentCommands = currentContext.commands.slice();
        const isDefaultCommand = !command;
        if (command) {
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
        }
        const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
        return isPromise(builderResult) ? builderResult.then((result)=>this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
    }
    applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
        const builder = commandHandler.builder;
        let innerYargs = yargs;
        if (isCommandBuilderCallback(builder)) {
            const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
            if (isPromise(builderOutput)) {
                return builderOutput.then((output)=>{
                    innerYargs = isYargsInstance(output) ? output : yargs;
                    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
                });
            }
        } else if (isCommandBuilderOptionDefinitions(builder)) {
            innerYargs = yargs.getInternalMethods().reset(aliases);
            Object.keys(commandHandler.builder).forEach((key)=>{
                innerYargs.option(key, builder[key]);
            });
        }
        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
    }
    parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
        if (isDefaultCommand) innerYargs.getInternalMethods().getUsageInstance().unfreeze();
        if (this.shouldUpdateUsage(innerYargs)) {
            innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
        return isPromise(innerArgv) ? innerArgv.then((argv)=>({
                aliases: innerYargs.parsed.aliases,
                innerArgv: argv
            })) : {
            aliases: innerYargs.parsed.aliases,
            innerArgv: innerArgv
        };
    }
    shouldUpdateUsage(yargs) {
        return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
    }
    usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
        const pc = parentCommands.filter((c)=>{
            return !DEFAULT_MARKER.test(c);
        });
        pc.push(c);
        return `$0 ${pc.join(' ')}`;
    }
    applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
        let positionalMap = {};
        if (helpOnly) return innerArgv;
        if (!yargs.getInternalMethods().getHasOutput()) {
            positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
        }
        const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
        innerArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
        if (!yargs.getInternalMethods().getHasOutput()) {
            const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
            innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                validation(result);
                return result;
            });
        }
        if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
            yargs.getInternalMethods().setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                const handlerResult = commandHandler.handler(result);
                return isPromise(handlerResult) ? handlerResult.then(()=>result) : result;
            });
            if (!isDefaultCommand) {
                yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
            }
            if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
                innerArgv.catch((error)=>{
                    try {
                        yargs.getInternalMethods().getUsageInstance().fail(null, error);
                    } catch (_err) {}
                });
            }
        }
        if (!isDefaultCommand) {
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
        }
        return innerArgv;
    }
    populatePositionals(commandHandler, argv, context, yargs) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        this.validation.positionalCount(demanded.length, argv._.length);
        while(demanded.length){
            const demand = demanded.shift();
            this.populatePositional(demand, argv, positionalMap);
        }
        while(optional.length){
            const maybe = optional.shift();
            this.populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map((a)=>'' + a));
        this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
        return positionalMap;
    }
    populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
            positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
            if (argv._.length) positionalMap[cmd] = [
                String(argv._.shift())
            ];
        }
    }
    cmdToParseOptions(cmdString) {
        const parseOptions = {
            array: [],
            default: {},
            alias: {},
            demand: {}
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach((d)=>{
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o)=>{
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
    }
    postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)){
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach((key)=>{
            positionalMap[key].map((value)=>{
                if (options.configuration['unknown-options-as-args']) options.key[key] = true;
                unparsed.push(`--${key}`);
                unparsed.push(value);
            });
        });
        if (!unparsed.length) return;
        const config = Object.assign({}, options.configuration, {
            'populate--': false
        });
        const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
            configuration: config
        }));
        if (parsed.error) {
            yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach((key)=>{
                positionalKeys.push(...parsed.aliases[key]);
            });
            const defaults = yargs.getOptions().default;
            Object.keys(parsed.argv).forEach((key)=>{
                if (positionalKeys.includes(key)) {
                    if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
                    if (!Object.prototype.hasOwnProperty.call(defaults, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
                        argv[key] = [].concat(argv[key], parsed.argv[key]);
                    } else {
                        argv[key] = parsed.argv[key];
                    }
                }
            });
        }
    }
    runDefaultBuilderOn(yargs) {
        if (!this.defaultCommand) return;
        if (this.shouldUpdateUsage(yargs)) {
            const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
        }
        const builder = this.defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
            return builder(yargs, true);
        } else if (!isCommandBuilderDefinition(builder)) {
            Object.keys(builder).forEach((key)=>{
                yargs.option(key, builder[key]);
            });
        }
        return undefined;
    }
    moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod) throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
        return this.commandFromFilename(mod.filename);
    }
    commandFromFilename(filename) {
        return this.shim.path.basename(filename, this.shim.path.extname(filename));
    }
    extractDesc({ describe , description , desc  }) {
        for (const test of [
            describe,
            description,
            desc
        ]){
            if (typeof test === 'string' || test === false) return test;
            assertNotStrictEqual(test, true, this.shim);
        }
        return false;
    }
    freeze() {
        this.frozens.push({
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand
        });
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        assertNotStrictEqual(frozen, undefined, this.shim);
        ({ handlers: this.handlers , aliasMap: this.aliasMap , defaultCommand: this.defaultCommand  } = frozen);
    }
    reset() {
        this.handlers = {};
        this.aliasMap = {};
        this.defaultCommand = undefined;
        this.requireCache = new Set();
        return this;
    }
}
function command(usage, validation, globalMiddleware, shim) {
    return new CommandInstance(usage, validation, globalMiddleware, shim);
}
function isCommandBuilderDefinition(builder) {
    return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';
}
function isCommandAndAliases(cmd) {
    return cmd.every((c)=>typeof c === 'string');
}
function isCommandBuilderCallback(builder) {
    return typeof builder === 'function';
}
class Completion {
    constructor(yargs, usage, command, shim){
        var _a, _b, _c;
        this.yargs = yargs;
        this.usage = usage;
        this.command = command;
        this.shim = shim;
        this.completionKey = 'get-yargs-completions';
        this.aliases = null;
        this.customCompletionFunction = null;
        this.zshShell = (_c = ((_a = this.shim.getEnv('SHELL')) === null || _a === void 0 ? void 0 : _a.includes('zsh')) || ((_b = this.shim.getEnv('ZSH_NAME')) === null || _b === void 0 ? void 0 : _b.includes('zsh'))) !== null && _c !== void 0 ? _c : false;
    }
    defaultCompletion(args, argv, current, done) {
        const handlers = this.command.getCommandHandlers();
        for(let i = 0, ii = args.length; i < ii; ++i){
            if (handlers[args[i]] && handlers[args[i]].builder) {
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) {
                    const y = this.yargs.getInternalMethods().reset();
                    builder(y, true);
                    return y.argv;
                }
            }
        }
        const completions = [];
        this.commandCompletions(completions, args, current);
        this.optionCompletions(completions, args, argv, current);
        this.choicesCompletions(completions, args, argv, current);
        done(null, completions);
    }
    commandCompletions(completions, args, current) {
        const parentCommands = this.yargs.getInternalMethods().getContext().commands;
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
            this.usage.getCommands().forEach((usageCommand)=>{
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) {
                    if (!this.zshShell) {
                        completions.push(commandName);
                    } else {
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                    }
                }
            });
        }
    }
    optionCompletions(completions, args, argv, current) {
        if ((current.match(/^-/) || current === '' && completions.length === 0) && !this.previousArgHasChoices(args)) {
            const options = this.yargs.getOptions();
            const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
            Object.keys(options.key).forEach((key)=>{
                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);
                const isPositionalKey = positionalKeys.includes(key);
                if (!isPositionalKey && !this.argsContainKey(args, argv, key, negable)) {
                    this.completeOptionKey(key, completions, current);
                    if (negable && !!options.default[key]) this.completeOptionKey(`no-${key}`, completions, current);
                }
            });
        }
    }
    choicesCompletions(completions, args, argv, current) {
        if (this.previousArgHasChoices(args)) {
            const choices = this.getPreviousArgChoices(args);
            if (choices && choices.length > 0) {
                completions.push(...choices);
            }
        }
    }
    getPreviousArgChoices(args) {
        if (args.length < 1) return;
        let previousArg = args[args.length - 1];
        let filter = '';
        if (!previousArg.startsWith('--') && args.length > 1) {
            filter = previousArg;
            previousArg = args[args.length - 2];
        }
        if (!previousArg.startsWith('--')) return;
        const previousArgKey = previousArg.replace(/-/g, '');
        const options = this.yargs.getOptions();
        if (Object.keys(options.key).some((key)=>key === previousArgKey) && Array.isArray(options.choices[previousArgKey])) {
            return options.choices[previousArgKey].filter((choice)=>!filter || choice.startsWith(filter));
        }
    }
    previousArgHasChoices(args) {
        const choices = this.getPreviousArgChoices(args);
        return choices !== undefined && choices.length > 0;
    }
    argsContainKey(args, argv, key, negable) {
        if (args.indexOf(`--${key}`) !== -1) return true;
        if (negable && args.indexOf(`--no-${key}`) !== -1) return true;
        if (this.aliases) {
            for (const alias of this.aliases[key]){
                if (argv[alias] !== undefined) return true;
            }
        }
        return false;
    }
    completeOptionKey(key, completions, current) {
        const descs = this.usage.getDescriptions();
        const startsByTwoDashes = (s)=>/^--/.test(s);
        const isShortOption = (s)=>/^[^0-9]$/.test(s);
        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
        if (!this.zshShell) {
            completions.push(dashes + key);
        } else {
            const desc = descs[key] || '';
            completions.push(dashes + `${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '')}`);
        }
    }
    customCompletion(args, argv, current, done) {
        assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
        if (isSyncCompletionFunction(this.customCompletionFunction)) {
            const result = this.customCompletionFunction(current, argv);
            if (isPromise(result)) {
                return result.then((list)=>{
                    this.shim.process.nextTick(()=>{
                        done(null, list);
                    });
                }).catch((err)=>{
                    this.shim.process.nextTick(()=>{
                        done(err, undefined);
                    });
                });
            }
            return done(null, result);
        } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
            return this.customCompletionFunction(current, argv, (onCompleted = done)=>this.defaultCompletion(args, argv, current, onCompleted), (completions)=>{
                done(null, completions);
            });
        } else {
            return this.customCompletionFunction(current, argv, (completions)=>{
                done(null, completions);
            });
        }
    }
    getCompletion(args, done) {
        const current = args.length ? args[args.length - 1] : '';
        const argv = this.yargs.parse(args, true);
        const completionFunction = this.customCompletionFunction ? (argv)=>this.customCompletion(args, argv, current, done) : (argv)=>this.defaultCompletion(args, argv, current, done);
        return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
    }
    generateCompletionScript($0, cmd) {
        let script = this.zshShell ? completionZshTemplate : completionShTemplate;
        const name = this.shim.path.basename($0);
        if ($0.match(/\.js$/)) $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
    }
    registerFunction(fn) {
        this.customCompletionFunction = fn;
    }
    setParsed(parsed) {
        this.aliases = parsed.aliases;
    }
}
function completion(yargs, usage, command, shim) {
    return new Completion(yargs, usage, command, shim);
}
class YargsInstance {
    constructor(processArgs = [], cwd, parentRequire, shim){
        this.customScriptName = false;
        this.parsed = false;
        _YargsInstance_command.set(this, void 0);
        _YargsInstance_cwd.set(this, void 0);
        _YargsInstance_context.set(this, {
            commands: [],
            fullCommands: []
        });
        _YargsInstance_completion.set(this, null);
        _YargsInstance_completionCommand.set(this, null);
        _YargsInstance_defaultShowHiddenOpt.set(this, 'show-hidden');
        _YargsInstance_exitError.set(this, null);
        _YargsInstance_detectLocale.set(this, true);
        _YargsInstance_emittedWarnings.set(this, {});
        _YargsInstance_exitProcess.set(this, true);
        _YargsInstance_frozens.set(this, []);
        _YargsInstance_globalMiddleware.set(this, void 0);
        _YargsInstance_groups.set(this, {});
        _YargsInstance_hasOutput.set(this, false);
        _YargsInstance_helpOpt.set(this, null);
        _YargsInstance_logger.set(this, void 0);
        _YargsInstance_output.set(this, '');
        _YargsInstance_options.set(this, void 0);
        _YargsInstance_parentRequire.set(this, void 0);
        _YargsInstance_parserConfig.set(this, {});
        _YargsInstance_parseFn.set(this, null);
        _YargsInstance_parseContext.set(this, null);
        _YargsInstance_pkgs.set(this, {});
        _YargsInstance_preservedGroups.set(this, {});
        _YargsInstance_processArgs.set(this, void 0);
        _YargsInstance_recommendCommands.set(this, false);
        _YargsInstance_shim.set(this, void 0);
        _YargsInstance_strict.set(this, false);
        _YargsInstance_strictCommands.set(this, false);
        _YargsInstance_strictOptions.set(this, false);
        _YargsInstance_usage.set(this, void 0);
        _YargsInstance_versionOpt.set(this, null);
        _YargsInstance_validation.set(this, void 0);
        __classPrivateFieldSet(this, _YargsInstance_shim, shim, "f");
        __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
        __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
        __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
        __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
        this.$0 = this[kGetDollarZero]();
        this[kReset]();
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
    }
    addHelpOpt(opt, msg) {
        const defaultHelpOpt = 'help';
        argsert('[string|boolean] [string]', [
            opt,
            msg
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
            __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
        }
        if (opt === false && msg === undefined) return this;
        __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === 'string' ? opt : defaultHelpOpt, "f");
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show help'));
        return this;
    }
    help(opt, msg) {
        return this.addHelpOpt(opt, msg);
    }
    addShowHiddenOpt(opt, msg) {
        argsert('[string|boolean] [string]', [
            opt,
            msg
        ], arguments.length);
        if (opt === false && msg === undefined) return this;
        const showHiddenOpt = typeof opt === 'string' ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        this.boolean(showHiddenOpt);
        this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show hidden options'));
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
        return this;
    }
    showHidden(opt, msg) {
        return this.addShowHiddenOpt(opt, msg);
    }
    alias(key, value) {
        argsert('<object|string|array> [string|array]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.alias.bind(this), 'alias', key, value);
        return this;
    }
    array(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('array', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    boolean(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('boolean', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    check(f, global) {
        argsert('<function> [boolean]', [
            f,
            global
        ], arguments.length);
        this.middleware((argv, _yargs)=>{
            return maybeAsyncResult(()=>{
                return f(argv);
            }, (result)=>{
                if (!result) {
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__('Argument check failed: %s', f.toString()));
                } else if (typeof result === 'string' || result instanceof Error) {
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
                }
                return argv;
            }, (err)=>{
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
                return argv;
            });
        }, false, global);
        return this;
    }
    choices(key, value) {
        argsert('<object|string|array> [string|array]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.choices.bind(this), 'choices', key, value);
        return this;
    }
    coerce(keys, value) {
        argsert('<object|string|array> [function]', [
            keys,
            value
        ], arguments.length);
        if (Array.isArray(keys)) {
            if (!value) {
                throw new YError('coerce callback must be provided');
            }
            for (const key of keys){
                this.coerce(key, value);
            }
            return this;
        } else if (typeof keys === 'object') {
            for (const key1 of Object.keys(keys)){
                this.coerce(key1, keys[key1]);
            }
            return this;
        }
        if (!value) {
            throw new YError('coerce callback must be provided');
        }
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs)=>{
            let aliases;
            return maybeAsyncResult(()=>{
                aliases = yargs.getAliases();
                return value(argv[keys]);
            }, (result)=>{
                argv[keys] = result;
                if (aliases[keys]) {
                    for (const alias of aliases[keys]){
                        argv[alias] = result;
                    }
                }
                return argv;
            }, (err)=>{
                throw new YError(err.message);
            });
        }, keys);
        return this;
    }
    conflicts(key1, key2) {
        argsert('<string|object> [string|array]', [
            key1,
            key2
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
        return this;
    }
    config(key = 'config', msg, parseFn) {
        argsert('[object|string] [string|function] [function]', [
            key,
            msg,
            parseFn
        ], arguments.length);
        if (typeof key === 'object' && !Array.isArray(key)) {
            key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
            return this;
        }
        if (typeof msg === 'function') {
            parseFn = msg;
            msg = undefined;
        }
        this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Path to JSON config file'));
        (Array.isArray(key) ? key : [
            key
        ]).forEach((k)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
        });
        return this;
    }
    completion(cmd, desc, fn) {
        argsert('[string] [string|boolean|function] [function]', [
            cmd,
            desc,
            fn
        ], arguments.length);
        if (typeof desc === 'function') {
            fn = desc;
            desc = undefined;
        }
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion', "f");
        if (!desc && desc !== false) {
            desc = 'generate completion script';
        }
        this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
        if (fn) __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
        return this;
    }
    command(cmd, description, builder, handler, middlewares, deprecated) {
        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [
            cmd,
            description,
            builder,
            handler,
            middlewares,
            deprecated
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return this;
    }
    commands(cmd, description, builder, handler, middlewares, deprecated) {
        return this.command(cmd, description, builder, handler, middlewares, deprecated);
    }
    commandDir(dir, opts) {
        argsert('<string> [object]', [
            dir,
            opts
        ], arguments.length);
        const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
        return this;
    }
    count(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('count', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    default(key, value, defaultDescription) {
        argsert('<object|string|array> [*] [string]', [
            key,
            value,
            defaultDescription
        ], arguments.length);
        if (defaultDescription) {
            assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
        }
        if (typeof value === 'function') {
            assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key]) __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
            value = value.call();
        }
        this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), 'default', key, value);
        return this;
    }
    defaults(key, value, defaultDescription) {
        return this.default(key, value, defaultDescription);
    }
    demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [
            min,
            max,
            minMsg,
            maxMsg
        ], arguments.length);
        if (typeof max !== 'number') {
            minMsg = max;
            max = Infinity;
        }
        this.global('_', false);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
            min,
            max,
            minMsg,
            maxMsg
        };
        return this;
    }
    demand(keys, max, msg) {
        if (Array.isArray(max)) {
            max.forEach((key)=>{
                assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
            max = Infinity;
        } else if (typeof max !== 'number') {
            msg = max;
            max = Infinity;
        }
        if (typeof keys === 'number') {
            assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            this.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
            keys.forEach((key)=>{
                assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
        } else {
            if (typeof msg === 'string') {
                this.demandOption(keys, msg);
            } else if (msg === true || typeof msg === 'undefined') {
                this.demandOption(keys);
            }
        }
        return this;
    }
    demandOption(keys, msg) {
        argsert('<object|string|array> [string]', [
            keys,
            msg
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), 'demandedOptions', keys, msg);
        return this;
    }
    deprecateOption(option, message) {
        argsert('<string> [string|boolean]', [
            option,
            message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
        return this;
    }
    describe(keys, description) {
        argsert('<object|string|array> [string]', [
            keys,
            description
        ], arguments.length);
        this[kSetKey](keys, true);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
        return this;
    }
    detectLocale(detect) {
        argsert('<boolean>', [
            detect
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
        return this;
    }
    env(prefix) {
        argsert('[string|boolean]', [
            prefix
        ], arguments.length);
        if (prefix === false) delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        else __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || '';
        return this;
    }
    epilogue(msg) {
        argsert('<string>', [
            msg
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
        return this;
    }
    epilog(msg) {
        return this.epilogue(msg);
    }
    example(cmd, description) {
        argsert('<string|array> [string]', [
            cmd,
            description
        ], arguments.length);
        if (Array.isArray(cmd)) {
            cmd.forEach((exampleParams)=>this.example(...exampleParams));
        } else {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
        }
        return this;
    }
    exit(code, err) {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
    }
    exitProcess(enabled = true) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
        return this;
    }
    fail(f) {
        argsert('<function|boolean>', [
            f
        ], arguments.length);
        if (typeof f === 'boolean' && f !== false) {
            throw new YError("Invalid first argument. Expected function or boolean 'false'");
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
        return this;
    }
    getAliases() {
        return this.parsed ? this.parsed.aliases : {};
    }
    async getCompletion(args, done) {
        argsert('<array> [function]', [
            args,
            done
        ], arguments.length);
        if (!done) {
            return new Promise((resolve, reject)=>{
                __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions)=>{
                    if (err) reject(err);
                    else resolve(completions);
                });
            });
        } else {
            return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
        }
    }
    getDemandedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
    }
    getDemandedCommands() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
    }
    getDeprecatedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
    }
    getDetectLocale() {
        return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
    }
    getExitProcess() {
        return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
    }
    getGroups() {
        return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
    }
    getHelp() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise(parse)) {
                    return parse.then(()=>{
                        return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
                    });
                }
            }
            const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise(builderResponse)) {
                return builderResponse.then(()=>{
                    return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
                });
            }
        }
        return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
    }
    getOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_options, "f");
    }
    getStrict() {
        return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
    }
    getStrictCommands() {
        return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
    }
    getStrictOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
    }
    global(globals, global) {
        argsert('<string|array> [boolean]', [
            globals,
            global
        ], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l)=>globals.indexOf(l) === -1);
        } else {
            globals.forEach((g)=>{
                if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g)) __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
            });
        }
        return this;
    }
    group(opts, groupName) {
        argsert('<string|array> <string>', [
            opts,
            groupName
        ], arguments.length);
        const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
        if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
            delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
        }
        const seen = {};
        __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key)=>{
            if (seen[key]) return false;
            return seen[key] = true;
        });
        return this;
    }
    hide(key) {
        argsert('<string>', [
            key
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
        return this;
    }
    implies(key, value) {
        argsert('<string|object> [number|string|array]', [
            key,
            value
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
        return this;
    }
    locale(locale) {
        argsert('[string]', [
            locale
        ], arguments.length);
        if (!locale) {
            this[kGuessLocale]();
            return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
        }
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
        return this;
    }
    middleware(callback, applyBeforeValidation, global) {
        return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global);
    }
    nargs(key, value) {
        argsert('<string|object|array> [number]', [
            key,
            value
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), 'narg', key, value);
        return this;
    }
    normalize(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('normalize', keys);
        return this;
    }
    number(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('number', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    option(key, opt) {
        argsert('<string|object> [object]', [
            key,
            opt
        ], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach((k)=>{
                this.options(k, key[k]);
            });
        } else {
            if (typeof opt !== 'object') {
                opt = {};
            }
            this[kTrackManuallySetKeys](key);
            if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === 'version' || (opt === null || opt === void 0 ? void 0 : opt.alias) === 'version')) {
                this[kEmitWarning]([
                    '"version" is a reserved word.',
                    'Please do one of the following:',
                    '- Disable version with `yargs.version(false)` if using "version" as an option',
                    '- Use the built-in `yargs.version` method instead (if applicable)',
                    '- Use a different option key',
                    'https://yargs.js.org/docs/#api-reference-version'
                ].join('\n'), undefined, 'versionWarning');
            }
            __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
            if (opt.alias) this.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) {
                this.deprecateOption(key, deprecate);
            }
            const demand = opt.demand || opt.required || opt.require;
            if (demand) {
                this.demand(key, demand);
            }
            if (opt.demandOption) {
                this.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
            }
            if (opt.conflicts) {
                this.conflicts(key, opt.conflicts);
            }
            if ('default' in opt) {
                this.default(key, opt.default);
            }
            if (opt.implies !== undefined) {
                this.implies(key, opt.implies);
            }
            if (opt.nargs !== undefined) {
                this.nargs(key, opt.nargs);
            }
            if (opt.config) {
                this.config(key, opt.configParser);
            }
            if (opt.normalize) {
                this.normalize(key);
            }
            if (opt.choices) {
                this.choices(key, opt.choices);
            }
            if (opt.coerce) {
                this.coerce(key, opt.coerce);
            }
            if (opt.group) {
                this.group(key, opt.group);
            }
            if (opt.boolean || opt.type === 'boolean') {
                this.boolean(key);
                if (opt.alias) this.boolean(opt.alias);
            }
            if (opt.array || opt.type === 'array') {
                this.array(key);
                if (opt.alias) this.array(opt.alias);
            }
            if (opt.number || opt.type === 'number') {
                this.number(key);
                if (opt.alias) this.number(opt.alias);
            }
            if (opt.string || opt.type === 'string') {
                this.string(key);
                if (opt.alias) this.string(opt.alias);
            }
            if (opt.count || opt.type === 'count') {
                this.count(key);
            }
            if (typeof opt.global === 'boolean') {
                this.global(key, opt.global);
            }
            if (opt.defaultDescription) {
                __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
            }
            if (opt.skipValidation) {
                this.skipValidation(key);
            }
            const desc = opt.describe || opt.description || opt.desc;
            this.describe(key, desc);
            if (opt.hidden) {
                this.hide(key);
            }
            if (opt.requiresArg) {
                this.requiresArg(key);
            }
        }
        return this;
    }
    options(key, opt) {
        return this.option(key, opt);
    }
    parse(args, shortCircuit, _parseFn) {
        argsert('[string|array] [function|boolean|object] [function]', [
            args,
            shortCircuit,
            _parseFn
        ], arguments.length);
        this[kFreeze]();
        if (typeof args === 'undefined') {
            args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        }
        if (typeof shortCircuit === 'object') {
            __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
            shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === 'function') {
            __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
            shortCircuit = false;
        }
        if (!shortCircuit) __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
        const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
        const tmpParsed = this.parsed;
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
        if (isPromise(parsed)) {
            return parsed.then((argv)=>{
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                return argv;
            }).catch((err)=>{
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
                    __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                }
                throw err;
            }).finally(()=>{
                this[kUnfreeze]();
                this.parsed = tmpParsed;
            });
        } else {
            if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
            this[kUnfreeze]();
            this.parsed = tmpParsed;
        }
        return parsed;
    }
    parseAsync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
    }
    parseSync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        if (isPromise(maybePromise)) {
            throw new YError('.parseSync() must not be used with asynchronous builders, handlers, or middleware');
        }
        return maybePromise;
    }
    parserConfiguration(config) {
        argsert('<object>', [
            config
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
        return this;
    }
    pkgConf(key, rootPath) {
        argsert('<string> [string]', [
            key,
            rootPath
        ], arguments.length);
        let conf = null;
        const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
        if (obj[key] && typeof obj[key] === 'object') {
            conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
        }
        return this;
    }
    positional(key, opts) {
        argsert('<string> <object>', [
            key,
            opts
        ], arguments.length);
        const supportedOpts = [
            'default',
            'defaultDescription',
            'implies',
            'normalize',
            'choices',
            'conflicts',
            'coerce',
            'type',
            'describe',
            'desc',
            'description',
            'alias'
        ];
        opts = objFilter(opts, (k, v)=>{
            if (k === 'type' && ![
                'string',
                'number',
                'boolean'
            ].includes(v)) return false;
            return supportedOpts.includes(k);
        });
        const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
        const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
            array: [],
            alias: {},
            default: {},
            demand: {}
        };
        objectKeys(parseOptions).forEach((pk)=>{
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) {
                if (parseOption.indexOf(key) !== -1) opts[pk] = true;
            } else {
                if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];
            }
        });
        this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
        return this.option(key, opts);
    }
    recommendCommands(recommend = true) {
        argsert('[boolean]', [
            recommend
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
        return this;
    }
    required(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    require(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    requiresArg(keys) {
        argsert('<array|string|object> [number]', [
            keys
        ], arguments.length);
        if (typeof keys === 'string' && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
            return this;
        } else {
            this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), 'narg', keys, NaN);
        }
        return this;
    }
    showCompletionScript($0, cmd) {
        argsert('[string] [string]', [
            $0,
            cmd
        ], arguments.length);
        $0 = $0 || this.$0;
        __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion'));
        return this;
    }
    showHelp(level) {
        argsert('[string|function]', [
            level
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise(parse)) {
                    parse.then(()=>{
                        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                    });
                    return this;
                }
            }
            const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise(builderResponse)) {
                builderResponse.then(()=>{
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                });
                return this;
            }
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        return this;
    }
    scriptName(scriptName) {
        this.customScriptName = true;
        this.$0 = scriptName;
        return this;
    }
    showHelpOnFail(enabled, message) {
        argsert('[boolean|string] [string]', [
            enabled,
            message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
        return this;
    }
    showVersion(level) {
        argsert('[string|function]', [
            level
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
        return this;
    }
    skipValidation(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('skipValidation', keys);
        return this;
    }
    strict(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
        return this;
    }
    strictCommands(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
        return this;
    }
    strictOptions(enabled) {
        argsert('[boolean]', [
            enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
        return this;
    }
    string(keys) {
        argsert('<array|string>', [
            keys
        ], arguments.length);
        this[kPopulateParserHintArray]('string', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    terminalWidth() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
    }
    updateLocale(obj) {
        return this.updateStrings(obj);
    }
    updateStrings(obj) {
        argsert('<object>', [
            obj
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
        return this;
    }
    usage(msg, description, builder, handler) {
        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [
            msg,
            description,
            builder,
            handler
        ], arguments.length);
        if (description !== undefined) {
            assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            if ((msg || '').match(/^\$0( |$)/)) {
                return this.command(msg, description, builder, handler);
            } else {
                throw new YError('.usage() description must start with $0 if being used as alias for .command()');
            }
        } else {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
            return this;
        }
    }
    version(opt, msg, ver) {
        const defaultVersionOpt = 'version';
        argsert('[boolean|string] [string] [string]', [
            opt,
            msg,
            ver
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(undefined);
            __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
        }
        if (arguments.length === 0) {
            ver = this[kGuessVersion]();
            opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
            if (opt === false) {
                return this;
            }
            ver = opt;
            opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
            ver = msg;
            msg = undefined;
        }
        __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === 'string' ? opt : defaultVersionOpt, "f");
        msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show version number');
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || undefined);
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
        return this;
    }
    wrap(cols) {
        argsert('<number|null|undefined>', [
            cols
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
        return this;
    }
    [(_YargsInstance_command = new WeakMap(), _YargsInstance_cwd = new WeakMap(), _YargsInstance_context = new WeakMap(), _YargsInstance_completion = new WeakMap(), _YargsInstance_completionCommand = new WeakMap(), _YargsInstance_defaultShowHiddenOpt = new WeakMap(), _YargsInstance_exitError = new WeakMap(), _YargsInstance_detectLocale = new WeakMap(), _YargsInstance_emittedWarnings = new WeakMap(), _YargsInstance_exitProcess = new WeakMap(), _YargsInstance_frozens = new WeakMap(), _YargsInstance_globalMiddleware = new WeakMap(), _YargsInstance_groups = new WeakMap(), _YargsInstance_hasOutput = new WeakMap(), _YargsInstance_helpOpt = new WeakMap(), _YargsInstance_logger = new WeakMap(), _YargsInstance_output = new WeakMap(), _YargsInstance_options = new WeakMap(), _YargsInstance_parentRequire = new WeakMap(), _YargsInstance_parserConfig = new WeakMap(), _YargsInstance_parseFn = new WeakMap(), _YargsInstance_parseContext = new WeakMap(), _YargsInstance_pkgs = new WeakMap(), _YargsInstance_preservedGroups = new WeakMap(), _YargsInstance_processArgs = new WeakMap(), _YargsInstance_recommendCommands = new WeakMap(), _YargsInstance_shim = new WeakMap(), _YargsInstance_strict = new WeakMap(), _YargsInstance_strictCommands = new WeakMap(), _YargsInstance_strictOptions = new WeakMap(), _YargsInstance_usage = new WeakMap(), _YargsInstance_versionOpt = new WeakMap(), _YargsInstance_validation = new WeakMap(), kCopyDoubleDash)](argv) {
        if (!argv._ || !argv['--']) return argv;
        argv._.push.apply(argv._, argv['--']);
        try {
            delete argv['--'];
        } catch (_err) {}
        return argv;
    }
    [kCreateLogger]() {
        return {
            log: (...args)=>{
                if (!this[kHasParseCallback]()) console.log(...args);
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
            },
            error: (...args)=>{
                if (!this[kHasParseCallback]()) console.error(...args);
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
            }
        };
    }
    [kDeleteFromParserHintObject](optionKey) {
        objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey)=>{
            if (((key)=>key === 'configObjects')(hintKey)) return;
            const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
            if (Array.isArray(hint)) {
                if (hint.includes(optionKey)) hint.splice(hint.indexOf(optionKey), 1);
            } else if (typeof hint === 'object') {
                delete hint[optionKey];
            }
        });
        delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
    }
    [kEmitWarning](warning, type, deduplicationId) {
        if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
            __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
            __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
        }
    }
    [kFreeze]() {
        __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
            options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
            configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
            exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
            groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
            strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
            strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
            strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
            completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
            output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
            exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
            hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
            parsed: this.parsed,
            parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
            parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
        });
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
    }
    [kGetDollarZero]() {
        let $0 = '';
        let default$0;
        if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
            default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
        } else {
            default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
        }
        $0 = default$0.map((x)=>{
            const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
            return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
        }).join(' ').trim();
        if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_') && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_')) {
            $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_').replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, '');
        }
        return $0;
    }
    [kGetParserConfiguration]() {
        return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
    }
    [kGuessLocale]() {
        if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f")) return;
        const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_ALL') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_MESSAGES') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANG') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANGUAGE') || 'en_US';
        this.locale(locale.replace(/[.:].*/, ''));
    }
    [kGuessVersion]() {
        const obj = this[kPkgUp]();
        return obj.version || 'unknown';
    }
    [kParsePositionalNumbers](argv) {
        const args = argv['--'] ? argv['--'] : argv._;
        for(let i = 0, arg; (arg = args[i]) !== undefined; i++){
            if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
                args[i] = Number(arg);
            }
        }
        return argv;
    }
    [kPkgUp](rootPath) {
        const npath = rootPath || '*';
        if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath]) return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
        let obj = {};
        try {
            let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
            if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
                startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
            }
            const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names)=>{
                if (names.includes('package.json')) {
                    return 'package.json';
                } else {
                    return undefined;
                }
            });
            assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, 'utf8'));
        } catch (_noop) {}
        __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
        return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    }
    [kPopulateParserHintArray](type, keys) {
        keys = [].concat(keys);
        keys.forEach((key)=>{
            key = this[kSanitizeKey](key);
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
        });
    }
    [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = value;
        });
    }
    [kPopulateParserHintArrayDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
            __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] || []).concat(value);
        });
    }
    [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
            key.forEach((k)=>{
                builder(k, value);
            });
        } else if (((key)=>typeof key === 'object')(key)) {
            for (const k of objectKeys(key)){
                builder(k, key[k]);
            }
        } else {
            singleKeyHandler(type, this[kSanitizeKey](key), value);
        }
    }
    [kSanitizeKey](key) {
        if (key === '__proto__') return '___proto___';
        return key;
    }
    [kSetKey](key, set) {
        this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), 'key', key, set);
        return this;
    }
    [kUnfreeze]() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
        assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        let configObjects;
        _a = this, _b = this, _c = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, { options: ({
            set value (_o){
                __classPrivateFieldSet(_a, _YargsInstance_options, _o, "f");
            }
        }).value , configObjects , exitProcess: ({
            set value (_o){
                __classPrivateFieldSet(_b, _YargsInstance_exitProcess, _o, "f");
            }
        }).value , groups: ({
            set value (_o){
                __classPrivateFieldSet(_c, _YargsInstance_groups, _o, "f");
            }
        }).value , output: ({
            set value (_o){
                __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
            }
        }).value , exitError: ({
            set value (_o){
                __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
            }
        }).value , hasOutput: ({
            set value (_o){
                __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
            }
        }).value , parsed: this.parsed , strict: ({
            set value (_o){
                __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
            }
        }).value , strictCommands: ({
            set value (_o){
                __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
            }
        }).value , strictOptions: ({
            set value (_o){
                __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
            }
        }).value , completionCommand: ({
            set value (_o){
                __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
            }
        }).value , parseFn: ({
            set value (_o){
                __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
            }
        }).value , parseContext: ({
            set value (_o){
                __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
            }
        }).value  } = frozen;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
    }
    [kValidateAsync](validation, argv) {
        return maybeAsyncResult(argv, (result)=>{
            validation(result);
            return result;
        });
    }
    getInternalMethods() {
        return {
            getCommandInstance: this[kGetCommandInstance].bind(this),
            getContext: this[kGetContext].bind(this),
            getHasOutput: this[kGetHasOutput].bind(this),
            getLoggerInstance: this[kGetLoggerInstance].bind(this),
            getParseContext: this[kGetParseContext].bind(this),
            getParserConfiguration: this[kGetParserConfiguration].bind(this),
            getUsageInstance: this[kGetUsageInstance].bind(this),
            getValidationInstance: this[kGetValidationInstance].bind(this),
            hasParseCallback: this[kHasParseCallback].bind(this),
            postProcess: this[kPostProcess].bind(this),
            reset: this[kReset].bind(this),
            runValidation: this[kRunValidation].bind(this),
            runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
            setHasOutput: this[kSetHasOutput].bind(this)
        };
    }
    [kGetCommandInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_command, "f");
    }
    [kGetContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_context, "f");
    }
    [kGetHasOutput]() {
        return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
    }
    [kGetLoggerInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
    }
    [kGetParseContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
    }
    [kGetUsageInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
    }
    [kGetValidationInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
    }
    [kHasParseCallback]() {
        return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
    }
    [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
        if (calledFromCommand) return argv;
        if (isPromise(argv)) return argv;
        if (!populateDoubleDash) {
            argv = this[kCopyDoubleDash](argv);
        }
        const parsePositionalNumbers = this[kGetParserConfiguration]()['parse-positional-numbers'] || this[kGetParserConfiguration]()['parse-positional-numbers'] === undefined;
        if (parsePositionalNumbers) {
            argv = this[kParsePositionalNumbers](argv);
        }
        if (runGlobalMiddleware) {
            argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
        }
        return argv;
    }
    [kReset](aliases = {}) {
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
        const tmpOptions = {};
        tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
        tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
        const localLookup = {};
        tmpOptions.local.forEach((l)=>{
            localLookup[l] = true;
            (aliases[l] || []).forEach((a)=>{
                localLookup[a] = true;
            });
        });
        Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName)=>{
            const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key)=>!(key in localLookup));
            if (keys.length > 0) {
                acc[groupName] = keys;
            }
            return acc;
        }, {}));
        __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
        const arrayOptions = [
            'array',
            'boolean',
            'string',
            'skipValidation',
            'count',
            'normalize',
            'number',
            'hiddenOptions'
        ];
        const objectOptions = [
            'narg',
            'key',
            'alias',
            'default',
            'defaultDescription',
            'config',
            'choices',
            'demandedOptions',
            'demandedCommands',
            'deprecatedOptions'
        ];
        arrayOptions.forEach((k)=>{
            tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k)=>!localLookup[k]);
        });
        objectOptions.forEach((k)=>{
            tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k)=>!localLookup[k]);
        });
        tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f")) __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_output, '', "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
        this.parsed = false;
        return this;
    }
    [kRebase](base, dir) {
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
    }
    [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
        let skipValidation = !!calledFromCommand || helpOnly;
        args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
        const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration['populate--'];
        const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
            'populate--': true
        });
        const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
            configuration: {
                'parse-positional-numbers': false,
                ...config
            }
        }));
        const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
        let argvPromise = undefined;
        const aliases = parsed.aliases;
        let helpOptSet = false;
        let versionOptSet = false;
        Object.keys(argv).forEach((key)=>{
            if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
                helpOptSet = true;
            } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
                versionOptSet = true;
            }
        });
        argv.$0 = this.$0;
        this.parsed = parsed;
        if (commandIndex === 0) {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
        }
        try {
            this[kGuessLocale]();
            if (shortCircuit) {
                return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
            }
            if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
                const helpCmds = [
                    __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")
                ].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k)=>k.length > 1);
                if (helpCmds.includes('' + argv._[argv._.length - 1])) {
                    argv._.pop();
                    helpOptSet = true;
                }
            }
            const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
            const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
            const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
            if (argv._.length) {
                if (handlerKeys.length) {
                    let firstUnknownCommand;
                    for(let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++){
                        cmd = String(argv._[i]);
                        if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                            const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
                            return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                        } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                            firstUnknownCommand = cmd;
                            break;
                        }
                    }
                    if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
                        __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
                    }
                }
                if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    this.showCompletionScript();
                    this.exit(0);
                }
            }
            if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
                const innerArgv1 = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
                return this[kPostProcess](innerArgv1, populateDoubleDash, !!calledFromCommand, false);
            }
            if (requestCompletions) {
                if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
                __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions)=>{
                    if (err) throw new YError(err.message);
                    (completions || []).forEach((completion)=>{
                        __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion);
                    });
                    this.exit(0);
                });
                return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
            }
            if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
                if (helpOptSet) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    skipValidation = true;
                    this.showHelp('log');
                    this.exit(0);
                } else if (versionOptSet) {
                    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                    skipValidation = true;
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion('log');
                    this.exit(0);
                }
            }
            if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
                skipValidation = Object.keys(argv).some((key)=>__classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
            }
            if (!skipValidation) {
                if (parsed.error) throw new YError(parsed.error.message);
                if (!requestCompletions) {
                    const validation = this[kRunValidation](aliases, {}, parsed.error);
                    if (!calledFromCommand) {
                        argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
                    }
                    argvPromise = this[kValidateAsync](validation, argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv);
                    if (isPromise(argvPromise) && !calledFromCommand) {
                        argvPromise = argvPromise.then(()=>{
                            return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
                        });
                    }
                }
            }
        } catch (err) {
            if (err instanceof YError) __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
            else throw err;
        }
        return this[kPostProcess](argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
    }
    [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
        const demandedOptions = {
            ...this.getDemandedOptions()
        };
        return (argv)=>{
            if (parseErrors) throw new YError(parseErrors.message);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
            let failedStrictCommands = false;
            if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
                failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
            }
            if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
            } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
            }
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
        };
    }
    [kSetHasOutput]() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    }
    [kTrackManuallySetKeys](keys) {
        if (typeof keys === 'string') {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        } else {
            for (const k of keys){
                __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
            }
        }
    }
}
function isCommandBuilderOptionDefinitions(builder) {
    return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) {
    return typeof cmd === 'object' && !Array.isArray(cmd);
}
function isSyncCompletionFunction(completionFunction) {
    return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
    return completionFunction.length > 3;
}
const Yargs = YargsFactory(__default5);
"use strict";
const MAX_BITS = 15;
const D_CODES = 30;
const BL_CODES = 19;
const LITERALS = 256;
const L_CODES = 256 + 1 + 29;
const HEAP_SIZE = 2 * L_CODES + 1;
const END_BLOCK = 256;
const MAX_BL_BITS = 7;
const Buf_size = 8 * 2;
const Z_DEFAULT_COMPRESSION = -1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;
const Z_NO_FLUSH = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH = 4;
const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_BUF_ERROR = -5;
function extractArray(array) {
    return flatArray(array.map(([length, value])=>new Array(length).fill(value, 0, length)));
}
function flatArray(array) {
    return array.reduce((a, b)=>a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}
const _dist_code = [
    0,
    1,
    2,
    3
].concat(...extractArray([
    [
        2,
        4
    ],
    [
        2,
        5
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        8,
        8
    ],
    [
        8,
        9
    ],
    [
        16,
        10
    ],
    [
        16,
        11
    ],
    [
        32,
        12
    ],
    [
        32,
        13
    ],
    [
        64,
        14
    ],
    [
        64,
        15
    ],
    [
        2,
        0
    ],
    [
        1,
        16
    ],
    [
        1,
        17
    ],
    [
        2,
        18
    ],
    [
        2,
        19
    ],
    [
        4,
        20
    ],
    [
        4,
        21
    ],
    [
        8,
        22
    ],
    [
        8,
        23
    ],
    [
        16,
        24
    ],
    [
        16,
        25
    ],
    [
        32,
        26
    ],
    [
        32,
        27
    ],
    [
        64,
        28
    ],
    [
        64,
        29
    ]
]));
function Tree() {
    const that = this;
    function gen_bitlen(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const extra = that.stat_desc.extra_bits;
        const base = that.stat_desc.extra_base;
        const max_length = that.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for(bits = 0; bits <= 15; bits++)s.bl_count[bits] = 0;
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for(h = s.heap_max + 1; h < HEAP_SIZE; h++){
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > that.max_code) continue;
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) xbits = extra[n - base];
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
        if (overflow === 0) return;
        do {
            bits = max_length - 1;
            while(s.bl_count[bits] === 0)bits--;
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        }while (overflow > 0)
        for(bits = max_length; bits !== 0; bits--){
            n = s.bl_count[bits];
            while(n !== 0){
                m = s.heap[--h];
                if (m > that.max_code) continue;
                if (tree[m * 2 + 1] != bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    }
    function bi_reverse(code, len) {
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        }while (--len > 0)
        return res >>> 1;
    }
    function gen_codes(tree, max_code, bl_count) {
        const next_code = [];
        let code = 0;
        let bits;
        let n;
        let len;
        for(bits = 1; bits <= 15; bits++){
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for(n = 0; n <= max_code; n++){
            len = tree[n * 2 + 1];
            if (len === 0) continue;
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    }
    that.build_tree = function(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const elems = that.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for(n = 0; n < elems; n++){
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while(s.heap_len < 2){
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (stree) s.static_len -= stree[node * 2 + 1];
        }
        that.max_code = max_code;
        for(n = Math.floor(s.heap_len / 2); n >= 1; n--)s.pqdownheap(tree, n);
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            s.pqdownheap(tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            s.pqdownheap(tree, 1);
        }while (s.heap_len >= 2)
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s);
        gen_codes(tree, that.max_code, s.bl_count);
    };
}
Tree._length_code = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7
].concat(...extractArray([
    [
        2,
        8
    ],
    [
        2,
        9
    ],
    [
        2,
        10
    ],
    [
        2,
        11
    ],
    [
        4,
        12
    ],
    [
        4,
        13
    ],
    [
        4,
        14
    ],
    [
        4,
        15
    ],
    [
        8,
        16
    ],
    [
        8,
        17
    ],
    [
        8,
        18
    ],
    [
        8,
        19
    ],
    [
        16,
        20
    ],
    [
        16,
        21
    ],
    [
        16,
        22
    ],
    [
        16,
        23
    ],
    [
        32,
        24
    ],
    [
        32,
        25
    ],
    [
        32,
        26
    ],
    [
        31,
        27
    ],
    [
        1,
        28
    ]
]));
Tree.base_length = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    28,
    32,
    40,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    160,
    192,
    224,
    0
];
Tree.base_dist = [
    0,
    1,
    2,
    3,
    4,
    6,
    8,
    12,
    16,
    24,
    32,
    48,
    64,
    96,
    128,
    192,
    256,
    384,
    512,
    768,
    1024,
    1536,
    2048,
    3072,
    4096,
    6144,
    8192,
    12288,
    16384,
    24576
];
Tree.d_code = function(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
Tree.extra_lbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
];
Tree.extra_dbits = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
Tree.extra_blbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
];
Tree.bl_order = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
    const that = this;
    that.static_tree = static_tree;
    that.extra_bits = extra_bits;
    that.extra_base = extra_base;
    that.elems = elems;
    that.max_length = max_length;
}
StaticTree.static_ltree = [
    12,
    8,
    140,
    8,
    76,
    8,
    204,
    8,
    44,
    8,
    172,
    8,
    108,
    8,
    236,
    8,
    28,
    8,
    156,
    8,
    92,
    8,
    220,
    8,
    60,
    8,
    188,
    8,
    124,
    8,
    252,
    8,
    2,
    8,
    130,
    8,
    66,
    8,
    194,
    8,
    34,
    8,
    162,
    8,
    98,
    8,
    226,
    8,
    18,
    8,
    146,
    8,
    82,
    8,
    210,
    8,
    50,
    8,
    178,
    8,
    114,
    8,
    242,
    8,
    10,
    8,
    138,
    8,
    74,
    8,
    202,
    8,
    42,
    8,
    170,
    8,
    106,
    8,
    234,
    8,
    26,
    8,
    154,
    8,
    90,
    8,
    218,
    8,
    58,
    8,
    186,
    8,
    122,
    8,
    250,
    8,
    6,
    8,
    134,
    8,
    70,
    8,
    198,
    8,
    38,
    8,
    166,
    8,
    102,
    8,
    230,
    8,
    22,
    8,
    150,
    8,
    86,
    8,
    214,
    8,
    54,
    8,
    182,
    8,
    118,
    8,
    246,
    8,
    14,
    8,
    142,
    8,
    78,
    8,
    206,
    8,
    46,
    8,
    174,
    8,
    110,
    8,
    238,
    8,
    30,
    8,
    158,
    8,
    94,
    8,
    222,
    8,
    62,
    8,
    190,
    8,
    126,
    8,
    254,
    8,
    1,
    8,
    129,
    8,
    65,
    8,
    193,
    8,
    33,
    8,
    161,
    8,
    97,
    8,
    225,
    8,
    17,
    8,
    145,
    8,
    81,
    8,
    209,
    8,
    49,
    8,
    177,
    8,
    113,
    8,
    241,
    8,
    9,
    8,
    137,
    8,
    73,
    8,
    201,
    8,
    41,
    8,
    169,
    8,
    105,
    8,
    233,
    8,
    25,
    8,
    153,
    8,
    89,
    8,
    217,
    8,
    57,
    8,
    185,
    8,
    121,
    8,
    249,
    8,
    5,
    8,
    133,
    8,
    69,
    8,
    197,
    8,
    37,
    8,
    165,
    8,
    101,
    8,
    229,
    8,
    21,
    8,
    149,
    8,
    85,
    8,
    213,
    8,
    53,
    8,
    181,
    8,
    117,
    8,
    245,
    8,
    13,
    8,
    141,
    8,
    77,
    8,
    205,
    8,
    45,
    8,
    173,
    8,
    109,
    8,
    237,
    8,
    29,
    8,
    157,
    8,
    93,
    8,
    221,
    8,
    61,
    8,
    189,
    8,
    125,
    8,
    253,
    8,
    19,
    9,
    275,
    9,
    147,
    9,
    403,
    9,
    83,
    9,
    339,
    9,
    211,
    9,
    467,
    9,
    51,
    9,
    307,
    9,
    179,
    9,
    435,
    9,
    115,
    9,
    371,
    9,
    243,
    9,
    499,
    9,
    11,
    9,
    267,
    9,
    139,
    9,
    395,
    9,
    75,
    9,
    331,
    9,
    203,
    9,
    459,
    9,
    43,
    9,
    299,
    9,
    171,
    9,
    427,
    9,
    107,
    9,
    363,
    9,
    235,
    9,
    491,
    9,
    27,
    9,
    283,
    9,
    155,
    9,
    411,
    9,
    91,
    9,
    347,
    9,
    219,
    9,
    475,
    9,
    59,
    9,
    315,
    9,
    187,
    9,
    443,
    9,
    123,
    9,
    379,
    9,
    251,
    9,
    507,
    9,
    7,
    9,
    263,
    9,
    135,
    9,
    391,
    9,
    71,
    9,
    327,
    9,
    199,
    9,
    455,
    9,
    39,
    9,
    295,
    9,
    167,
    9,
    423,
    9,
    103,
    9,
    359,
    9,
    231,
    9,
    487,
    9,
    23,
    9,
    279,
    9,
    151,
    9,
    407,
    9,
    87,
    9,
    343,
    9,
    215,
    9,
    471,
    9,
    55,
    9,
    311,
    9,
    183,
    9,
    439,
    9,
    119,
    9,
    375,
    9,
    247,
    9,
    503,
    9,
    15,
    9,
    271,
    9,
    143,
    9,
    399,
    9,
    79,
    9,
    335,
    9,
    207,
    9,
    463,
    9,
    47,
    9,
    303,
    9,
    175,
    9,
    431,
    9,
    111,
    9,
    367,
    9,
    239,
    9,
    495,
    9,
    31,
    9,
    287,
    9,
    159,
    9,
    415,
    9,
    95,
    9,
    351,
    9,
    223,
    9,
    479,
    9,
    63,
    9,
    319,
    9,
    191,
    9,
    447,
    9,
    127,
    9,
    383,
    9,
    255,
    9,
    511,
    9,
    0,
    7,
    64,
    7,
    32,
    7,
    96,
    7,
    16,
    7,
    80,
    7,
    48,
    7,
    112,
    7,
    8,
    7,
    72,
    7,
    40,
    7,
    104,
    7,
    24,
    7,
    88,
    7,
    56,
    7,
    120,
    7,
    4,
    7,
    68,
    7,
    36,
    7,
    100,
    7,
    20,
    7,
    84,
    7,
    52,
    7,
    116,
    7,
    3,
    8,
    131,
    8,
    67,
    8,
    195,
    8,
    35,
    8,
    163,
    8,
    99,
    8,
    227,
    8
];
StaticTree.static_dtree = [
    0,
    5,
    16,
    5,
    8,
    5,
    24,
    5,
    4,
    5,
    20,
    5,
    12,
    5,
    28,
    5,
    2,
    5,
    18,
    5,
    10,
    5,
    26,
    5,
    6,
    5,
    22,
    5,
    14,
    5,
    30,
    5,
    1,
    5,
    17,
    5,
    9,
    5,
    25,
    5,
    5,
    5,
    21,
    5,
    13,
    5,
    29,
    5,
    3,
    5,
    19,
    5,
    11,
    5,
    27,
    5,
    7,
    5,
    23,
    5
];
StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    const that = this;
    that.good_length = good_length;
    that.max_lazy = max_lazy;
    that.nice_length = nice_length;
    that.max_chain = max_chain;
    that.func = func;
}
const STORED = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
    new Config(0, 0, 0, 0, 0),
    new Config(4, 4, 8, 4, 1),
    new Config(4, 5, 16, 8, 1),
    new Config(4, 6, 32, 32, 1),
    new Config(4, 4, 16, 16, 2),
    new Config(8, 16, 32, 32, 2),
    new Config(8, 16, 128, 128, 2),
    new Config(8, 32, 128, 256, 2),
    new Config(32, 128, 258, 1024, 2),
    new Config(32, 258, 258, 4096, 2)
];
const z_errmsg = [
    "need dictionary",
    "stream end",
    "",
    "",
    "stream error",
    "data error",
    "",
    "buffer error",
    "",
    ""
];
const NeedMore = 0;
const BlockDone = 1;
const FinishStarted = 2;
const FinishDone = 3;
const PRESET_DICT = 0x20;
const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const Z_DEFLATED = 8;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
function smaller(tree, n, m, depth) {
    const tn2 = tree[n * 2];
    const tm2 = tree[m * 2];
    return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
}
function Deflate() {
    const that = this;
    let strm;
    let status;
    let pending_buf_size;
    let last_flush;
    let w_size;
    let w_bits;
    let w_mask;
    let window1;
    let window_size;
    let prev;
    let head;
    let ins_h;
    let hash_size;
    let hash_bits;
    let hash_mask;
    let hash_shift;
    let block_start;
    let match_length;
    let prev_match;
    let match_available;
    let strstart;
    let match_start;
    let lookahead;
    let prev_length;
    let max_chain_length;
    let max_lazy_match;
    let level;
    let strategy;
    let good_match;
    let nice_match;
    let dyn_ltree;
    let dyn_dtree;
    let bl_tree;
    const l_desc = new Tree();
    const d_desc = new Tree();
    const bl_desc = new Tree();
    that.depth = [];
    let l_buf;
    let lit_bufsize;
    let last_lit;
    let d_buf;
    let matches;
    let last_eob_len;
    let bi_buf;
    let bi_valid;
    that.bl_count = [];
    that.heap = [];
    dyn_ltree = [];
    dyn_dtree = [];
    bl_tree = [];
    function lm_init() {
        window_size = 2 * w_size;
        head[hash_size - 1] = 0;
        for(let i = 0; i < hash_size - 1; i++){
            head[i] = 0;
        }
        max_lazy_match = config_table[level].max_lazy;
        good_match = config_table[level].good_length;
        nice_match = config_table[level].nice_length;
        max_chain_length = config_table[level].max_chain;
        strstart = 0;
        block_start = 0;
        lookahead = 0;
        match_length = prev_length = MIN_MATCH - 1;
        match_available = 0;
        ins_h = 0;
    }
    function init_block() {
        let i;
        for(i = 0; i < L_CODES; i++)dyn_ltree[i * 2] = 0;
        for(i = 0; i < 30; i++)dyn_dtree[i * 2] = 0;
        for(i = 0; i < 19; i++)bl_tree[i * 2] = 0;
        dyn_ltree[END_BLOCK * 2] = 1;
        that.opt_len = that.static_len = 0;
        last_lit = matches = 0;
    }
    function tr_init() {
        l_desc.dyn_tree = dyn_ltree;
        l_desc.stat_desc = StaticTree.static_l_desc;
        d_desc.dyn_tree = dyn_dtree;
        d_desc.stat_desc = StaticTree.static_d_desc;
        bl_desc.dyn_tree = bl_tree;
        bl_desc.stat_desc = StaticTree.static_bl_desc;
        bi_buf = 0;
        bi_valid = 0;
        last_eob_len = 8;
        init_block();
    }
    that.pqdownheap = function(tree, k) {
        const heap = that.heap;
        const v = heap[k];
        let j = k << 1;
        while(j <= that.heap_len){
            if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
                j++;
            }
            if (smaller(tree, v, heap[j], that.depth)) break;
            heap[k] = heap[j];
            k = j;
            j <<= 1;
        }
        heap[k] = v;
    };
    function scan_tree(tree, max_code) {
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 0xffff;
        for(let n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen != prevlen) bl_tree[curlen * 2]++;
                bl_tree[16 * 2]++;
            } else if (count <= 10) {
                bl_tree[17 * 2]++;
            } else {
                bl_tree[18 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function build_bl_tree() {
        let max_blindex;
        scan_tree(dyn_ltree, l_desc.max_code);
        scan_tree(dyn_dtree, d_desc.max_code);
        bl_desc.build_tree(that);
        for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){
            if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0) break;
        }
        that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    }
    function put_byte(p) {
        that.pending_buf[that.pending++] = p;
    }
    function put_short(w) {
        put_byte(w & 0xff);
        put_byte(w >>> 8 & 0xff);
    }
    function putShortMSB(b) {
        put_byte(b >> 8 & 0xff);
        put_byte(b & 0xff & 0xff);
    }
    function send_bits(value, length) {
        let val;
        const len = length;
        if (bi_valid > Buf_size - len) {
            val = value;
            bi_buf |= val << bi_valid & 0xffff;
            put_short(bi_buf);
            bi_buf = val >>> Buf_size - bi_valid;
            bi_valid += len - Buf_size;
        } else {
            bi_buf |= value << bi_valid & 0xffff;
            bi_valid += len;
        }
    }
    function send_code(c, tree) {
        const c2 = c * 2;
        send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
    }
    function send_tree(tree, max_code) {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for(n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(curlen, bl_tree);
                }while (--count !== 0)
            } else if (curlen !== 0) {
                if (curlen != prevlen) {
                    send_code(curlen, bl_tree);
                    count--;
                }
                send_code(16, bl_tree);
                send_bits(count - 3, 2);
            } else if (count <= 10) {
                send_code(17, bl_tree);
                send_bits(count - 3, 3);
            } else {
                send_code(18, bl_tree);
                send_bits(count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function send_all_trees(lcodes, dcodes, blcodes) {
        let rank;
        send_bits(lcodes - 257, 5);
        send_bits(dcodes - 1, 5);
        send_bits(blcodes - 4, 4);
        for(rank = 0; rank < blcodes; rank++){
            send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
        }
        send_tree(dyn_ltree, lcodes - 1);
        send_tree(dyn_dtree, dcodes - 1);
    }
    function bi_flush() {
        if (bi_valid == 16) {
            put_short(bi_buf);
            bi_buf = 0;
            bi_valid = 0;
        } else if (bi_valid >= 8) {
            put_byte(bi_buf & 0xff);
            bi_buf >>>= 8;
            bi_valid -= 8;
        }
    }
    function _tr_align() {
        send_bits(1 << 1, 3);
        send_code(256, StaticTree.static_ltree);
        bi_flush();
        if (1 + last_eob_len + 10 - bi_valid < 9) {
            send_bits(1 << 1, 3);
            send_code(256, StaticTree.static_ltree);
            bi_flush();
        }
        last_eob_len = 7;
    }
    function _tr_tally(dist, lc) {
        let out_length, in_length, dcode;
        that.pending_buf[d_buf + last_lit * 2] = dist >>> 8 & 0xff;
        that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;
        that.pending_buf[l_buf + last_lit] = lc & 0xff;
        last_lit++;
        if (dist === 0) {
            dyn_ltree[lc * 2]++;
        } else {
            matches++;
            dist--;
            dyn_ltree[(Tree._length_code[lc] + 256 + 1) * 2]++;
            dyn_dtree[Tree.d_code(dist) * 2]++;
        }
        if ((last_lit & 0x1fff) === 0 && level > 2) {
            out_length = last_lit * 8;
            in_length = strstart - block_start;
            for(dcode = 0; dcode < 30; dcode++){
                out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
            }
            out_length >>>= 3;
            if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2)) return true;
        }
        return last_lit == lit_bufsize - 1;
    }
    function compress_block(ltree, dtree) {
        let dist;
        let lc;
        let lx = 0;
        let code;
        let extra;
        if (last_lit !== 0) {
            do {
                dist = that.pending_buf[d_buf + lx * 2] << 8 & 0xff00 | that.pending_buf[d_buf + lx * 2 + 1] & 0xff;
                lc = that.pending_buf[l_buf + lx] & 0xff;
                lx++;
                if (dist === 0) {
                    send_code(lc, ltree);
                } else {
                    code = Tree._length_code[lc];
                    send_code(code + 256 + 1, ltree);
                    extra = Tree.extra_lbits[code];
                    if (extra !== 0) {
                        lc -= Tree.base_length[code];
                        send_bits(lc, extra);
                    }
                    dist--;
                    code = Tree.d_code(dist);
                    send_code(code, dtree);
                    extra = Tree.extra_dbits[code];
                    if (extra !== 0) {
                        dist -= Tree.base_dist[code];
                        send_bits(dist, extra);
                    }
                }
            }while (lx < last_lit)
        }
        send_code(256, ltree);
        last_eob_len = ltree[END_BLOCK * 2 + 1];
    }
    function bi_windup() {
        if (bi_valid > 8) {
            put_short(bi_buf);
        } else if (bi_valid > 0) {
            put_byte(bi_buf & 0xff);
        }
        bi_buf = 0;
        bi_valid = 0;
    }
    function copy_block(buf, len, header) {
        bi_windup();
        last_eob_len = 8;
        if (header) {
            put_short(len);
            put_short(~len);
        }
        that.pending_buf.set(window1.subarray(buf, buf + len), that.pending);
        that.pending += len;
    }
    function _tr_stored_block(buf, stored_len, eof) {
        send_bits((0 << 1) + (eof ? 1 : 0), 3);
        copy_block(buf, stored_len, true);
    }
    function _tr_flush_block(buf, stored_len, eof) {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (level > 0) {
            l_desc.build_tree(that);
            d_desc.build_tree(that);
            max_blindex = build_bl_tree();
            opt_lenb = that.opt_len + 3 + 7 >>> 3;
            static_lenb = that.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf != -1) {
            _tr_stored_block(buf, stored_len, eof);
        } else if (static_lenb == opt_lenb) {
            send_bits((1 << 1) + (eof ? 1 : 0), 3);
            compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
        } else {
            send_bits((2 << 1) + (eof ? 1 : 0), 3);
            send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
            compress_block(dyn_ltree, dyn_dtree);
        }
        init_block();
        if (eof) {
            bi_windup();
        }
    }
    function flush_block_only(eof) {
        _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
        block_start = strstart;
        strm.flush_pending();
    }
    function fill_window() {
        let n, m;
        let p;
        let more;
        do {
            more = window_size - lookahead - strstart;
            if (more === 0 && strstart === 0 && lookahead === 0) {
                more = w_size;
            } else if (more == -1) {
                more--;
            } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
                window1.set(window1.subarray(w_size, w_size + w_size), 0);
                match_start -= w_size;
                strstart -= w_size;
                block_start -= w_size;
                n = hash_size;
                p = n;
                do {
                    m = head[--p] & 0xffff;
                    head[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                n = w_size;
                p = n;
                do {
                    m = prev[--p] & 0xffff;
                    prev[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                more += w_size;
            }
            if (strm.avail_in === 0) return;
            n = strm.read_buf(window1, strstart + lookahead, more);
            lookahead += n;
            if (lookahead >= 3) {
                ins_h = window1[strstart] & 0xff;
                ins_h = (ins_h << hash_shift ^ window1[strstart + 1] & 0xff) & hash_mask;
            }
        }while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0)
    }
    function deflate_stored(flush) {
        let max_block_size = 0xffff;
        let max_start;
        if (max_block_size > pending_buf_size - 5) {
            max_block_size = pending_buf_size - 5;
        }
        while(true){
            if (lookahead <= 1) {
                fill_window();
                if (lookahead === 0 && flush == 0) return 0;
                if (lookahead === 0) break;
            }
            strstart += lookahead;
            lookahead = 0;
            max_start = block_start + max_block_size;
            if (strstart === 0 || strstart >= max_start) {
                lookahead = strstart - max_start;
                strstart = max_start;
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
            if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) return flush == 4 ? 2 : 0;
        return flush == 4 ? 3 : 1;
    }
    function longest_match(cur_match) {
        let chain_length = max_chain_length;
        let scan = strstart;
        let match;
        let len;
        let best_len = prev_length;
        const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
        let _nice_match = nice_match;
        const wmask = w_mask;
        const strend = strstart + 258;
        let scan_end1 = window1[scan + best_len - 1];
        let scan_end = window1[scan + best_len];
        if (prev_length >= good_match) {
            chain_length >>= 2;
        }
        if (_nice_match > lookahead) _nice_match = lookahead;
        do {
            match = cur_match;
            if (window1[match + best_len] != scan_end || window1[match + best_len - 1] != scan_end1 || window1[match] != window1[scan] || window1[++match] != window1[scan + 1]) continue;
            scan += 2;
            match++;
            do {}while (window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && window1[++scan] == window1[++match] && scan < strend)
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                match_start = cur_match;
                best_len = len;
                if (len >= _nice_match) break;
                scan_end1 = window1[scan + best_len - 1];
                scan_end = window1[scan + best_len];
            }
        }while ((cur_match = prev[cur_match & wmask] & 0xffff) > limit && --chain_length !== 0)
        if (best_len <= lookahead) return best_len;
        return lookahead;
    }
    function deflate_fast(flush) {
        let hash_head = 0;
        let bflush;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ window1[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                hash_head = head[ins_h] & 0xffff;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            if (hash_head !== 0 && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
            }
            if (match_length >= 3) {
                bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
                lookahead -= match_length;
                if (match_length <= max_lazy_match && lookahead >= 3) {
                    match_length--;
                    do {
                        strstart++;
                        ins_h = (ins_h << hash_shift ^ window1[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                        hash_head = head[ins_h] & 0xffff;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }while (--match_length !== 0)
                    strstart++;
                } else {
                    strstart += match_length;
                    match_length = 0;
                    ins_h = window1[strstart] & 0xff;
                    ins_h = (ins_h << hash_shift ^ window1[strstart + 1] & 0xff) & hash_mask;
                }
            } else {
                bflush = _tr_tally(0, window1[strstart] & 0xff);
                lookahead--;
                strstart++;
            }
            if (bflush) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflate_slow(flush) {
        let hash_head = 0;
        let bflush;
        let max_insert;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ window1[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                hash_head = head[ins_h] & 0xffff;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            prev_length = match_length;
            prev_match = match_start;
            match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
                if (match_length <= 5 && (strategy == 1 || match_length == 3 && strstart - match_start > 4096)) {
                    match_length = MIN_MATCH - 1;
                }
            }
            if (prev_length >= 3 && match_length <= prev_length) {
                max_insert = strstart + lookahead - MIN_MATCH;
                bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
                lookahead -= prev_length - 1;
                prev_length -= 2;
                do {
                    if (++strstart <= max_insert) {
                        ins_h = (ins_h << hash_shift ^ window1[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                        hash_head = head[ins_h] & 0xffff;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }
                }while (--prev_length !== 0)
                match_available = 0;
                match_length = MIN_MATCH - 1;
                strstart++;
                if (bflush) {
                    flush_block_only(false);
                    if (strm.avail_out === 0) return 0;
                }
            } else if (match_available !== 0) {
                bflush = _tr_tally(0, window1[strstart - 1] & 0xff);
                if (bflush) {
                    flush_block_only(false);
                }
                strstart++;
                lookahead--;
                if (strm.avail_out === 0) return 0;
            } else {
                match_available = 1;
                strstart++;
                lookahead--;
            }
        }
        if (match_available !== 0) {
            bflush = _tr_tally(0, window1[strstart - 1] & 0xff);
            match_available = 0;
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflateReset(strm) {
        strm.total_in = strm.total_out = 0;
        strm.msg = null;
        that.pending = 0;
        that.pending_out = 0;
        status = BUSY_STATE;
        last_flush = Z_NO_FLUSH;
        tr_init();
        lm_init();
        return 0;
    }
    that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {
        if (!_method) _method = Z_DEFLATED;
        if (!memLevel) memLevel = DEF_MEM_LEVEL;
        if (!_strategy) _strategy = Z_DEFAULT_STRATEGY;
        strm.msg = null;
        if (_level == Z_DEFAULT_COMPRESSION) _level = 6;
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        strm.dstate = that;
        w_bits = bits;
        w_size = 1 << w_bits;
        w_mask = w_size - 1;
        hash_bits = memLevel + 7;
        hash_size = 1 << hash_bits;
        hash_mask = hash_size - 1;
        hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        window1 = new Uint8Array(w_size * 2);
        prev = [];
        head = [];
        lit_bufsize = 1 << memLevel + 6;
        that.pending_buf = new Uint8Array(lit_bufsize * 4);
        pending_buf_size = lit_bufsize * 4;
        d_buf = Math.floor(lit_bufsize / 2);
        l_buf = (1 + 2) * lit_bufsize;
        level = _level;
        strategy = _strategy;
        return deflateReset(strm);
    };
    that.deflateEnd = function() {
        if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
            return Z_STREAM_ERROR;
        }
        that.pending_buf = null;
        head = null;
        prev = null;
        window1 = null;
        that.dstate = null;
        return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
    };
    that.deflateParams = function(strm, _level, _strategy) {
        let err = Z_OK;
        if (_level == Z_DEFAULT_COMPRESSION) {
            _level = 6;
        }
        if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
            err = strm.deflate(Z_PARTIAL_FLUSH);
        }
        if (level != _level) {
            level = _level;
            max_lazy_match = config_table[level].max_lazy;
            good_match = config_table[level].good_length;
            nice_match = config_table[level].nice_length;
            max_chain_length = config_table[level].max_chain;
        }
        strategy = _strategy;
        return err;
    };
    that.deflateSetDictionary = function(strm, dictionary, dictLength) {
        let length = dictLength;
        let n, index = 0;
        if (!dictionary || status != INIT_STATE) return Z_STREAM_ERROR;
        if (length < MIN_MATCH) return Z_OK;
        if (length > w_size - MIN_LOOKAHEAD) {
            length = w_size - MIN_LOOKAHEAD;
            index = dictLength - length;
        }
        window1.set(dictionary.subarray(index, index + length), 0);
        strstart = length;
        block_start = length;
        ins_h = window1[0] & 0xff;
        ins_h = (ins_h << hash_shift ^ window1[1] & 0xff) & hash_mask;
        for(n = 0; n <= length - MIN_MATCH; n++){
            ins_h = (ins_h << hash_shift ^ window1[n + (MIN_MATCH - 1)] & 0xff) & hash_mask;
            prev[n & w_mask] = head[ins_h];
            head[ins_h] = n;
        }
        return Z_OK;
    };
    that.deflate = function(_strm, flush) {
        let i, header, level_flags, old_flush, bstate;
        if (flush > Z_FINISH || flush < 0) {
            return Z_STREAM_ERROR;
        }
        if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];
            return Z_STREAM_ERROR;
        }
        if (_strm.avail_out === 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        strm = _strm;
        old_flush = last_flush;
        last_flush = flush;
        if (status == INIT_STATE) {
            header = Z_DEFLATED + (w_bits - 8 << 4) << 8;
            level_flags = (level - 1 & 0xff) >> 1;
            if (level_flags > 3) level_flags = 3;
            header |= level_flags << 6;
            if (strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            status = BUSY_STATE;
            putShortMSB(header);
        }
        if (that.pending !== 0) {
            strm.flush_pending();
            if (strm.avail_out === 0) {
                last_flush = -1;
                return Z_OK;
            }
        } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
            strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (status == FINISH_STATE && strm.avail_in !== 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {
            bstate = -1;
            switch(config_table[level].func){
                case STORED:
                    bstate = deflate_stored(flush);
                    break;
                case FAST:
                    bstate = deflate_fast(flush);
                    break;
                case SLOW:
                    bstate = deflate_slow(flush);
                    break;
                default:
            }
            if (bstate == FinishStarted || bstate == FinishDone) {
                status = FINISH_STATE;
            }
            if (bstate == NeedMore || bstate == FinishStarted) {
                if (strm.avail_out === 0) {
                    last_flush = -1;
                }
                return Z_OK;
            }
            if (bstate == BlockDone) {
                if (flush == Z_PARTIAL_FLUSH) {
                    _tr_align();
                } else {
                    _tr_stored_block(0, 0, false);
                    if (flush == Z_FULL_FLUSH) {
                        for(i = 0; i < hash_size; i++)head[i] = 0;
                    }
                }
                strm.flush_pending();
                if (strm.avail_out === 0) {
                    last_flush = -1;
                    return Z_OK;
                }
            }
        }
        if (flush != Z_FINISH) return Z_OK;
        return Z_STREAM_END;
    };
}
function ZStream() {
    const that = this;
    that.next_in_index = 0;
    that.next_out_index = 0;
    that.avail_in = 0;
    that.total_in = 0;
    that.avail_out = 0;
    that.total_out = 0;
}
ZStream.prototype = {
    deflateInit: function(level, bits) {
        const that = this;
        that.dstate = new Deflate();
        if (!bits) bits = MAX_BITS;
        return that.dstate.deflateInit(that, level, bits);
    },
    deflate: function(flush) {
        const that = this;
        if (!that.dstate) {
            return Z_STREAM_ERROR;
        }
        return that.dstate.deflate(that, flush);
    },
    deflateEnd: function() {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        const ret = that.dstate.deflateEnd();
        that.dstate = null;
        return ret;
    },
    deflateParams: function(level, strategy) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateParams(that, level, strategy);
    },
    deflateSetDictionary: function(dictionary, dictLength) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
    },
    read_buf: function(buf, start, size) {
        const that = this;
        let len = that.avail_in;
        if (len > size) len = size;
        if (len === 0) return 0;
        that.avail_in -= len;
        buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
        that.next_in_index += len;
        that.total_in += len;
        return len;
    },
    flush_pending: function() {
        const that = this;
        let len = that.dstate.pending;
        if (len > that.avail_out) len = that.avail_out;
        if (len === 0) return;
        that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
        that.next_out_index += len;
        that.dstate.pending_out += len;
        that.total_out += len;
        that.avail_out -= len;
        that.dstate.pending -= len;
        if (that.dstate.pending === 0) {
            that.dstate.pending_out = 0;
        }
    }
};
function ZipDeflate(options) {
    const that = this;
    const z = new ZStream();
    const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let level = options ? options.level : Z_DEFAULT_COMPRESSION;
    if (typeof level == "undefined") level = Z_DEFAULT_COMPRESSION;
    z.deflateInit(level);
    z.next_out = buf;
    that.append = function(data, onprogress) {
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        if (!data.length) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(flush);
            if (err != Z_OK) throw new Error("deflating: " + z.msg);
            if (z.next_out_index) if (z.next_out_index == bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] || new Uint8Array(0);
        }
        return array;
    };
    that.flush = function() {
        let err, array, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(Z_FINISH);
            if (err != Z_STREAM_END && err != Z_OK) throw new Error("deflating: " + z.msg);
            if (bufsize - z.avail_out > 0) buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
        }while (z.avail_in > 0 || z.avail_out === 0)
        z.deflateEnd();
        array = new Uint8Array(bufferSize);
        buffers.forEach(function(chunk) {
            array.set(chunk, bufferIndex);
            bufferIndex += chunk.length;
        });
        return array;
    };
}
function getMaximumCompressedSize(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
"use strict";
const MAX_BITS1 = 15;
const Z_OK1 = 0;
const Z_STREAM_END1 = 1;
const Z_NEED_DICT1 = 2;
const Z_STREAM_ERROR1 = -2;
const Z_DATA_ERROR1 = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR1 = -5;
const inflate_mask = [
    0x00000000,
    0x00000001,
    0x00000003,
    0x00000007,
    0x0000000f,
    0x0000001f,
    0x0000003f,
    0x0000007f,
    0x000000ff,
    0x000001ff,
    0x000003ff,
    0x000007ff,
    0x00000fff,
    0x00001fff,
    0x00003fff,
    0x00007fff,
    0x0000ffff
];
const Z_FINISH1 = 4;
const fixed_bl = 9;
const fixed_bd = 5;
const fixed_tl = [
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    192,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    160,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    224,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    144,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    208,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    176,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    240,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    200,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    168,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    232,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    152,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    216,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    184,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    248,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    196,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    164,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    228,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    148,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    212,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    180,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    244,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    204,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    172,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    236,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    156,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    220,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    188,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    252,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    194,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    162,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    226,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    146,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    210,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    178,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    242,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    202,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    170,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    234,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    154,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    218,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    186,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    250,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    198,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    166,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    230,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    150,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    214,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    182,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    246,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    206,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    174,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    238,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    158,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    222,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    190,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    254,
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    193,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    161,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    225,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    145,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    209,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    177,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    241,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    201,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    169,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    233,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    153,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    217,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    185,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    249,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    197,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    165,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    229,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    149,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    213,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    181,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    245,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    205,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    173,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    237,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    157,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    221,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    189,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    253,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    195,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    163,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    227,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    147,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    211,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    179,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    243,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    203,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    171,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    235,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    155,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    219,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    187,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    251,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    199,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    167,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    231,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    151,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    215,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    183,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    247,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    207,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    175,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    239,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    159,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    223,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    191,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    255
];
const fixed_td = [
    80,
    5,
    1,
    87,
    5,
    257,
    83,
    5,
    17,
    91,
    5,
    4097,
    81,
    5,
    5,
    89,
    5,
    1025,
    85,
    5,
    65,
    93,
    5,
    16385,
    80,
    5,
    3,
    88,
    5,
    513,
    84,
    5,
    33,
    92,
    5,
    8193,
    82,
    5,
    9,
    90,
    5,
    2049,
    86,
    5,
    129,
    192,
    5,
    24577,
    80,
    5,
    2,
    87,
    5,
    385,
    83,
    5,
    25,
    91,
    5,
    6145,
    81,
    5,
    7,
    89,
    5,
    1537,
    85,
    5,
    97,
    93,
    5,
    24577,
    80,
    5,
    4,
    88,
    5,
    769,
    84,
    5,
    49,
    92,
    5,
    12289,
    82,
    5,
    13,
    90,
    5,
    3073,
    86,
    5,
    193,
    192,
    5,
    24577
];
const cplens = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
];
const cplext = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    112,
    112
];
const cpdist = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577
];
const cpdext = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
const BMAX = 15;
function InfTree() {
    const that = this;
    let hn;
    let v;
    let c;
    let r;
    let u;
    let x;
    function huft_build(b, bindex, n, s, d, e, t, m, hp, hn, v) {
        let a;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let mask;
        let p;
        let q;
        let w;
        let xp;
        let y;
        let z;
        p = 0;
        i = n;
        do {
            c[b[bindex + p]]++;
            p++;
            i--;
        }while (i !== 0)
        if (c[0] == n) {
            t[0] = -1;
            m[0] = 0;
            return 0;
        }
        l = m[0];
        for(j = 1; j <= 15; j++)if (c[j] !== 0) break;
        k = j;
        if (l < j) {
            l = j;
        }
        for(i = BMAX; i !== 0; i--){
            if (c[i] !== 0) break;
        }
        g = i;
        if (l > i) {
            l = i;
        }
        m[0] = l;
        for(y = 1 << j; j < i; j++, y <<= 1){
            if ((y -= c[j]) < 0) {
                return Z_DATA_ERROR1;
            }
        }
        if ((y -= c[i]) < 0) {
            return Z_DATA_ERROR1;
        }
        c[i] += y;
        x[1] = j = 0;
        p = 1;
        xp = 2;
        while(--i !== 0){
            x[xp] = j += c[p];
            xp++;
            p++;
        }
        i = 0;
        p = 0;
        do {
            if ((j = b[bindex + p]) !== 0) {
                v[x[j]++] = i;
            }
            p++;
        }while (++i < n)
        n = x[g];
        x[0] = i = 0;
        p = 0;
        h = -1;
        w = -l;
        u[0] = 0;
        q = 0;
        z = 0;
        for(; k <= g; k++){
            a = c[k];
            while(a-- !== 0){
                while(k > w + l){
                    h++;
                    w += l;
                    z = g - w;
                    z = z > l ? l : z;
                    if ((f = 1 << (j = k - w)) > a + 1) {
                        f -= a + 1;
                        xp = k;
                        if (j < z) {
                            while(++j < z){
                                if ((f <<= 1) <= c[++xp]) break;
                                f -= c[xp];
                            }
                        }
                    }
                    z = 1 << j;
                    if (hn[0] + z > 1440) {
                        return Z_DATA_ERROR1;
                    }
                    u[h] = q = hn[0];
                    hn[0] += z;
                    if (h !== 0) {
                        x[h] = i;
                        r[0] = j;
                        r[1] = l;
                        j = i >>> w - l;
                        r[2] = q - u[h - 1] - j;
                        hp.set(r, (u[h - 1] + j) * 3);
                    } else {
                        t[0] = q;
                    }
                }
                r[1] = k - w;
                if (p >= n) {
                    r[0] = 128 + 64;
                } else if (v[p] < s) {
                    r[0] = v[p] < 256 ? 0 : 32 + 64;
                    r[2] = v[p++];
                } else {
                    r[0] = e[v[p] - s] + 16 + 64;
                    r[2] = d[v[p++] - s];
                }
                f = 1 << k - w;
                for(j = i >>> w; j < z; j += f){
                    hp.set(r, (q + j) * 3);
                }
                for(j = 1 << k - 1; (i & j) !== 0; j >>>= 1){
                    i ^= j;
                }
                i ^= j;
                mask = (1 << w) - 1;
                while((i & mask) != x[h]){
                    h--;
                    w -= l;
                    mask = (1 << w) - 1;
                }
            }
        }
        return y !== 0 && g != 1 ? Z_BUF_ERROR1 : 0;
    }
    function initWorkArea(vsize) {
        let i;
        if (!hn) {
            hn = [];
            v = [];
            c = new Int32Array(BMAX + 1);
            r = [];
            u = new Int32Array(BMAX);
            x = new Int32Array(BMAX + 1);
        }
        if (v.length < vsize) {
            v = [];
        }
        for(i = 0; i < vsize; i++){
            v[i] = 0;
        }
        for(i = 0; i < 15 + 1; i++){
            c[i] = 0;
        }
        for(i = 0; i < 3; i++){
            r[i] = 0;
        }
        u.set(c.subarray(0, 15), 0);
        x.set(c.subarray(0, 15 + 1), 0);
    }
    that.inflate_trees_bits = function(c, bb, tb, hp, z) {
        let result;
        initWorkArea(19);
        hn[0] = 0;
        result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
        if (result == Z_DATA_ERROR1) {
            z.msg = "oversubscribed dynamic bit lengths tree";
        } else if (result == Z_BUF_ERROR1 || bb[0] === 0) {
            z.msg = "incomplete dynamic bit lengths tree";
            result = Z_DATA_ERROR1;
        }
        return result;
    };
    that.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
        let result;
        initWorkArea(288);
        hn[0] = 0;
        result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
        if (result != Z_OK1 || bl[0] === 0) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed literal/length tree";
            } else if (result != Z_MEM_ERROR) {
                z.msg = "incomplete literal/length tree";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        initWorkArea(288);
        result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
        if (result != Z_OK1 || bd[0] === 0 && nl > 257) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed distance tree";
            } else if (result == Z_BUF_ERROR1) {
                z.msg = "incomplete distance tree";
                result = Z_DATA_ERROR1;
            } else if (result != Z_MEM_ERROR) {
                z.msg = "empty distance tree with lengths";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        return Z_OK1;
    };
}
InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
    bl[0] = fixed_bl;
    bd[0] = fixed_bd;
    tl[0] = fixed_tl;
    td[0] = fixed_td;
    return Z_OK1;
};
const START = 0;
const LEN = 1;
const LENEXT = 2;
const DIST = 3;
const DISTEXT = 4;
const COPY = 5;
const LIT = 6;
const WASH = 7;
const END = 8;
const BADCODE = 9;
function InfCodes() {
    const that = this;
    let mode;
    let len = 0;
    let tree;
    let tree_index = 0;
    let need = 0;
    let lit = 0;
    let get = 0;
    let dist = 0;
    let lbits = 0;
    let dbits = 0;
    let ltree;
    let ltree_index = 0;
    let dtree;
    let dtree_index = 0;
    function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
        let t;
        let tp;
        let tp_index;
        let e;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let ml;
        let md;
        let c;
        let d;
        let r;
        let tp_index_t_3;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        ml = inflate_mask[bl];
        md = inflate_mask[bd];
        do {
            while(k < 20){
                n--;
                b |= (z.read_byte(p++) & 0xff) << k;
                k += 8;
            }
            t = b & ml;
            tp = tl;
            tp_index = tl_index;
            tp_index_t_3 = (tp_index + t) * 3;
            if ((e = tp[tp_index_t_3]) === 0) {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                s.window[q++] = tp[tp_index_t_3 + 2];
                m--;
                continue;
            }
            do {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                if ((e & 16) !== 0) {
                    e &= 15;
                    c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                    b >>= e;
                    k -= e;
                    while(k < 15){
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    t = b & md;
                    tp = td;
                    tp_index = td_index;
                    tp_index_t_3 = (tp_index + t) * 3;
                    e = tp[tp_index_t_3];
                    do {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        if ((e & 16) !== 0) {
                            e &= 15;
                            while(k < e){
                                n--;
                                b |= (z.read_byte(p++) & 0xff) << k;
                                k += 8;
                            }
                            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                            b >>= e;
                            k -= e;
                            m -= c;
                            if (q >= d) {
                                r = q - d;
                                if (q - r > 0 && 2 > q - r) {
                                    s.window[q++] = s.window[r++];
                                    s.window[q++] = s.window[r++];
                                    c -= 2;
                                } else {
                                    s.window.set(s.window.subarray(r, r + 2), q);
                                    q += 2;
                                    r += 2;
                                    c -= 2;
                                }
                            } else {
                                r = q - d;
                                do {
                                    r += s.end;
                                }while (r < 0)
                                e = s.end - r;
                                if (c > e) {
                                    c -= e;
                                    if (q - r > 0 && e > q - r) {
                                        do {
                                            s.window[q++] = s.window[r++];
                                        }while (--e !== 0)
                                    } else {
                                        s.window.set(s.window.subarray(r, r + e), q);
                                        q += e;
                                        r += e;
                                        e = 0;
                                    }
                                    r = 0;
                                }
                            }
                            if (q - r > 0 && c > q - r) {
                                do {
                                    s.window[q++] = s.window[r++];
                                }while (--c !== 0)
                            } else {
                                s.window.set(s.window.subarray(r, r + c), q);
                                q += c;
                                r += c;
                                c = 0;
                            }
                            break;
                        } else if ((e & 64) === 0) {
                            t += tp[tp_index_t_3 + 2];
                            t += b & inflate_mask[e];
                            tp_index_t_3 = (tp_index + t) * 3;
                            e = tp[tp_index_t_3];
                        } else {
                            z.msg = "invalid distance code";
                            c = z.avail_in - n;
                            c = k >> 3 < c ? k >> 3 : c;
                            n += c;
                            p -= c;
                            k -= c << 3;
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return Z_DATA_ERROR1;
                        }
                    }while (true)
                    break;
                }
                if ((e & 64) === 0) {
                    t += tp[tp_index_t_3 + 2];
                    t += b & inflate_mask[e];
                    tp_index_t_3 = (tp_index + t) * 3;
                    if ((e = tp[tp_index_t_3]) === 0) {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        s.window[q++] = tp[tp_index_t_3 + 2];
                        m--;
                        break;
                    }
                } else if ((e & 32) !== 0) {
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return 1;
                } else {
                    z.msg = "invalid literal/length code";
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return Z_DATA_ERROR1;
                }
            }while (true)
        }while (m >= 258 && n >= 10)
        c = z.avail_in - n;
        c = k >> 3 < c ? k >> 3 : c;
        n += c;
        p -= c;
        k -= c << 3;
        s.bitb = b;
        s.bitk = k;
        z.avail_in = n;
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        s.write = q;
        return 0;
    }
    that.init = function(bl, bd, tl, tl_index, td, td_index) {
        mode = START;
        lbits = bl;
        dbits = bd;
        ltree = tl;
        ltree_index = tl_index;
        dtree = td;
        dtree_index = td_index;
        tree = null;
    };
    that.proc = function(s, z, r) {
        let j;
        let tindex;
        let e;
        let b = 0;
        let k = 0;
        let p = 0;
        let n;
        let q;
        let m;
        let f;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        while(true){
            switch(mode){
                case START:
                    if (m >= 258 && n >= 10) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
                        p = z.next_in_index;
                        n = z.avail_in;
                        b = s.bitb;
                        k = s.bitk;
                        q = s.write;
                        m = q < s.read ? s.read - q - 1 : s.end - q;
                        if (r != Z_OK1) {
                            mode = r == Z_STREAM_END1 ? WASH : BADCODE;
                            break;
                        }
                    }
                    need = lbits;
                    tree = ltree;
                    tree_index = ltree_index;
                    mode = LEN;
                case LEN:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if (e === 0) {
                        lit = tree[tindex + 2];
                        mode = LIT;
                        break;
                    }
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        len = tree[tindex + 2];
                        mode = LENEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    if ((e & 32) !== 0) {
                        mode = WASH;
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid literal/length code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case LENEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    len += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    need = dbits;
                    tree = dtree;
                    tree_index = dtree_index;
                    mode = DIST;
                case DIST:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        dist = tree[tindex + 2];
                        mode = DISTEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid distance code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case DISTEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    dist += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    mode = COPY;
                case COPY:
                    f = q - dist;
                    while(f < 0){
                        f += s.end;
                    }
                    while(len !== 0){
                        if (m === 0) {
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.write = q;
                                r = s.inflate_flush(z, r);
                                q = s.write;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                                if (q == s.end && s.read !== 0) {
                                    q = 0;
                                    m = q < s.read ? s.read - q - 1 : s.end - q;
                                }
                                if (m === 0) {
                                    s.bitb = b;
                                    s.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    s.write = q;
                                    return s.inflate_flush(z, r);
                                }
                            }
                        }
                        s.window[q++] = s.window[f++];
                        m--;
                        if (f == s.end) f = 0;
                        len--;
                    }
                    mode = START;
                    break;
                case LIT:
                    if (m === 0) {
                        if (q == s.end && s.read !== 0) {
                            q = 0;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                        }
                        if (m === 0) {
                            s.write = q;
                            r = s.inflate_flush(z, r);
                            q = s.write;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.bitb = b;
                                s.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                s.write = q;
                                return s.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    s.window[q++] = lit;
                    m--;
                    mode = START;
                    break;
                case WASH:
                    if (k > 7) {
                        k -= 8;
                        n++;
                        p--;
                    }
                    s.write = q;
                    r = s.inflate_flush(z, r);
                    q = s.write;
                    m = q < s.read ? s.read - q - 1 : s.end - q;
                    if (s.read != s.write) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        return s.inflate_flush(z, r);
                    }
                    mode = END;
                case END:
                    r = Z_STREAM_END1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case BADCODE:
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
            }
        }
    };
    that.free = function() {};
}
const border = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
const TYPE = 0;
const LENS = 1;
const STORED1 = 2;
const TABLE = 3;
const BTREE = 4;
const DTREE = 5;
const CODES = 6;
const DRY = 7;
const DONELOCKS = 8;
const BADBLOCKS = 9;
function InfBlocks(z, w) {
    const that = this;
    let mode = 0;
    let left = 0;
    let table = 0;
    let index = 0;
    let blens;
    const bb = [
        0
    ];
    const tb = [
        0
    ];
    const codes = new InfCodes();
    let last = 0;
    let hufts = new Int32Array(1440 * 3);
    const check = 0;
    const inftree = new InfTree();
    that.bitk = 0;
    that.bitb = 0;
    that.window = new Uint8Array(w);
    that.end = w;
    that.read = 0;
    that.write = 0;
    that.reset = function(z, c) {
        if (c) c[0] = check;
        if (mode == CODES) {
            codes.free(z);
        }
        mode = TYPE;
        that.bitk = 0;
        that.bitb = 0;
        that.read = that.write = 0;
    };
    that.reset(z, null);
    that.inflate_flush = function(z, r) {
        let n;
        let p;
        let q;
        p = z.next_out_index;
        q = that.read;
        n = (q <= that.write ? that.write : that.end) - q;
        if (n > z.avail_out) n = z.avail_out;
        if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
        z.avail_out -= n;
        z.total_out += n;
        z.next_out.set(that.window.subarray(q, q + n), p);
        p += n;
        q += n;
        if (q == that.end) {
            q = 0;
            if (that.write == that.end) that.write = 0;
            n = that.write - q;
            if (n > z.avail_out) n = z.avail_out;
            if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
            z.avail_out -= n;
            z.total_out += n;
            z.next_out.set(that.window.subarray(q, q + n), p);
            p += n;
            q += n;
        }
        z.next_out_index = p;
        that.read = q;
        return r;
    };
    that.proc = function(z, r) {
        let t;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let i;
        p = z.next_in_index;
        n = z.avail_in;
        b = that.bitb;
        k = that.bitk;
        q = that.write;
        m = q < that.read ? that.read - q - 1 : that.end - q;
        while(true){
            let bl, bd, tl, td, bl_, bd_, tl_, td_;
            switch(mode){
                case TYPE:
                    while(k < 3){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    t = b & 7;
                    last = t & 1;
                    switch(t >>> 1){
                        case 0:
                            b >>>= 3;
                            k -= 3;
                            t = k & 7;
                            b >>>= t;
                            k -= t;
                            mode = LENS;
                            break;
                        case 1:
                            bl = [];
                            bd = [];
                            tl = [
                                []
                            ];
                            td = [
                                []
                            ];
                            InfTree.inflate_trees_fixed(bl, bd, tl, td);
                            codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
                            b >>>= 3;
                            k -= 3;
                            mode = CODES;
                            break;
                        case 2:
                            b >>>= 3;
                            k -= 3;
                            mode = TABLE;
                            break;
                        case 3:
                            b >>>= 3;
                            k -= 3;
                            mode = BADBLOCKS;
                            z.msg = "invalid block type";
                            r = Z_DATA_ERROR1;
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                    }
                    break;
                case LENS:
                    while(k < 32){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {
                        mode = BADBLOCKS;
                        z.msg = "invalid stored block lengths";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    left = b & 0xffff;
                    b = k = 0;
                    mode = left !== 0 ? STORED1 : last !== 0 ? DRY : TYPE;
                    break;
                case STORED1:
                    if (n === 0) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    if (m === 0) {
                        if (q == that.end && that.read !== 0) {
                            q = 0;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                        }
                        if (m === 0) {
                            that.write = q;
                            r = that.inflate_flush(z, r);
                            q = that.write;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                            if (q == that.end && that.read !== 0) {
                                q = 0;
                                m = q < that.read ? that.read - q - 1 : that.end - q;
                            }
                            if (m === 0) {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    t = left;
                    if (t > n) t = n;
                    if (t > m) t = m;
                    that.window.set(z.read_buf(p, t), q);
                    p += t;
                    n -= t;
                    q += t;
                    m -= t;
                    if ((left -= t) !== 0) break;
                    mode = last !== 0 ? DRY : TYPE;
                    break;
                case TABLE:
                    while(k < 14){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    table = t = b & 0x3fff;
                    if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {
                        mode = BADBLOCKS;
                        z.msg = "too many length or distance symbols";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);
                    if (!blens || blens.length < t) {
                        blens = [];
                    } else {
                        for(i = 0; i < t; i++){
                            blens[i] = 0;
                        }
                    }
                    b >>>= 14;
                    k -= 14;
                    index = 0;
                    mode = BTREE;
                case BTREE:
                    while(index < 4 + (table >>> 10)){
                        while(k < 3){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 0xff) << k;
                            k += 8;
                        }
                        blens[border[index++]] = b & 7;
                        b >>>= 3;
                        k -= 3;
                    }
                    while(index < 19){
                        blens[border[index++]] = 0;
                    }
                    bb[0] = 7;
                    t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
                    if (t != Z_OK1) {
                        r = t;
                        if (r == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    index = 0;
                    mode = DTREE;
                case DTREE:
                    while(true){
                        t = table;
                        if (index >= 258 + (t & 0x1f) + (t >> 5 & 0x1f)) {
                            break;
                        }
                        let j, c;
                        t = bb[0];
                        while(k < t){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 0xff) << k;
                            k += 8;
                        }
                        t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
                        c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];
                        if (c < 16) {
                            b >>>= t;
                            k -= t;
                            blens[index++] = c;
                        } else {
                            i = c == 18 ? 7 : c - 14;
                            j = c == 18 ? 11 : 3;
                            while(k < t + i){
                                if (n !== 0) {
                                    r = Z_OK1;
                                } else {
                                    that.bitb = b;
                                    that.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    that.write = q;
                                    return that.inflate_flush(z, r);
                                }
                                n--;
                                b |= (z.read_byte(p++) & 0xff) << k;
                                k += 8;
                            }
                            b >>>= t;
                            k -= t;
                            j += b & inflate_mask[i];
                            b >>>= i;
                            k -= i;
                            i = index;
                            t = table;
                            if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {
                                blens = null;
                                mode = BADBLOCKS;
                                z.msg = "invalid bit length repeat";
                                r = Z_DATA_ERROR1;
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            c = c == 16 ? blens[i - 1] : 0;
                            do {
                                blens[i++] = c;
                            }while (--j !== 0)
                            index = i;
                        }
                    }
                    tb[0] = -1;
                    bl_ = [];
                    bd_ = [];
                    tl_ = [];
                    td_ = [];
                    bl_[0] = 9;
                    bd_[0] = 6;
                    t = table;
                    t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);
                    if (t != Z_OK1) {
                        if (t == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        r = t;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
                    mode = CODES;
                case CODES:
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    if ((r = codes.proc(that, z, r)) != Z_STREAM_END1) {
                        return that.inflate_flush(z, r);
                    }
                    r = Z_OK1;
                    codes.free(z);
                    p = z.next_in_index;
                    n = z.avail_in;
                    b = that.bitb;
                    k = that.bitk;
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (last === 0) {
                        mode = TYPE;
                        break;
                    }
                    mode = DRY;
                case DRY:
                    that.write = q;
                    r = that.inflate_flush(z, r);
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (that.read != that.write) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    mode = DONELOCKS;
                case DONELOCKS:
                    r = Z_STREAM_END1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                case BADBLOCKS:
                    r = Z_DATA_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
            }
        }
    };
    that.free = function(z) {
        that.reset(z, null);
        that.window = null;
        hufts = null;
    };
    that.set_dictionary = function(d, start, n) {
        that.window.set(d.subarray(start, start + n), 0);
        that.read = that.write = n;
    };
    that.sync_point = function() {
        return mode == LENS ? 1 : 0;
    };
}
const PRESET_DICT1 = 0x20;
const Z_DEFLATED1 = 8;
const METHOD = 0;
const FLAG = 1;
const DICT4 = 2;
const DICT3 = 3;
const DICT2 = 4;
const DICT1 = 5;
const DICT0 = 6;
const BLOCKS = 7;
const DONE = 12;
const BAD = 13;
const mark = [
    0,
    0,
    0xff,
    0xff
];
function Inflate() {
    const that = this;
    that.mode = 0;
    that.method = 0;
    that.was = [
        0
    ];
    that.need = 0;
    that.marker = 0;
    that.wbits = 0;
    function inflateReset(z) {
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        z.total_in = z.total_out = 0;
        z.msg = null;
        z.istate.mode = BLOCKS;
        z.istate.blocks.reset(z, null);
        return 0;
    }
    that.inflateEnd = function(z) {
        if (that.blocks) that.blocks.free(z);
        that.blocks = null;
        return Z_OK1;
    };
    that.inflateInit = function(z, w) {
        z.msg = null;
        that.blocks = null;
        if (w < 8 || w > 15) {
            that.inflateEnd(z);
            return Z_STREAM_ERROR1;
        }
        that.wbits = w;
        z.istate.blocks = new InfBlocks(z, 1 << w);
        inflateReset(z);
        return Z_OK1;
    };
    that.inflate = function(z, f) {
        let r;
        let b;
        if (!z || !z.istate || !z.next_in) return Z_STREAM_ERROR1;
        const istate = z.istate;
        f = f == Z_FINISH1 ? Z_BUF_ERROR1 : Z_OK1;
        r = Z_BUF_ERROR1;
        while(true){
            switch(istate.mode){
                case METHOD:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    if (((istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED1) {
                        istate.mode = BAD;
                        z.msg = "unknown compression method";
                        istate.marker = 5;
                        break;
                    }
                    if ((istate.method >> 4) + 8 > istate.wbits) {
                        istate.mode = BAD;
                        z.msg = "invalid window size";
                        istate.marker = 5;
                        break;
                    }
                    istate.mode = FLAG;
                case FLAG:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    b = z.read_byte(z.next_in_index++) & 0xff;
                    if (((istate.method << 8) + b) % 31 !== 0) {
                        istate.mode = BAD;
                        z.msg = "incorrect header check";
                        istate.marker = 5;
                        break;
                    }
                    if ((b & PRESET_DICT1) === 0) {
                        istate.mode = BLOCKS;
                        break;
                    }
                    istate.mode = DICT4;
                case DICT4:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need = (z.read_byte(z.next_in_index++) & 0xff) << 24 & 0xff000000;
                    istate.mode = DICT3;
                case DICT3:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 16 & 0xff0000;
                    istate.mode = DICT2;
                case DICT2:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 8 & 0xff00;
                    istate.mode = DICT1;
                case DICT1:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += z.read_byte(z.next_in_index++) & 0xff;
                    istate.mode = DICT0;
                    return Z_NEED_DICT1;
                case DICT0:
                    istate.mode = BAD;
                    z.msg = "need dictionary";
                    istate.marker = 0;
                    return Z_STREAM_ERROR1;
                case BLOCKS:
                    r = istate.blocks.proc(z, r);
                    if (r == Z_DATA_ERROR1) {
                        istate.mode = BAD;
                        istate.marker = 0;
                        break;
                    }
                    if (r == Z_OK1) {
                        r = f;
                    }
                    if (r != Z_STREAM_END1) {
                        return r;
                    }
                    r = f;
                    istate.blocks.reset(z, istate.was);
                    istate.mode = DONE;
                case DONE:
                    return Z_STREAM_END1;
                case BAD:
                    return Z_DATA_ERROR1;
                default:
                    return Z_STREAM_ERROR1;
            }
        }
    };
    that.inflateSetDictionary = function(z, dictionary, dictLength) {
        let index = 0, length = dictLength;
        if (!z || !z.istate || z.istate.mode != DICT0) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (length >= 1 << istate.wbits) {
            length = (1 << istate.wbits) - 1;
            index = dictLength - length;
        }
        istate.blocks.set_dictionary(dictionary, index, length);
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSync = function(z) {
        let n;
        let p;
        let m;
        let r, w;
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (istate.mode != BAD) {
            istate.mode = BAD;
            istate.marker = 0;
        }
        if ((n = z.avail_in) === 0) return Z_BUF_ERROR1;
        p = z.next_in_index;
        m = istate.marker;
        while(n !== 0 && m < 4){
            if (z.read_byte(p) == mark[m]) {
                m++;
            } else if (z.read_byte(p) !== 0) {
                m = 0;
            } else {
                m = 4 - m;
            }
            p++;
            n--;
        }
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        z.avail_in = n;
        istate.marker = m;
        if (m != 4) {
            return Z_DATA_ERROR1;
        }
        r = z.total_in;
        w = z.total_out;
        inflateReset(z);
        z.total_in = r;
        z.total_out = w;
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSyncPoint = function(z) {
        if (!z || !z.istate || !z.istate.blocks) return Z_STREAM_ERROR1;
        return z.istate.blocks.sync_point();
    };
}
function ZStream1() {}
ZStream1.prototype = {
    inflateInit: function(bits) {
        const that = this;
        that.istate = new Inflate();
        if (!bits) bits = MAX_BITS1;
        return that.istate.inflateInit(that, bits);
    },
    inflate: function(f) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflate(that, f);
    },
    inflateEnd: function() {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        const ret = that.istate.inflateEnd(that);
        that.istate = null;
        return ret;
    },
    inflateSync: function() {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSync(that);
    },
    inflateSetDictionary: function(dictionary, dictLength) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSetDictionary(that, dictionary, dictLength);
    },
    read_byte: function(start) {
        const that = this;
        return that.next_in[start];
    },
    read_buf: function(start, size) {
        const that = this;
        return that.next_in.subarray(start, start + size);
    }
};
function ZipInflate(options) {
    const that = this;
    const z = new ZStream1();
    const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let nomoreinput = false;
    z.inflateInit();
    z.next_out = buf;
    that.append = function(data, onprogress) {
        const buffers = [];
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        if (data.length === 0) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            if (z.avail_in === 0 && !nomoreinput) {
                z.next_in_index = 0;
                nomoreinput = true;
            }
            err = z.inflate(flush);
            if (nomoreinput && err === Z_BUF_ERROR1) {
                if (z.avail_in !== 0) throw new Error("inflating: bad input");
            } else if (err !== Z_OK1 && err !== Z_STREAM_END1) throw new Error("inflating: " + z.msg);
            if ((nomoreinput || err === Z_STREAM_END1) && z.avail_in === data.length) throw new Error("inflating: bad input");
            if (z.next_out_index) if (z.next_out_index === bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] || new Uint8Array(0);
        }
        return array;
    };
    that.flush = function() {
        z.inflateEnd();
    };
}
"use strict";
const DEFAULT_CONFIGURATION = {
    chunkSize: 512 * 1024,
    maxWorkers: typeof navigator != "undefined" && navigator.hardwareConcurrency || 2,
    terminateWorkerTimeout: 5000,
    useWebWorkers: true,
    workerScripts: undefined
};
const config = Object.assign({}, DEFAULT_CONFIGURATION);
function getConfiguration() {
    return config;
}
function configure(configuration) {
    if (configuration.chunkSize !== undefined) {
        config.chunkSize = configuration.chunkSize;
    }
    if (configuration.maxWorkers !== undefined) {
        config.maxWorkers = configuration.maxWorkers;
    }
    if (configuration.terminateWorkerTimeout !== undefined) {
        config.terminateWorkerTimeout = configuration.terminateWorkerTimeout;
    }
    if (configuration.useWebWorkers !== undefined) {
        config.useWebWorkers = configuration.useWebWorkers;
    }
    if (configuration.Deflate !== undefined) {
        config.Deflate = configuration.Deflate;
    }
    if (configuration.Inflate !== undefined) {
        config.Inflate = configuration.Inflate;
    }
    if (configuration.workerScripts !== undefined) {
        if (configuration.workerScripts.deflate) {
            if (!Array.isArray(configuration.workerScripts.deflate)) {
                throw new Error("workerScripts.deflate must be an array");
            }
            if (!config.workerScripts) {
                config.workerScripts = {};
            }
            config.workerScripts.deflate = configuration.workerScripts.deflate;
        }
        if (configuration.workerScripts.inflate) {
            if (!Array.isArray(configuration.workerScripts.inflate)) {
                throw new Error("workerScripts.inflate must be an array");
            }
            if (!config.workerScripts) {
                config.workerScripts = {};
            }
            config.workerScripts.inflate = configuration.workerScripts.inflate;
        }
    }
}
"use strict";
const table = {
    "application": {
        "andrew-inset": "ez",
        "annodex": "anx",
        "atom+xml": "atom",
        "atomcat+xml": "atomcat",
        "atomserv+xml": "atomsrv",
        "bbolin": "lin",
        "cap": [
            "cap",
            "pcap"
        ],
        "cu-seeme": "cu",
        "davmount+xml": "davmount",
        "dsptype": "tsp",
        "ecmascript": [
            "es",
            "ecma"
        ],
        "futuresplash": "spl",
        "hta": "hta",
        "java-archive": "jar",
        "java-serialized-object": "ser",
        "java-vm": "class",
        "javascript": "js",
        "m3g": "m3g",
        "mac-binhex40": "hqx",
        "mathematica": [
            "nb",
            "ma",
            "mb"
        ],
        "msaccess": "mdb",
        "msword": [
            "doc",
            "dot"
        ],
        "mxf": "mxf",
        "oda": "oda",
        "ogg": "ogx",
        "pdf": "pdf",
        "pgp-keys": "key",
        "pgp-signature": [
            "asc",
            "sig"
        ],
        "pics-rules": "prf",
        "postscript": [
            "ps",
            "ai",
            "eps",
            "epsi",
            "epsf",
            "eps2",
            "eps3"
        ],
        "rar": "rar",
        "rdf+xml": "rdf",
        "rss+xml": "rss",
        "rtf": "rtf",
        "smil": [
            "smi",
            "smil"
        ],
        "xhtml+xml": [
            "xhtml",
            "xht"
        ],
        "xml": [
            "xml",
            "xsl",
            "xsd"
        ],
        "xspf+xml": "xspf",
        "zip": "zip",
        "vnd.android.package-archive": "apk",
        "vnd.cinderella": "cdy",
        "vnd.google-earth.kml+xml": "kml",
        "vnd.google-earth.kmz": "kmz",
        "vnd.mozilla.xul+xml": "xul",
        "vnd.ms-excel": [
            "xls",
            "xlb",
            "xlt",
            "xlm",
            "xla",
            "xlc",
            "xlw"
        ],
        "vnd.ms-pki.seccat": "cat",
        "vnd.ms-pki.stl": "stl",
        "vnd.ms-powerpoint": [
            "ppt",
            "pps",
            "pot"
        ],
        "vnd.oasis.opendocument.chart": "odc",
        "vnd.oasis.opendocument.database": "odb",
        "vnd.oasis.opendocument.formula": "odf",
        "vnd.oasis.opendocument.graphics": "odg",
        "vnd.oasis.opendocument.graphics-template": "otg",
        "vnd.oasis.opendocument.image": "odi",
        "vnd.oasis.opendocument.presentation": "odp",
        "vnd.oasis.opendocument.presentation-template": "otp",
        "vnd.oasis.opendocument.spreadsheet": "ods",
        "vnd.oasis.opendocument.spreadsheet-template": "ots",
        "vnd.oasis.opendocument.text": "odt",
        "vnd.oasis.opendocument.text-master": "odm",
        "vnd.oasis.opendocument.text-template": "ott",
        "vnd.oasis.opendocument.text-web": "oth",
        "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
        "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
        "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
        "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
        "vnd.openxmlformats-officedocument.presentationml.template": "potx",
        "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
        "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
        "vnd.smaf": "mmf",
        "vnd.stardivision.calc": "sdc",
        "vnd.stardivision.chart": "sds",
        "vnd.stardivision.draw": "sda",
        "vnd.stardivision.impress": "sdd",
        "vnd.stardivision.math": [
            "sdf",
            "smf"
        ],
        "vnd.stardivision.writer": [
            "sdw",
            "vor"
        ],
        "vnd.stardivision.writer-global": "sgl",
        "vnd.sun.xml.calc": "sxc",
        "vnd.sun.xml.calc.template": "stc",
        "vnd.sun.xml.draw": "sxd",
        "vnd.sun.xml.draw.template": "std",
        "vnd.sun.xml.impress": "sxi",
        "vnd.sun.xml.impress.template": "sti",
        "vnd.sun.xml.math": "sxm",
        "vnd.sun.xml.writer": "sxw",
        "vnd.sun.xml.writer.global": "sxg",
        "vnd.sun.xml.writer.template": "stw",
        "vnd.symbian.install": [
            "sis",
            "sisx"
        ],
        "vnd.visio": [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ],
        "vnd.wap.wbxml": "wbxml",
        "vnd.wap.wmlc": "wmlc",
        "vnd.wap.wmlscriptc": "wmlsc",
        "vnd.wordperfect": "wpd",
        "vnd.wordperfect5.1": "wp5",
        "x-123": "wk",
        "x-7z-compressed": "7z",
        "x-abiword": "abw",
        "x-apple-diskimage": "dmg",
        "x-bcpio": "bcpio",
        "x-bittorrent": "torrent",
        "x-cbr": [
            "cbr",
            "cba",
            "cbt",
            "cb7"
        ],
        "x-cbz": "cbz",
        "x-cdf": [
            "cdf",
            "cda"
        ],
        "x-cdlink": "vcd",
        "x-chess-pgn": "pgn",
        "x-cpio": "cpio",
        "x-csh": "csh",
        "x-debian-package": [
            "deb",
            "udeb"
        ],
        "x-director": [
            "dcr",
            "dir",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ],
        "x-dms": "dms",
        "x-doom": "wad",
        "x-dvi": "dvi",
        "x-httpd-eruby": "rhtml",
        "x-font": "pcf.Z",
        "x-freemind": "mm",
        "x-gnumeric": "gnumeric",
        "x-go-sgf": "sgf",
        "x-graphing-calculator": "gcf",
        "x-gtar": [
            "gtar",
            "taz"
        ],
        "x-hdf": "hdf",
        "x-httpd-php": [
            "phtml",
            "pht",
            "php"
        ],
        "x-httpd-php-source": "phps",
        "x-httpd-php3": "php3",
        "x-httpd-php3-preprocessed": "php3p",
        "x-httpd-php4": "php4",
        "x-httpd-php5": "php5",
        "x-ica": "ica",
        "x-info": "info",
        "x-internet-signup": [
            "ins",
            "isp"
        ],
        "x-iphone": "iii",
        "x-iso9660-image": "iso",
        "x-java-jnlp-file": "jnlp",
        "x-jmol": "jmz",
        "x-killustrator": "kil",
        "x-koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "x-kpresenter": [
            "kpr",
            "kpt"
        ],
        "x-kword": [
            "kwd",
            "kwt"
        ],
        "x-latex": "latex",
        "x-lha": "lha",
        "x-lyx": "lyx",
        "x-lzh": "lzh",
        "x-lzx": "lzx",
        "x-maker": [
            "frm",
            "maker",
            "frame",
            "fm",
            "fb",
            "book",
            "fbdoc"
        ],
        "x-ms-wmd": "wmd",
        "x-ms-wmz": "wmz",
        "x-msdos-program": [
            "com",
            "exe",
            "bat",
            "dll"
        ],
        "x-msi": "msi",
        "x-netcdf": [
            "nc",
            "cdf"
        ],
        "x-ns-proxy-autoconfig": [
            "pac",
            "dat"
        ],
        "x-nwc": "nwc",
        "x-object": "o",
        "x-oz-application": "oza",
        "x-pkcs7-certreqresp": "p7r",
        "x-python-code": [
            "pyc",
            "pyo"
        ],
        "x-qgis": [
            "qgs",
            "shp",
            "shx"
        ],
        "x-quicktimeplayer": "qtl",
        "x-redhat-package-manager": "rpm",
        "x-ruby": "rb",
        "x-sh": "sh",
        "x-shar": "shar",
        "x-shockwave-flash": [
            "swf",
            "swfl"
        ],
        "x-silverlight": "scr",
        "x-stuffit": "sit",
        "x-sv4cpio": "sv4cpio",
        "x-sv4crc": "sv4crc",
        "x-tar": "tar",
        "x-tcl": "tcl",
        "x-tex-gf": "gf",
        "x-tex-pk": "pk",
        "x-texinfo": [
            "texinfo",
            "texi"
        ],
        "x-trash": [
            "~",
            "%",
            "bak",
            "old",
            "sik"
        ],
        "x-troff": [
            "t",
            "tr",
            "roff"
        ],
        "x-troff-man": "man",
        "x-troff-me": "me",
        "x-troff-ms": "ms",
        "x-ustar": "ustar",
        "x-wais-source": "src",
        "x-wingz": "wz",
        "x-x509-ca-cert": [
            "crt",
            "der",
            "cer"
        ],
        "x-xcf": "xcf",
        "x-xfig": "fig",
        "x-xpinstall": "xpi",
        "applixware": "aw",
        "atomsvc+xml": "atomsvc",
        "ccxml+xml": "ccxml",
        "cdmi-capability": "cdmia",
        "cdmi-container": "cdmic",
        "cdmi-domain": "cdmid",
        "cdmi-object": "cdmio",
        "cdmi-queue": "cdmiq",
        "docbook+xml": "dbk",
        "dssc+der": "dssc",
        "dssc+xml": "xdssc",
        "emma+xml": "emma",
        "epub+zip": "epub",
        "exi": "exi",
        "font-tdpfr": "pfr",
        "gml+xml": "gml",
        "gpx+xml": "gpx",
        "gxf": "gxf",
        "hyperstudio": "stk",
        "inkml+xml": [
            "ink",
            "inkml"
        ],
        "ipfix": "ipfix",
        "json": "json",
        "jsonml+json": "jsonml",
        "lost+xml": "lostxml",
        "mads+xml": "mads",
        "marc": "mrc",
        "marcxml+xml": "mrcx",
        "mathml+xml": "mathml",
        "mbox": "mbox",
        "mediaservercontrol+xml": "mscml",
        "metalink+xml": "metalink",
        "metalink4+xml": "meta4",
        "mets+xml": "mets",
        "mods+xml": "mods",
        "mp21": [
            "m21",
            "mp21"
        ],
        "mp4": "mp4s",
        "oebps-package+xml": "opf",
        "omdoc+xml": "omdoc",
        "onenote": [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ],
        "oxps": "oxps",
        "patch-ops-error+xml": "xer",
        "pgp-encrypted": "pgp",
        "pkcs10": "p10",
        "pkcs7-mime": [
            "p7m",
            "p7c"
        ],
        "pkcs7-signature": "p7s",
        "pkcs8": "p8",
        "pkix-attr-cert": "ac",
        "pkix-crl": "crl",
        "pkix-pkipath": "pkipath",
        "pkixcmp": "pki",
        "pls+xml": "pls",
        "prs.cww": "cww",
        "pskc+xml": "pskcxml",
        "reginfo+xml": "rif",
        "relax-ng-compact-syntax": "rnc",
        "resource-lists+xml": "rl",
        "resource-lists-diff+xml": "rld",
        "rls-services+xml": "rs",
        "rpki-ghostbusters": "gbr",
        "rpki-manifest": "mft",
        "rpki-roa": "roa",
        "rsd+xml": "rsd",
        "sbml+xml": "sbml",
        "scvp-cv-request": "scq",
        "scvp-cv-response": "scs",
        "scvp-vp-request": "spq",
        "scvp-vp-response": "spp",
        "sdp": "sdp",
        "set-payment-initiation": "setpay",
        "set-registration-initiation": "setreg",
        "shf+xml": "shf",
        "sparql-query": "rq",
        "sparql-results+xml": "srx",
        "srgs": "gram",
        "srgs+xml": "grxml",
        "sru+xml": "sru",
        "ssdl+xml": "ssdl",
        "ssml+xml": "ssml",
        "tei+xml": [
            "tei",
            "teicorpus"
        ],
        "thraud+xml": "tfi",
        "timestamped-data": "tsd",
        "vnd.3gpp.pic-bw-large": "plb",
        "vnd.3gpp.pic-bw-small": "psb",
        "vnd.3gpp.pic-bw-var": "pvb",
        "vnd.3gpp2.tcap": "tcap",
        "vnd.3m.post-it-notes": "pwn",
        "vnd.accpac.simply.aso": "aso",
        "vnd.accpac.simply.imp": "imp",
        "vnd.acucobol": "acu",
        "vnd.acucorp": [
            "atc",
            "acutc"
        ],
        "vnd.adobe.air-application-installer-package+zip": "air",
        "vnd.adobe.formscentral.fcdt": "fcdt",
        "vnd.adobe.fxp": [
            "fxp",
            "fxpl"
        ],
        "vnd.adobe.xdp+xml": "xdp",
        "vnd.adobe.xfdf": "xfdf",
        "vnd.ahead.space": "ahead",
        "vnd.airzip.filesecure.azf": "azf",
        "vnd.airzip.filesecure.azs": "azs",
        "vnd.amazon.ebook": "azw",
        "vnd.americandynamics.acc": "acc",
        "vnd.amiga.ami": "ami",
        "vnd.anser-web-certificate-issue-initiation": "cii",
        "vnd.anser-web-funds-transfer-initiation": "fti",
        "vnd.antix.game-component": "atx",
        "vnd.apple.installer+xml": "mpkg",
        "vnd.apple.mpegurl": "m3u8",
        "vnd.aristanetworks.swi": "swi",
        "vnd.astraea-software.iota": "iota",
        "vnd.audiograph": "aep",
        "vnd.blueice.multipass": "mpm",
        "vnd.bmi": "bmi",
        "vnd.businessobjects": "rep",
        "vnd.chemdraw+xml": "cdxml",
        "vnd.chipnuts.karaoke-mmd": "mmd",
        "vnd.claymore": "cla",
        "vnd.cloanto.rp9": "rp9",
        "vnd.clonk.c4group": [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ],
        "vnd.cluetrust.cartomobile-config": "c11amc",
        "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
        "vnd.commonspace": "csp",
        "vnd.contact.cmsg": "cdbcmsg",
        "vnd.cosmocaller": "cmc",
        "vnd.crick.clicker": "clkx",
        "vnd.crick.clicker.keyboard": "clkk",
        "vnd.crick.clicker.palette": "clkp",
        "vnd.crick.clicker.template": "clkt",
        "vnd.crick.clicker.wordbank": "clkw",
        "vnd.criticaltools.wbs+xml": "wbs",
        "vnd.ctc-posml": "pml",
        "vnd.cups-ppd": "ppd",
        "vnd.curl.car": "car",
        "vnd.curl.pcurl": "pcurl",
        "vnd.dart": "dart",
        "vnd.data-vision.rdz": "rdz",
        "vnd.dece.data": [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ],
        "vnd.dece.ttml+xml": [
            "uvt",
            "uvvt"
        ],
        "vnd.dece.unspecified": [
            "uvx",
            "uvvx"
        ],
        "vnd.dece.zip": [
            "uvz",
            "uvvz"
        ],
        "vnd.denovo.fcselayout-link": "fe_launch",
        "vnd.dna": "dna",
        "vnd.dolby.mlp": "mlp",
        "vnd.dpgraph": "dpg",
        "vnd.dreamfactory": "dfac",
        "vnd.ds-keypoint": "kpxx",
        "vnd.dvb.ait": "ait",
        "vnd.dvb.service": "svc",
        "vnd.dynageo": "geo",
        "vnd.ecowin.chart": "mag",
        "vnd.enliven": "nml",
        "vnd.epson.esf": "esf",
        "vnd.epson.msf": "msf",
        "vnd.epson.quickanime": "qam",
        "vnd.epson.salt": "slt",
        "vnd.epson.ssf": "ssf",
        "vnd.eszigno3+xml": [
            "es3",
            "et3"
        ],
        "vnd.ezpix-album": "ez2",
        "vnd.ezpix-package": "ez3",
        "vnd.fdf": "fdf",
        "vnd.fdsn.mseed": "mseed",
        "vnd.fdsn.seed": [
            "seed",
            "dataless"
        ],
        "vnd.flographit": "gph",
        "vnd.fluxtime.clip": "ftc",
        "vnd.framemaker": [
            "fm",
            "frame",
            "maker",
            "book"
        ],
        "vnd.frogans.fnc": "fnc",
        "vnd.frogans.ltf": "ltf",
        "vnd.fsc.weblaunch": "fsc",
        "vnd.fujitsu.oasys": "oas",
        "vnd.fujitsu.oasys2": "oa2",
        "vnd.fujitsu.oasys3": "oa3",
        "vnd.fujitsu.oasysgp": "fg5",
        "vnd.fujitsu.oasysprs": "bh2",
        "vnd.fujixerox.ddd": "ddd",
        "vnd.fujixerox.docuworks": "xdw",
        "vnd.fujixerox.docuworks.binder": "xbd",
        "vnd.fuzzysheet": "fzs",
        "vnd.genomatix.tuxedo": "txd",
        "vnd.geogebra.file": "ggb",
        "vnd.geogebra.tool": "ggt",
        "vnd.geometry-explorer": [
            "gex",
            "gre"
        ],
        "vnd.geonext": "gxt",
        "vnd.geoplan": "g2w",
        "vnd.geospace": "g3w",
        "vnd.gmx": "gmx",
        "vnd.grafeq": [
            "gqf",
            "gqs"
        ],
        "vnd.groove-account": "gac",
        "vnd.groove-help": "ghf",
        "vnd.groove-identity-message": "gim",
        "vnd.groove-injector": "grv",
        "vnd.groove-tool-message": "gtm",
        "vnd.groove-tool-template": "tpl",
        "vnd.groove-vcard": "vcg",
        "vnd.hal+xml": "hal",
        "vnd.handheld-entertainment+xml": "zmm",
        "vnd.hbci": "hbci",
        "vnd.hhe.lesson-player": "les",
        "vnd.hp-hpgl": "hpgl",
        "vnd.hp-hpid": "hpid",
        "vnd.hp-hps": "hps",
        "vnd.hp-jlyt": "jlt",
        "vnd.hp-pcl": "pcl",
        "vnd.hp-pclxl": "pclxl",
        "vnd.hydrostatix.sof-data": "sfd-hdstx",
        "vnd.ibm.minipay": "mpy",
        "vnd.ibm.modcap": [
            "afp",
            "listafp",
            "list3820"
        ],
        "vnd.ibm.rights-management": "irm",
        "vnd.ibm.secure-container": "sc",
        "vnd.iccprofile": [
            "icc",
            "icm"
        ],
        "vnd.igloader": "igl",
        "vnd.immervision-ivp": "ivp",
        "vnd.immervision-ivu": "ivu",
        "vnd.insors.igm": "igm",
        "vnd.intercon.formnet": [
            "xpw",
            "xpx"
        ],
        "vnd.intergeo": "i2g",
        "vnd.intu.qbo": "qbo",
        "vnd.intu.qfx": "qfx",
        "vnd.ipunplugged.rcprofile": "rcprofile",
        "vnd.irepository.package+xml": "irp",
        "vnd.is-xpr": "xpr",
        "vnd.isac.fcs": "fcs",
        "vnd.jam": "jam",
        "vnd.jcp.javame.midlet-rms": "rms",
        "vnd.jisp": "jisp",
        "vnd.joost.joda-archive": "joda",
        "vnd.kahootz": [
            "ktz",
            "ktr"
        ],
        "vnd.kde.karbon": "karbon",
        "vnd.kde.kchart": "chrt",
        "vnd.kde.kformula": "kfo",
        "vnd.kde.kivio": "flw",
        "vnd.kde.kontour": "kon",
        "vnd.kde.kpresenter": [
            "kpr",
            "kpt"
        ],
        "vnd.kde.kspread": "ksp",
        "vnd.kde.kword": [
            "kwd",
            "kwt"
        ],
        "vnd.kenameaapp": "htke",
        "vnd.kidspiration": "kia",
        "vnd.kinar": [
            "kne",
            "knp"
        ],
        "vnd.koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "vnd.kodak-descriptor": "sse",
        "vnd.las.las+xml": "lasxml",
        "vnd.llamagraphics.life-balance.desktop": "lbd",
        "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
        "vnd.lotus-1-2-3": "123",
        "vnd.lotus-approach": "apr",
        "vnd.lotus-freelance": "pre",
        "vnd.lotus-notes": "nsf",
        "vnd.lotus-organizer": "org",
        "vnd.lotus-screencam": "scm",
        "vnd.lotus-wordpro": "lwp",
        "vnd.macports.portpkg": "portpkg",
        "vnd.mcd": "mcd",
        "vnd.medcalcdata": "mc1",
        "vnd.mediastation.cdkey": "cdkey",
        "vnd.mfer": "mwf",
        "vnd.mfmp": "mfm",
        "vnd.micrografx.flo": "flo",
        "vnd.micrografx.igx": "igx",
        "vnd.mif": "mif",
        "vnd.mobius.daf": "daf",
        "vnd.mobius.dis": "dis",
        "vnd.mobius.mbk": "mbk",
        "vnd.mobius.mqy": "mqy",
        "vnd.mobius.msl": "msl",
        "vnd.mobius.plc": "plc",
        "vnd.mobius.txf": "txf",
        "vnd.mophun.application": "mpn",
        "vnd.mophun.certificate": "mpc",
        "vnd.ms-artgalry": "cil",
        "vnd.ms-cab-compressed": "cab",
        "vnd.ms-excel.addin.macroenabled.12": "xlam",
        "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
        "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
        "vnd.ms-excel.template.macroenabled.12": "xltm",
        "vnd.ms-fontobject": "eot",
        "vnd.ms-htmlhelp": "chm",
        "vnd.ms-ims": "ims",
        "vnd.ms-lrm": "lrm",
        "vnd.ms-officetheme": "thmx",
        "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
        "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
        "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
        "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
        "vnd.ms-powerpoint.template.macroenabled.12": "potm",
        "vnd.ms-project": [
            "mpp",
            "mpt"
        ],
        "vnd.ms-word.document.macroenabled.12": "docm",
        "vnd.ms-word.template.macroenabled.12": "dotm",
        "vnd.ms-works": [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ],
        "vnd.ms-wpl": "wpl",
        "vnd.ms-xpsdocument": "xps",
        "vnd.mseq": "mseq",
        "vnd.musician": "mus",
        "vnd.muvee.style": "msty",
        "vnd.mynfc": "taglet",
        "vnd.neurolanguage.nlu": "nlu",
        "vnd.nitf": [
            "ntf",
            "nitf"
        ],
        "vnd.noblenet-directory": "nnd",
        "vnd.noblenet-sealer": "nns",
        "vnd.noblenet-web": "nnw",
        "vnd.nokia.n-gage.data": "ngdat",
        "vnd.nokia.n-gage.symbian.install": "n-gage",
        "vnd.nokia.radio-preset": "rpst",
        "vnd.nokia.radio-presets": "rpss",
        "vnd.novadigm.edm": "edm",
        "vnd.novadigm.edx": "edx",
        "vnd.novadigm.ext": "ext",
        "vnd.oasis.opendocument.chart-template": "otc",
        "vnd.oasis.opendocument.formula-template": "odft",
        "vnd.oasis.opendocument.image-template": "oti",
        "vnd.olpc-sugar": "xo",
        "vnd.oma.dd2+xml": "dd2",
        "vnd.openofficeorg.extension": "oxt",
        "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
        "vnd.osgeo.mapguide.package": "mgp",
        "vnd.osgi.dp": "dp",
        "vnd.osgi.subsystem": "esa",
        "vnd.palm": [
            "pdb",
            "pqa",
            "oprc"
        ],
        "vnd.pawaafile": "paw",
        "vnd.pg.format": "str",
        "vnd.pg.osasli": "ei6",
        "vnd.picsel": "efif",
        "vnd.pmi.widget": "wg",
        "vnd.pocketlearn": "plf",
        "vnd.powerbuilder6": "pbd",
        "vnd.previewsystems.box": "box",
        "vnd.proteus.magazine": "mgz",
        "vnd.publishare-delta-tree": "qps",
        "vnd.pvi.ptid1": "ptid",
        "vnd.quark.quarkxpress": [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ],
        "vnd.realvnc.bed": "bed",
        "vnd.recordare.musicxml": "mxl",
        "vnd.recordare.musicxml+xml": "musicxml",
        "vnd.rig.cryptonote": "cryptonote",
        "vnd.rn-realmedia": "rm",
        "vnd.rn-realmedia-vbr": "rmvb",
        "vnd.route66.link66+xml": "link66",
        "vnd.sailingtracker.track": "st",
        "vnd.seemail": "see",
        "vnd.sema": "sema",
        "vnd.semd": "semd",
        "vnd.semf": "semf",
        "vnd.shana.informed.formdata": "ifm",
        "vnd.shana.informed.formtemplate": "itp",
        "vnd.shana.informed.interchange": "iif",
        "vnd.shana.informed.package": "ipk",
        "vnd.simtech-mindmapper": [
            "twd",
            "twds"
        ],
        "vnd.smart.teacher": "teacher",
        "vnd.solent.sdkm+xml": [
            "sdkm",
            "sdkd"
        ],
        "vnd.spotfire.dxp": "dxp",
        "vnd.spotfire.sfs": "sfs",
        "vnd.stepmania.package": "smzip",
        "vnd.stepmania.stepchart": "sm",
        "vnd.sus-calendar": [
            "sus",
            "susp"
        ],
        "vnd.svd": "svd",
        "vnd.syncml+xml": "xsm",
        "vnd.syncml.dm+wbxml": "bdm",
        "vnd.syncml.dm+xml": "xdm",
        "vnd.tao.intent-module-archive": "tao",
        "vnd.tcpdump.pcap": [
            "pcap",
            "cap",
            "dmp"
        ],
        "vnd.tmobile-livetv": "tmo",
        "vnd.trid.tpt": "tpt",
        "vnd.triscape.mxs": "mxs",
        "vnd.trueapp": "tra",
        "vnd.ufdl": [
            "ufd",
            "ufdl"
        ],
        "vnd.uiq.theme": "utz",
        "vnd.umajin": "umj",
        "vnd.unity": "unityweb",
        "vnd.uoml+xml": "uoml",
        "vnd.vcx": "vcx",
        "vnd.visionary": "vis",
        "vnd.vsf": "vsf",
        "vnd.webturbo": "wtb",
        "vnd.wolfram.player": "nbp",
        "vnd.wqd": "wqd",
        "vnd.wt.stf": "stf",
        "vnd.xara": "xar",
        "vnd.xfdl": "xfdl",
        "vnd.yamaha.hv-dic": "hvd",
        "vnd.yamaha.hv-script": "hvs",
        "vnd.yamaha.hv-voice": "hvp",
        "vnd.yamaha.openscoreformat": "osf",
        "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
        "vnd.yamaha.smaf-audio": "saf",
        "vnd.yamaha.smaf-phrase": "spf",
        "vnd.yellowriver-custom-menu": "cmp",
        "vnd.zul": [
            "zir",
            "zirz"
        ],
        "vnd.zzazz.deck+xml": "zaz",
        "voicexml+xml": "vxml",
        "widget": "wgt",
        "winhlp": "hlp",
        "wsdl+xml": "wsdl",
        "wspolicy+xml": "wspolicy",
        "x-ace-compressed": "ace",
        "x-authorware-bin": [
            "aab",
            "x32",
            "u32",
            "vox"
        ],
        "x-authorware-map": "aam",
        "x-authorware-seg": "aas",
        "x-blorb": [
            "blb",
            "blorb"
        ],
        "x-bzip": "bz",
        "x-bzip2": [
            "bz2",
            "boz"
        ],
        "x-cfs-compressed": "cfs",
        "x-chat": "chat",
        "x-conference": "nsc",
        "x-dgc-compressed": "dgc",
        "x-dtbncx+xml": "ncx",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-eva": "eva",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": [
            "ttf",
            "ttc"
        ],
        "x-font-type1": [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ],
        "x-font-woff": "woff",
        "x-freearc": "arc",
        "x-gca-compressed": "gca",
        "x-glulx": "ulx",
        "x-gramps-xml": "gramps",
        "x-install-instructions": "install",
        "x-lzh-compressed": [
            "lzh",
            "lha"
        ],
        "x-mie": "mie",
        "x-mobipocket-ebook": [
            "prc",
            "mobi"
        ],
        "x-ms-application": "application",
        "x-ms-shortcut": "lnk",
        "x-ms-xbap": "xbap",
        "x-msbinder": "obd",
        "x-mscardfile": "crd",
        "x-msclip": "clp",
        "x-msdownload": [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ],
        "x-msmediaview": [
            "mvb",
            "m13",
            "m14"
        ],
        "x-msmetafile": [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ],
        "x-msmoney": "mny",
        "x-mspublisher": "pub",
        "x-msschedule": "scd",
        "x-msterminal": "trm",
        "x-mswrite": "wri",
        "x-nzb": "nzb",
        "x-pkcs12": [
            "p12",
            "pfx"
        ],
        "x-pkcs7-certificates": [
            "p7b",
            "spc"
        ],
        "x-research-info-systems": "ris",
        "x-silverlight-app": "xap",
        "x-sql": "sql",
        "x-stuffitx": "sitx",
        "x-subrip": "srt",
        "x-t3vm-image": "t3",
        "x-tads": "gam",
        "x-tex": "tex",
        "x-tex-tfm": "tfm",
        "x-tgif": "obj",
        "x-xliff+xml": "xlf",
        "x-xz": "xz",
        "x-zmachine": [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ],
        "xaml+xml": "xaml",
        "xcap-diff+xml": "xdf",
        "xenc+xml": "xenc",
        "xml-dtd": "dtd",
        "xop+xml": "xop",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "xv+xml": [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ],
        "yang": "yang",
        "yin+xml": "yin",
        "envoy": "evy",
        "fractals": "fif",
        "internet-property-stream": "acx",
        "olescript": "axs",
        "vnd.ms-outlook": "msg",
        "vnd.ms-pkicertstore": "sst",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz",
        "x-perfmon": [
            "pma",
            "pmc",
            "pml",
            "pmr",
            "pmw"
        ],
        "x-pkcs7-mime": [
            "p7c",
            "p7m"
        ],
        "ynd.ms-pkipko": "pko"
    },
    "audio": {
        "amr": "amr",
        "amr-wb": "awb",
        "annodex": "axa",
        "basic": [
            "au",
            "snd"
        ],
        "flac": "flac",
        "midi": [
            "mid",
            "midi",
            "kar",
            "rmi"
        ],
        "mpeg": [
            "mpga",
            "mpega",
            "mp2",
            "mp3",
            "m4a",
            "mp2a",
            "m2a",
            "m3a"
        ],
        "mpegurl": "m3u",
        "ogg": [
            "oga",
            "ogg",
            "spx"
        ],
        "prs.sid": "sid",
        "x-aiff": [
            "aif",
            "aiff",
            "aifc"
        ],
        "x-gsm": "gsm",
        "x-ms-wma": "wma",
        "x-ms-wax": "wax",
        "x-pn-realaudio": "ram",
        "x-realaudio": "ra",
        "x-sd2": "sd2",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "s3m": "s3m",
        "silk": "sil",
        "vnd.dece.audio": [
            "uva",
            "uvva"
        ],
        "vnd.digital-winds": "eol",
        "vnd.dra": "dra",
        "vnd.dts": "dts",
        "vnd.dts.hd": "dtshd",
        "vnd.lucent.voice": "lvp",
        "vnd.ms-playready.media.pya": "pya",
        "vnd.nuera.ecelp4800": "ecelp4800",
        "vnd.nuera.ecelp7470": "ecelp7470",
        "vnd.nuera.ecelp9600": "ecelp9600",
        "vnd.rip": "rip",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": [
            "mid",
            "rmi"
        ]
    },
    "chemical": {
        "x-alchemy": "alc",
        "x-cache": [
            "cac",
            "cache"
        ],
        "x-cache-csf": "csf",
        "x-cactvs-binary": [
            "cbin",
            "cascii",
            "ctab"
        ],
        "x-cdx": "cdx",
        "x-chem3d": "c3d",
        "x-cif": "cif",
        "x-cmdf": "cmdf",
        "x-cml": "cml",
        "x-compass": "cpa",
        "x-crossfire": "bsd",
        "x-csml": [
            "csml",
            "csm"
        ],
        "x-ctx": "ctx",
        "x-cxf": [
            "cxf",
            "cef"
        ],
        "x-embl-dl-nucleotide": [
            "emb",
            "embl"
        ],
        "x-gamess-input": [
            "inp",
            "gam",
            "gamin"
        ],
        "x-gaussian-checkpoint": [
            "fch",
            "fchk"
        ],
        "x-gaussian-cube": "cub",
        "x-gaussian-input": [
            "gau",
            "gjc",
            "gjf"
        ],
        "x-gaussian-log": "gal",
        "x-gcg8-sequence": "gcg",
        "x-genbank": "gen",
        "x-hin": "hin",
        "x-isostar": [
            "istr",
            "ist"
        ],
        "x-jcamp-dx": [
            "jdx",
            "dx"
        ],
        "x-kinemage": "kin",
        "x-macmolecule": "mcm",
        "x-macromodel-input": [
            "mmd",
            "mmod"
        ],
        "x-mdl-molfile": "mol",
        "x-mdl-rdfile": "rd",
        "x-mdl-rxnfile": "rxn",
        "x-mdl-sdfile": [
            "sd",
            "sdf"
        ],
        "x-mdl-tgf": "tgf",
        "x-mmcif": "mcif",
        "x-mol2": "mol2",
        "x-molconn-Z": "b",
        "x-mopac-graph": "gpt",
        "x-mopac-input": [
            "mop",
            "mopcrt",
            "mpc",
            "zmt"
        ],
        "x-mopac-out": "moo",
        "x-ncbi-asn1": "asn",
        "x-ncbi-asn1-ascii": [
            "prt",
            "ent"
        ],
        "x-ncbi-asn1-binary": [
            "val",
            "aso"
        ],
        "x-pdb": [
            "pdb",
            "ent"
        ],
        "x-rosdal": "ros",
        "x-swissprot": "sw",
        "x-vamas-iso14976": "vms",
        "x-vmd": "vmd",
        "x-xtel": "xtel",
        "x-xyz": "xyz"
    },
    "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": [
            "jpeg",
            "jpg",
            "jpe"
        ],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": [
            "svg",
            "svgz"
        ],
        "tiff": [
            "tiff",
            "tif"
        ],
        "vnd.djvu": [
            "djvu",
            "djv"
        ],
        "vnd.wap.wbmp": "wbmp",
        "x-canon-cr2": "cr2",
        "x-canon-crw": "crw",
        "x-cmu-raster": "ras",
        "x-coreldraw": "cdr",
        "x-coreldrawpattern": "pat",
        "x-coreldrawtemplate": "cdt",
        "x-corelphotopaint": "cpt",
        "x-epson-erf": "erf",
        "x-icon": "ico",
        "x-jg": "art",
        "x-jng": "jng",
        "x-nikon-nef": "nef",
        "x-olympus-orf": "orf",
        "x-photoshop": "psd",
        "x-portable-anymap": "pnm",
        "x-portable-bitmap": "pbm",
        "x-portable-graymap": "pgm",
        "x-portable-pixmap": "ppm",
        "x-rgb": "rgb",
        "x-xbitmap": "xbm",
        "x-xpixmap": "xpm",
        "x-xwindowdump": "xwd",
        "bmp": "bmp",
        "cgm": "cgm",
        "g3fax": "g3",
        "ktx": "ktx",
        "prs.btif": "btif",
        "sgi": "sgi",
        "vnd.dece.graphic": [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ],
        "vnd.dwg": "dwg",
        "vnd.dxf": "dxf",
        "vnd.fastbidsheet": "fbs",
        "vnd.fpx": "fpx",
        "vnd.fst": "fst",
        "vnd.fujixerox.edmics-mmr": "mmr",
        "vnd.fujixerox.edmics-rlc": "rlc",
        "vnd.ms-modi": "mdi",
        "vnd.ms-photo": "wdp",
        "vnd.net-fpx": "npx",
        "vnd.xiff": "xif",
        "webp": "webp",
        "x-3ds": "3ds",
        "x-cmx": "cmx",
        "x-freehand": [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ],
        "x-pict": [
            "pic",
            "pct"
        ],
        "x-tga": "tga",
        "cis-cod": "cod",
        "pipeg": "jfif"
    },
    "message": {
        "rfc822": [
            "eml",
            "mime",
            "mht",
            "mhtml",
            "nws"
        ]
    },
    "model": {
        "iges": [
            "igs",
            "iges"
        ],
        "mesh": [
            "msh",
            "mesh",
            "silo"
        ],
        "vrml": [
            "wrl",
            "vrml"
        ],
        "x3d+vrml": [
            "x3dv",
            "x3dvz"
        ],
        "x3d+xml": [
            "x3d",
            "x3dz"
        ],
        "x3d+binary": [
            "x3db",
            "x3dbz"
        ],
        "vnd.collada+xml": "dae",
        "vnd.dwf": "dwf",
        "vnd.gdl": "gdl",
        "vnd.gtw": "gtw",
        "vnd.mts": "mts",
        "vnd.vtu": "vtu"
    },
    "text": {
        "cache-manifest": [
            "manifest",
            "appcache"
        ],
        "calendar": [
            "ics",
            "icz",
            "ifb"
        ],
        "css": "css",
        "csv": "csv",
        "h323": "323",
        "html": [
            "html",
            "htm",
            "shtml",
            "stm"
        ],
        "iuls": "uls",
        "mathml": "mml",
        "plain": [
            "txt",
            "text",
            "brf",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "bas"
        ],
        "richtext": "rtx",
        "scriptlet": [
            "sct",
            "wsc"
        ],
        "texmacs": [
            "tm",
            "ts"
        ],
        "tab-separated-values": "tsv",
        "vnd.sun.j2me.app-descriptor": "jad",
        "vnd.wap.wml": "wml",
        "vnd.wap.wmlscript": "wmls",
        "x-bibtex": "bib",
        "x-boo": "boo",
        "x-c++hdr": [
            "h++",
            "hpp",
            "hxx",
            "hh"
        ],
        "x-c++src": [
            "c++",
            "cpp",
            "cxx",
            "cc"
        ],
        "x-component": "htc",
        "x-dsrc": "d",
        "x-diff": [
            "diff",
            "patch"
        ],
        "x-haskell": "hs",
        "x-java": "java",
        "x-literate-haskell": "lhs",
        "x-moc": "moc",
        "x-pascal": [
            "p",
            "pas"
        ],
        "x-pcs-gcd": "gcd",
        "x-perl": [
            "pl",
            "pm"
        ],
        "x-python": "py",
        "x-scala": "scala",
        "x-setext": "etx",
        "x-tcl": [
            "tcl",
            "tk"
        ],
        "x-tex": [
            "tex",
            "ltx",
            "sty",
            "cls"
        ],
        "x-vcalendar": "vcs",
        "x-vcard": "vcf",
        "n3": "n3",
        "prs.lines.tag": "dsc",
        "sgml": [
            "sgml",
            "sgm"
        ],
        "troff": [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ],
        "turtle": "ttl",
        "uri-list": [
            "uri",
            "uris",
            "urls"
        ],
        "vcard": "vcard",
        "vnd.curl": "curl",
        "vnd.curl.dcurl": "dcurl",
        "vnd.curl.scurl": "scurl",
        "vnd.curl.mcurl": "mcurl",
        "vnd.dvb.subtitle": "sub",
        "vnd.fly": "fly",
        "vnd.fmi.flexstor": "flx",
        "vnd.graphviz": "gv",
        "vnd.in3d.3dml": "3dml",
        "vnd.in3d.spot": "spot",
        "x-asm": [
            "s",
            "asm"
        ],
        "x-c": [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ],
        "x-fortran": [
            "f",
            "for",
            "f77",
            "f90"
        ],
        "x-opml": "opml",
        "x-nfo": "nfo",
        "x-sfv": "sfv",
        "x-uuencode": "uu",
        "webviewhtml": "htt"
    },
    "video": {
        "avif": ".avif",
        "3gpp": "3gp",
        "annodex": "axv",
        "dl": "dl",
        "dv": [
            "dif",
            "dv"
        ],
        "fli": "fli",
        "gl": "gl",
        "mpeg": [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v",
            "mp2",
            "mpa",
            "mpv2"
        ],
        "mp4": [
            "mp4",
            "mp4v",
            "mpg4"
        ],
        "quicktime": [
            "qt",
            "mov"
        ],
        "ogg": "ogv",
        "vnd.mpegurl": [
            "mxu",
            "m4u"
        ],
        "x-flv": "flv",
        "x-la-asf": [
            "lsf",
            "lsx"
        ],
        "x-mng": "mng",
        "x-ms-asf": [
            "asf",
            "asx",
            "asr"
        ],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": [
            "mpv",
            "mkv",
            "mk3d",
            "mks"
        ],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": [
            "jpm",
            "jpgm"
        ],
        "mj2": [
            "mj2",
            "mjp2"
        ],
        "vnd.dece.hd": [
            "uvh",
            "uvvh"
        ],
        "vnd.dece.mobile": [
            "uvm",
            "uvvm"
        ],
        "vnd.dece.pd": [
            "uvp",
            "uvvp"
        ],
        "vnd.dece.sd": [
            "uvs",
            "uvvs"
        ],
        "vnd.dece.video": [
            "uvv",
            "uvvv"
        ],
        "vnd.dvb.file": "dvb",
        "vnd.fvt": "fvt",
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": [
            "uvu",
            "uvvu"
        ],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
    },
    "x-conference": {
        "x-cooltalk": "ice"
    },
    "x-world": {
        "x-vrml": [
            "vrm",
            "vrml",
            "wrl",
            "flr",
            "wrz",
            "xaf",
            "xof"
        ]
    }
};
(()=>{
    const mimeTypes = {};
    for(let type in table){
        if (table.hasOwnProperty(type)) {
            for(let subtype in table[type]){
                if (table[type].hasOwnProperty(subtype)) {
                    const value = table[type][subtype];
                    if (typeof value == "string") {
                        mimeTypes[value] = type + "/" + subtype;
                    } else {
                        for(let indexMimeType = 0; indexMimeType < value.length; indexMimeType++){
                            mimeTypes[value[indexMimeType]] = type + "/" + subtype;
                        }
                    }
                }
            }
        }
    }
    return mimeTypes;
})();
"use strict";
const table1 = [];
for(let i2 = 0; i2 < 256; i2++){
    let t = i2;
    for(let j = 0; j < 8; j++){
        if (t & 1) {
            t = t >>> 1 ^ 0xEDB88320;
        } else {
            t = t >>> 1;
        }
    }
    table1[i2] = t;
}
class Crc32 {
    constructor(crc){
        this.crc = crc || -1;
    }
    append(data) {
        let crc = this.crc | 0;
        for(let offset = 0, length = data.length | 0; offset < length; offset++){
            crc = crc >>> 8 ^ table1[(crc ^ data[offset]) & 0xFF];
        }
        this.crc = crc;
    }
    get() {
        return ~this.crc;
    }
}
"use strict";
const bitArray = {
    concat (a1, a2) {
        if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
        }
        const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
        if (shift === 32) {
            return a1.concat(a2);
        } else {
            return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
        }
    },
    bitLength (a) {
        const l = a.length;
        if (l === 0) {
            return 0;
        }
        const x = a[l - 1];
        return (l - 1) * 32 + bitArray.getPartial(x);
    },
    clamp (a, len) {
        if (a.length * 32 < len) {
            return a;
        }
        a = a.slice(0, Math.ceil(len / 32));
        const l = a.length;
        len = len & 31;
        if (l > 0 && len) {
            a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);
        }
        return a;
    },
    partial (len, x, _end) {
        if (len === 32) {
            return x;
        }
        return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;
    },
    getPartial (x) {
        return Math.round(x / 0x10000000000) || 32;
    },
    _shiftRight (a, shift, carry, out) {
        if (out === undefined) {
            out = [];
        }
        for(; shift >= 32; shift -= 32){
            out.push(carry);
            carry = 0;
        }
        if (shift === 0) {
            return out.concat(a);
        }
        for(let i = 0; i < a.length; i++){
            out.push(carry | a[i] >>> shift);
            carry = a[i] << 32 - shift;
        }
        const last2 = a.length ? a[a.length - 1] : 0;
        const shift2 = bitArray.getPartial(last2);
        out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
        return out;
    }
};
const codec = {
    bytes: {
        fromBits (arr) {
            const bl = bitArray.bitLength(arr);
            const byteLength = bl / 8;
            const out = new Uint8Array(byteLength);
            let tmp;
            for(let i = 0; i < byteLength; i++){
                if ((i & 3) === 0) {
                    tmp = arr[i / 4];
                }
                out[i] = tmp >>> 24;
                tmp <<= 8;
            }
            return out;
        },
        toBits (bytes) {
            const out = [];
            let i;
            let tmp = 0;
            for(i = 0; i < bytes.length; i++){
                tmp = tmp << 8 | bytes[i];
                if ((i & 3) === 3) {
                    out.push(tmp);
                    tmp = 0;
                }
            }
            if (i & 3) {
                out.push(bitArray.partial(8 * (i & 3), tmp));
            }
            return out;
        }
    }
};
const hash = {};
hash.sha1 = function(hash) {
    if (hash) {
        this._h = hash._h.slice(0);
        this._buffer = hash._buffer.slice(0);
        this._length = hash._length;
    } else {
        this.reset();
    }
};
hash.sha1.prototype = {
    blockSize: 512,
    reset: function() {
        const sha1 = this;
        sha1._h = this._init.slice(0);
        sha1._buffer = [];
        sha1._length = 0;
        return sha1;
    },
    update: function(data) {
        const sha1 = this;
        if (typeof data === "string") {
            data = codec.utf8String.toBits(data);
        }
        const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
        const ol = sha1._length;
        const nl = sha1._length = ol + bitArray.bitLength(data);
        if (nl > 9007199254740991) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        const c = new Uint32Array(b);
        let j = 0;
        for(let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize){
            sha1._block(c.subarray(16 * j, 16 * (j + 1)));
            j += 1;
        }
        b.splice(0, 16 * j);
        return sha1;
    },
    finalize: function() {
        const sha1 = this;
        let b = sha1._buffer;
        const h = sha1._h;
        b = bitArray.concat(b, [
            bitArray.partial(1, 1)
        ]);
        for(let i = b.length + 2; i & 15; i++){
            b.push(0);
        }
        b.push(Math.floor(sha1._length / 0x100000000));
        b.push(sha1._length | 0);
        while(b.length){
            sha1._block(b.splice(0, 16));
        }
        sha1.reset();
        return h;
    },
    _init: [
        0x67452301,
        0xEFCDAB89,
        0x98BADCFE,
        0x10325476,
        0xC3D2E1F0
    ],
    _key: [
        0x5A827999,
        0x6ED9EBA1,
        0x8F1BBCDC,
        0xCA62C1D6
    ],
    _f: function(t, b, c, d) {
        if (t <= 19) {
            return b & c | ~b & d;
        } else if (t <= 39) {
            return b ^ c ^ d;
        } else if (t <= 59) {
            return b & c | b & d | c & d;
        } else if (t <= 79) {
            return b ^ c ^ d;
        }
    },
    _S: function(n, x) {
        return x << n | x >>> 32 - n;
    },
    _block: function(words) {
        const sha1 = this;
        const h = sha1._h;
        const w = Array(80);
        for(let j = 0; j < 16; j++){
            w[j] = words[j];
        }
        let a = h[0];
        let b = h[1];
        let c = h[2];
        let d = h[3];
        let e = h[4];
        for(let t = 0; t <= 79; t++){
            if (t >= 16) {
                w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
            }
            const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] + sha1._key[Math.floor(t / 20)] | 0;
            e = d;
            d = c;
            c = sha1._S(30, b);
            b = a;
            a = tmp;
        }
        h[0] = h[0] + a | 0;
        h[1] = h[1] + b | 0;
        h[2] = h[2] + c | 0;
        h[3] = h[3] + d | 0;
        h[4] = h[4] + e | 0;
    }
};
const cipher = {};
cipher.aes = class {
    constructor(key){
        const aes = this;
        aes._tables = [
            [
                [],
                [],
                [],
                [],
                []
            ],
            [
                [],
                [],
                [],
                [],
                []
            ]
        ];
        if (!aes._tables[0][0][0]) {
            aes._precompute();
        }
        const sbox = aes._tables[0][4];
        const decTable = aes._tables[1];
        const keyLen = key.length;
        let i, encKey, decKey, rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error("invalid aes key size");
        }
        aes._key = [
            encKey = key.slice(0),
            decKey = []
        ];
        for(i = keyLen; i < 4 * keyLen + 28; i++){
            let tmp = encKey[i - 1];
            if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                if (i % keyLen === 0) {
                    tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                    rcon = rcon << 1 ^ (rcon >> 7) * 283;
                }
            }
            encKey[i] = encKey[i - keyLen] ^ tmp;
        }
        for(let j = 0; i; j++, i--){
            const tmp1 = encKey[j & 3 ? i : i - 4];
            if (i <= 4 || j < 4) {
                decKey[j] = tmp1;
            } else {
                decKey[j] = decTable[0][sbox[tmp1 >>> 24]] ^ decTable[1][sbox[tmp1 >> 16 & 255]] ^ decTable[2][sbox[tmp1 >> 8 & 255]] ^ decTable[3][sbox[tmp1 & 255]];
            }
        }
    }
    encrypt(data) {
        return this._crypt(data, 0);
    }
    decrypt(data) {
        return this._crypt(data, 1);
    }
    _precompute() {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        const d = [];
        const th = [];
        let xInv, x2, x4, x8;
        for(let i = 0; i < 256; i++){
            th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
        }
        for(let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1){
            let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
            s = s >> 8 ^ s & 255 ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;
            x8 = d[x4 = d[x2 = d[x]]];
            let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
            let tEnc = d[s] * 0x101 ^ s * 0x1010100;
            for(let i1 = 0; i1 < 4; i1++){
                encTable[i1][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                decTable[i1][s] = tDec = tDec << 24 ^ tDec >>> 8;
            }
        }
        for(let i2 = 0; i2 < 5; i2++){
            encTable[i2] = encTable[i2].slice(0);
            decTable[i2] = decTable[i2].slice(0);
        }
    }
    _crypt(input, dir) {
        if (input.length !== 4) {
            throw new Error("invalid aes block size");
        }
        const key = this._key[dir];
        const nInnerRounds = key.length / 4 - 2;
        const out = [
            0,
            0,
            0,
            0
        ];
        const table = this._tables[dir];
        const t0 = table[0];
        const t1 = table[1];
        const t2 = table[2];
        const t3 = table[3];
        const sbox = table[4];
        let a = input[0] ^ key[0];
        let b = input[dir ? 3 : 1] ^ key[1];
        let c = input[2] ^ key[2];
        let d = input[dir ? 1 : 3] ^ key[3];
        let kIndex = 4;
        let a2, b2, c2;
        for(let i = 0; i < nInnerRounds; i++){
            a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
        }
        for(let i1 = 0; i1 < 4; i1++){
            out[dir ? 3 & -i1 : i1] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
        }
        return out;
    }
};
const mode = {};
mode.ctrGladman = class {
    constructor(prf, iv){
        this._prf = prf;
        this._initIv = iv;
        this._iv = iv;
    }
    reset() {
        this._iv = this._initIv;
    }
    update(data) {
        return this.calculate(this._prf, data, this._iv);
    }
    incWord(word) {
        if ((word >> 24 & 0xff) === 0xff) {
            let b1 = word >> 16 & 0xff;
            let b2 = word >> 8 & 0xff;
            let b3 = word & 0xff;
            if (b1 === 0xff) {
                b1 = 0;
                if (b2 === 0xff) {
                    b2 = 0;
                    if (b3 === 0xff) {
                        b3 = 0;
                    } else {
                        ++b3;
                    }
                } else {
                    ++b2;
                }
            } else {
                ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
        } else {
            word += 0x01 << 24;
        }
        return word;
    }
    incCounter(counter) {
        if ((counter[0] = this.incWord(counter[0])) === 0) {
            counter[1] = this.incWord(counter[1]);
        }
    }
    calculate(prf, data, iv) {
        let l;
        if (!(l = data.length)) {
            return [];
        }
        const bl = bitArray.bitLength(data);
        for(let i = 0; i < l; i += 4){
            this.incCounter(iv);
            const e = prf.encrypt(iv);
            data[i] ^= e[0];
            data[i + 1] ^= e[1];
            data[i + 2] ^= e[2];
            data[i + 3] ^= e[3];
        }
        return bitArray.clamp(data, bl);
    }
};
const misc = {};
misc.hmacSha1 = class {
    constructor(key){
        const hmac = this;
        const Hash = hmac._hash = hash.sha1;
        const exKey = [
            [],
            []
        ];
        const bs = Hash.prototype.blockSize / 32;
        hmac._baseHash = [
            new Hash(),
            new Hash()
        ];
        if (key.length > bs) {
            key = Hash.hash(key);
        }
        for(let i = 0; i < bs; i++){
            exKey[0][i] = key[i] ^ 0x36363636;
            exKey[1][i] = key[i] ^ 0x5C5C5C5C;
        }
        hmac._baseHash[0].update(exKey[0]);
        hmac._baseHash[1].update(exKey[1]);
        hmac._resultHash = new Hash(hmac._baseHash[0]);
    }
    reset() {
        const hmac = this;
        hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
        hmac._updated = false;
    }
    update(data) {
        const hmac = this;
        hmac._updated = true;
        hmac._resultHash.update(data);
    }
    digest() {
        const hmac = this;
        const w = hmac._resultHash.finalize();
        const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
        hmac.reset();
        return result;
    }
};
"use strict";
const ERR_INVALID_PASSWORD = "Invalid pasword";
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = {
    name: "PBKDF2"
};
const HASH_ALGORITHM = {
    name: "HMAC"
};
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({
    hash: HASH_ALGORITHM
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({
    iterations: 1000,
    hash: {
        name: HASH_FUNCTION
    }
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = [
    "deriveBits"
];
const SALT_LENGTH = [
    8,
    12,
    16
];
const KEY_LENGTH = [
    16,
    24,
    32
];
const COUNTER_DEFAULT_VALUE = [
    0,
    0,
    0,
    0
];
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;
class AESDecrypt {
    constructor(password, signed, strength){
        Object.assign(this, {
            password,
            signed,
            strength: strength - 1,
            pendingInput: new Uint8Array(0)
        });
    }
    async append(input) {
        const aesCrypto = this;
        if (aesCrypto.password) {
            const preamble = subarray(input, 0, SALT_LENGTH[aesCrypto.strength] + 2);
            await createDecryptionKeys(aesCrypto, preamble, aesCrypto.password);
            aesCrypto.password = null;
            aesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
            aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
            input = subarray(input, SALT_LENGTH[aesCrypto.strength] + 2);
        }
        const output = new Uint8Array(input.length - 10 - (input.length - 10) % 16);
        return append(aesCrypto, input, output, 0, 10, true);
    }
    flush() {
        const aesCrypto = this;
        const pendingInput = aesCrypto.pendingInput;
        const chunkToDecrypt = subarray(pendingInput, 0, pendingInput.length - 10);
        const originalSignature = subarray(pendingInput, pendingInput.length - 10);
        let decryptedChunkArray = new Uint8Array(0);
        if (chunkToDecrypt.length) {
            const encryptedChunk = codecBytes.toBits(chunkToDecrypt);
            aesCrypto.hmac.update(encryptedChunk);
            const decryptedChunk = aesCrypto.aesCtrGladman.update(encryptedChunk);
            decryptedChunkArray = codecBytes.fromBits(decryptedChunk);
        }
        let valid = true;
        if (aesCrypto.signed) {
            const signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, 10);
            for(let indexSignature = 0; indexSignature < 10; indexSignature++){
                if (signature[indexSignature] != originalSignature[indexSignature]) {
                    valid = false;
                }
            }
        }
        return {
            valid,
            data: decryptedChunkArray
        };
    }
}
class AESEncrypt {
    constructor(password, strength){
        Object.assign(this, {
            password,
            strength: strength - 1,
            pendingInput: new Uint8Array(0)
        });
    }
    async append(input) {
        const aesCrypto = this;
        let preamble = new Uint8Array(0);
        if (aesCrypto.password) {
            preamble = await createEncryptionKeys(aesCrypto, aesCrypto.password);
            aesCrypto.password = null;
            aesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));
            aesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);
        }
        const output = new Uint8Array(preamble.length + input.length - input.length % 16);
        output.set(preamble, 0);
        return append(aesCrypto, input, output, preamble.length, 0);
    }
    flush() {
        const aesCrypto = this;
        let encryptedChunkArray = new Uint8Array(0);
        if (aesCrypto.pendingInput.length) {
            const encryptedChunk = aesCrypto.aesCtrGladman.update(codecBytes.toBits(aesCrypto.pendingInput));
            aesCrypto.hmac.update(encryptedChunk);
            encryptedChunkArray = codecBytes.fromBits(encryptedChunk);
        }
        const signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, 10);
        return {
            data: concat(encryptedChunkArray, signature),
            signature
        };
    }
}
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
    const inputLength = input.length - paddingEnd;
    if (aesCrypto.pendingInput.length) {
        input = concat(aesCrypto.pendingInput, input);
        output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
    }
    let offset;
    for(offset = 0; offset <= inputLength - 16; offset += BLOCK_LENGTH){
        const inputChunk = codecBytes.toBits(subarray(input, offset, offset + 16));
        if (verifySignature) {
            aesCrypto.hmac.update(inputChunk);
        }
        const outputChunk = aesCrypto.aesCtrGladman.update(inputChunk);
        if (!verifySignature) {
            aesCrypto.hmac.update(outputChunk);
        }
        output.set(codecBytes.fromBits(outputChunk), offset + paddingStart);
    }
    aesCrypto.pendingInput = subarray(input, offset);
    return output;
}
async function createDecryptionKeys(decrypt, preambleArray, password) {
    await createKeys(decrypt, password, subarray(preambleArray, 0, SALT_LENGTH[decrypt.strength]));
    const passwordVerification = subarray(preambleArray, SALT_LENGTH[decrypt.strength]);
    const passwordVerificationKey = decrypt.keys.passwordVerification;
    if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
        throw new Error(ERR_INVALID_PASSWORD);
    }
}
async function createEncryptionKeys(encrypt, password) {
    const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH[encrypt.strength]));
    await createKeys(encrypt, password, salt);
    return concat(salt, encrypt.keys.passwordVerification);
}
async function createKeys(target, password, salt) {
    const encodedPassword = new TextEncoder().encode(password);
    const basekey = await crypto.subtle.importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
    const derivedBits = await crypto.subtle.deriveBits(Object.assign({
        salt
    }, DERIVED_BITS_ALGORITHM), basekey, 8 * (KEY_LENGTH[target.strength] * 2 + 2));
    const compositeKey = new Uint8Array(derivedBits);
    target.keys = {
        key: codecBytes.toBits(subarray(compositeKey, 0, KEY_LENGTH[target.strength])),
        authentication: codecBytes.toBits(subarray(compositeKey, KEY_LENGTH[target.strength], KEY_LENGTH[target.strength] * 2)),
        passwordVerification: subarray(compositeKey, KEY_LENGTH[target.strength] * 2)
    };
}
function concat(leftArray, rightArray) {
    let array = leftArray;
    if (leftArray.length + rightArray.length) {
        array = new Uint8Array(leftArray.length + rightArray.length);
        array.set(leftArray, 0);
        array.set(rightArray, leftArray.length);
    }
    return array;
}
function expand(inputArray, length) {
    if (length && length > inputArray.length) {
        const array = inputArray;
        inputArray = new Uint8Array(length);
        inputArray.set(array, 0);
    }
    return inputArray;
}
function subarray(array, begin, end) {
    return array.subarray(begin, end);
}
"use strict";
const HEADER_LENGTH = 12;
class ZipCryptoDecrypt {
    constructor(password, passwordVerification){
        const zipCrypto = this;
        Object.assign(zipCrypto, {
            password,
            passwordVerification
        });
        createKeys1(zipCrypto, password);
    }
    append(input) {
        const zipCrypto = this;
        if (zipCrypto.password) {
            const decryptedHeader = decrypt(zipCrypto, input.subarray(0, 12));
            zipCrypto.password = null;
            if (decryptedHeader[12 - 1] != zipCrypto.passwordVerification) {
                throw new Error(ERR_INVALID_PASSWORD);
            }
            input = input.subarray(HEADER_LENGTH);
        }
        return decrypt(zipCrypto, input);
    }
    flush() {
        return {
            valid: true,
            data: new Uint8Array(0)
        };
    }
}
class ZipCryptoEncrypt {
    constructor(password, passwordVerification){
        const zipCrypto = this;
        Object.assign(zipCrypto, {
            password,
            passwordVerification
        });
        createKeys1(zipCrypto, password);
    }
    append(input) {
        const zipCrypto = this;
        let output;
        let offset;
        if (zipCrypto.password) {
            zipCrypto.password = null;
            const header = crypto.getRandomValues(new Uint8Array(12));
            header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
            output = new Uint8Array(input.length + header.length);
            output.set(encrypt(zipCrypto, header), 0);
            offset = HEADER_LENGTH;
        } else {
            output = new Uint8Array(input.length);
            offset = 0;
        }
        output.set(encrypt(zipCrypto, input), offset);
        return output;
    }
    flush() {
        return {
            data: new Uint8Array(0)
        };
    }
}
function decrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, output[index]);
    }
    return output;
}
function encrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, input[index]);
    }
    return output;
}
function createKeys1(target, password) {
    target.keys = [
        0x12345678,
        0x23456789,
        0x34567890
    ];
    target.crcKey0 = new Crc32(target.keys[0]);
    target.crcKey2 = new Crc32(target.keys[2]);
    for(let index = 0; index < password.length; index++){
        updateKeys(target, password.charCodeAt(index));
    }
}
function updateKeys(target, __byte) {
    target.crcKey0.append([
        __byte
    ]);
    target.keys[0] = ~target.crcKey0.get();
    target.keys[1] = getInt32(target.keys[1] + getInt8(target.keys[0]));
    target.keys[1] = getInt32(Math.imul(target.keys[1], 134775813) + 1);
    target.crcKey2.append([
        target.keys[1] >>> 24
    ]);
    target.keys[2] = ~target.crcKey2.get();
}
function getByte(target) {
    const temp = target.keys[2] | 2;
    return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
    return number & 0xFF;
}
function getInt32(number) {
    return number & 0xFFFFFFFF;
}
"use strict";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
const ERR_INVALID_SIGNATURE = "Invalid signature";
class Inflate1 {
    constructor(codecConstructor, { signature , password , signed , compressed , zipCrypto , passwordVerification , encryptionStrength  }, { chunkSize  }){
        const encrypted = Boolean(password);
        Object.assign(this, {
            signature,
            encrypted,
            signed,
            compressed,
            inflate: compressed && new codecConstructor({
                chunkSize
            }),
            crc32: signed && new Crc32(),
            zipCrypto,
            decrypt: encrypted && zipCrypto ? new ZipCryptoDecrypt(password, passwordVerification) : new AESDecrypt(password, signed, encryptionStrength)
        });
    }
    async append(data) {
        const codec = this;
        if (codec.encrypted && data.length) {
            data = await codec.decrypt.append(data);
        }
        if (codec.compressed && data.length) {
            data = await codec.inflate.append(data);
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed && data.length) {
            codec.crc32.append(data);
        }
        return data;
    }
    async flush() {
        const codec = this;
        let signature;
        let data = new Uint8Array(0);
        if (codec.encrypted) {
            const result = codec.decrypt.flush();
            if (!result.valid) {
                throw new Error(ERR_INVALID_SIGNATURE);
            }
            data = result.data;
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed) {
            const dataViewSignature = new DataView(new Uint8Array(4).buffer);
            signature = codec.crc32.get();
            dataViewSignature.setUint32(0, signature);
            if (codec.signature != dataViewSignature.getUint32(0, false)) {
                throw new Error(ERR_INVALID_SIGNATURE);
            }
        }
        if (codec.compressed) {
            data = await codec.inflate.append(data) || new Uint8Array(0);
            await codec.inflate.flush();
        }
        return {
            data,
            signature
        };
    }
}
class Deflate1 {
    constructor(codecConstructor, { encrypted , signed , compressed , level , zipCrypto , password , passwordVerification , encryptionStrength  }, { chunkSize  }){
        Object.assign(this, {
            encrypted,
            signed,
            compressed,
            deflate: compressed && new codecConstructor({
                level: level || 5,
                chunkSize
            }),
            crc32: signed && new Crc32(),
            zipCrypto,
            encrypt: encrypted && zipCrypto ? new ZipCryptoEncrypt(password, passwordVerification) : new AESEncrypt(password, encryptionStrength)
        });
    }
    async append(inputData) {
        const codec = this;
        let data = inputData;
        if (codec.compressed && inputData.length) {
            data = await codec.deflate.append(inputData);
        }
        if (codec.encrypted && data.length) {
            data = await codec.encrypt.append(data);
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed && inputData.length) {
            codec.crc32.append(inputData);
        }
        return data;
    }
    async flush() {
        const codec = this;
        let signature;
        let data = new Uint8Array(0);
        if (codec.compressed) {
            data = await codec.deflate.flush() || new Uint8Array(0);
        }
        if (codec.encrypted) {
            data = await codec.encrypt.append(data);
            const result = codec.encrypt.flush();
            signature = result.signature;
            const newData = new Uint8Array(data.length + result.data.length);
            newData.set(data, 0);
            newData.set(result.data, data.length);
            data = newData;
        }
        if ((!codec.encrypted || codec.zipCrypto) && codec.signed) {
            signature = codec.crc32.get();
        }
        return {
            data,
            signature
        };
    }
}
function createCodec(codecConstructor, options, config) {
    if (options.codecType.startsWith(CODEC_DEFLATE)) {
        return new Deflate1(codecConstructor, options, config);
    } else if (options.codecType.startsWith(CODEC_INFLATE)) {
        return new Inflate1(codecConstructor, options, config);
    }
}
"use strict";
const importMeta1 = {
    url: "file:///data/Projets/Logiciels/deno/Studio-Pack-Generator/vendor/deno.land/x/zipjs@v2.3.17/lib/core/codecs/codec-pool-worker.js",
    main: false
};
const MESSAGE_INIT = "init";
const MESSAGE_APPEND = "append";
const MESSAGE_FLUSH = "flush";
const MESSAGE_EVENT_TYPE = "message";
let classicWorkersSupported = true;
function createWorkerInterface(workerData, config) {
    const interfaceCodec = createCodec(workerData.codecConstructor, workerData.options, config);
    return {
        async append (data) {
            try {
                return await interfaceCodec.append(data);
            } catch (error) {
                workerData.onTaskFinished();
                throw error;
            }
        },
        async flush () {
            try {
                return await interfaceCodec.flush();
            } finally{
                workerData.onTaskFinished();
            }
        }
    };
}
function createWebWorkerInterface(workerData, config) {
    let messageTask;
    const moduleType = {
        type: "module"
    };
    if (!workerData.interface) {
        if (!classicWorkersSupported) {
            workerData.worker = getWorker(moduleType);
        } else {
            try {
                workerData.worker = getWorker();
            } catch (error) {
                classicWorkersSupported = false;
                workerData.worker = getWorker(moduleType);
            }
        }
        workerData.worker.addEventListener(MESSAGE_EVENT_TYPE, onMessage, false);
        workerData.interface = {
            append (data) {
                return initAndSendMessage({
                    type: MESSAGE_APPEND,
                    data
                });
            },
            flush () {
                return initAndSendMessage({
                    type: MESSAGE_FLUSH
                });
            }
        };
    }
    return workerData.interface;
    function getWorker(options = {}) {
        return new Worker(new URL(workerData.scripts[0], importMeta1.url), options);
    }
    async function initAndSendMessage(message) {
        if (!messageTask) {
            const options = workerData.options;
            const scripts = workerData.scripts.slice(1);
            await sendMessage({
                scripts,
                type: MESSAGE_INIT,
                options,
                config: {
                    chunkSize: config.chunkSize
                }
            });
        }
        return sendMessage(message);
    }
    function sendMessage(message) {
        const worker = workerData.worker;
        const result = new Promise((resolve, reject)=>messageTask = {
                resolve,
                reject
            });
        try {
            if (message.data) {
                try {
                    message.data = message.data.buffer;
                    worker.postMessage(message, [
                        message.data
                    ]);
                } catch (error) {
                    worker.postMessage(message);
                }
            } else {
                worker.postMessage(message);
            }
        } catch (error1) {
            messageTask.reject(error1);
            messageTask = null;
            workerData.onTaskFinished();
        }
        return result;
    }
    function onMessage(event) {
        const message = event.data;
        if (messageTask) {
            const reponseError = message.error;
            const type = message.type;
            if (reponseError) {
                const error = new Error(reponseError.message);
                error.stack = reponseError.stack;
                messageTask.reject(error);
                messageTask = null;
                workerData.onTaskFinished();
            } else if (type == MESSAGE_INIT || type == MESSAGE_FLUSH || type == MESSAGE_APPEND) {
                const data = message.data;
                if (type == MESSAGE_FLUSH) {
                    messageTask.resolve({
                        data: new Uint8Array(data),
                        signature: message.signature
                    });
                    messageTask = null;
                    workerData.onTaskFinished();
                } else {
                    messageTask.resolve(data && new Uint8Array(data));
                }
            }
        }
    }
}
const __default6 = (workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts)=>{
    Object.assign(workerData, {
        busy: true,
        codecConstructor,
        options: Object.assign({}, options),
        scripts,
        terminate () {
            if (workerData.worker && !workerData.busy) {
                workerData.worker.terminate();
                workerData.interface = null;
            }
        },
        onTaskFinished () {
            workerData.busy = false;
            onTaskFinished(workerData);
        }
    });
    return webWorker ? createWebWorkerInterface(workerData, config) : createWorkerInterface(workerData, config);
};
"use strict";
let pool = [];
let pendingRequests = [];
function createCodec1(codecConstructor, options, config) {
    const streamCopy = !options.compressed && !options.signed && !options.encrypted;
    const webWorker = !streamCopy && (options.useWebWorkers || options.useWebWorkers === undefined && config.useWebWorkers);
    const scripts = webWorker && config.workerScripts ? config.workerScripts[options.codecType] : [];
    if (pool.length < config.maxWorkers) {
        const workerData = {};
        pool.push(workerData);
        return __default6(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts);
    } else {
        const workerData1 = pool.find((workerData)=>!workerData.busy);
        if (workerData1) {
            clearTerminateTimeout(workerData1);
            return __default6(workerData1, codecConstructor, options, config, onTaskFinished, webWorker, scripts);
        } else {
            return new Promise((resolve)=>pendingRequests.push({
                    resolve,
                    codecConstructor,
                    options,
                    webWorker,
                    scripts
                }));
        }
    }
    function onTaskFinished(workerData) {
        if (pendingRequests.length) {
            const [{ resolve , codecConstructor , options , webWorker , scripts  }] = pendingRequests.splice(0, 1);
            resolve(__default6(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts));
        } else if (workerData.worker) {
            clearTerminateTimeout(workerData);
            if (Number.isFinite(config.terminateWorkerTimeout) && config.terminateWorkerTimeout >= 0) {
                workerData.terminateTimeout = setTimeout(()=>{
                    pool = pool.filter((data)=>data != workerData);
                    workerData.terminate();
                }, config.terminateWorkerTimeout);
            }
        } else {
            pool = pool.filter((data)=>data != workerData);
        }
    }
}
function clearTerminateTimeout(workerData) {
    if (workerData.terminateTimeout) {
        clearTimeout(workerData.terminateTimeout);
        workerData.terminateTimeout = null;
    }
}
const __default7 = ()=>{
    if ("function" == typeof URL.createObjectURL) {
        const e = '\n\t\t\t\n\nconst t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n;}class e{constructor(t){this.crc=t||-1;}append(e){let n=0|this.crc;for(let i=0,a=0|e.length;i<a;i++)n=n>>>8^t[255&(n^e[i])];this.crc=n;}get(){return ~this.crc}}const n={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const i=t[t.length-1],a=n.getPartial(i);return 32===a?t.concat(e):n._shiftRight(e,a,0|i,t.slice(0,t.length-1))},bitLength(t){const e=t.length;if(0===e)return 0;const i=t[e-1];return 32*(e-1)+n.getPartial(i)},clamp(t,e){if(32*t.length<e)return t;const i=(t=t.slice(0,Math.ceil(e/32))).length;return e&=31,i>0&&e&&(t[i-1]=n.partial(e,t[i-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>Math.round(t/1099511627776)||32,_shiftRight(t,e,i,a){for(void 0===a&&(a=[]);e>=32;e-=32)a.push(i),i=0;if(0===e)return a.concat(t);for(let n=0;n<t.length;n++)a.push(i|t[n]>>>e),i=t[n]<<32-e;const r=t.length?t[t.length-1]:0,s=n.getPartial(r);return a.push(n.partial(e+s&31,e+s>32?i:a.pop(),1)),a}},i={bytes:{fromBits(t){const e=n.bitLength(t)/8,i=new Uint8Array(e);let a;for(let n=0;n<e;n++)0==(3&n)&&(a=t[n/4]),i[n]=a>>>24,a<<=8;return i},toBits(t){const e=[];let i,a=0;for(i=0;i<t.length;i++)a=a<<8|t[i],3==(3&i)&&(e.push(a),a=0);return 3&i&&e.push(n.partial(8*(3&i),a)),e}}},a={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset();}};a.sha1.prototype={blockSize:512,reset:function(){const t=this;return t._h=this._init.slice(0),t._buffer=[],t._length=0,t},update:function(t){const e=this;"string"==typeof t&&(t=i.utf8String.toBits(t));const a=e._buffer=n.concat(e._buffer,t),r=e._length,s=e._length=r+n.bitLength(t);if(s>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const o=new Uint32Array(a);let l=0;for(let t=e.blockSize+r-(e.blockSize+r&e.blockSize-1);t<=s;t+=e.blockSize)e._block(o.subarray(16*l,16*(l+1))),l+=1;return a.splice(0,16*l),e},finalize:function(){const t=this;let e=t._buffer;const i=t._h;e=n.concat(e,[n.partial(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(Math.floor(t._length/4294967296)),e.push(0|t._length);e.length;)t._block(e.splice(0,16));return t.reset(),i},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:function(t,e,n,i){return t<=19?e&n|~e&i:t<=39?e^n^i:t<=59?e&n|e&i|n&i:t<=79?e^n^i:void 0},_S:function(t,e){return e<<t|e>>>32-t},_block:function(t){const e=this,n=e._h,i=Array(80);for(let e=0;e<16;e++)i[e]=t[e];let a=n[0],r=n[1],s=n[2],o=n[3],l=n[4];for(let t=0;t<=79;t++){t>=16&&(i[t]=e._S(1,i[t-3]^i[t-8]^i[t-14]^i[t-16]));const n=e._S(5,a)+e._f(t,r,s,o)+l+i[t]+e._key[Math.floor(t/20)]|0;l=o,o=s,s=e._S(30,r),r=a,a=n;}n[0]=n[0]+a|0,n[1]=n[1]+r|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0;}};const r={aes:class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const n=e._tables[0][4],i=e._tables[1],a=t.length;let r,s,o,l=1;if(4!==a&&6!==a&&8!==a)throw new Error("invalid aes key size");for(e._key=[s=t.slice(0),o=[]],r=a;r<4*a+28;r++){let t=s[r-1];(r%a==0||8===a&&r%a==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],r%a==0&&(t=t<<8^t>>>24^l<<24,l=l<<1^283*(l>>7))),s[r]=s[r-a]^t;}for(let t=0;r;t++,r--){const e=s[3&t?r:r-4];o[t]=r<=4||t<4?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]];}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const t=this._tables[0],e=this._tables[1],n=t[4],i=e[4],a=[],r=[];let s,o,l,_;for(let t=0;t<256;t++)r[(a[t]=t<<1^283*(t>>7))^t]=t;for(let d=s=0;!n[d];d^=o||1,s=r[s]||1){let r=s^s<<1^s<<2^s<<3^s<<4;r=r>>8^255&r^99,n[d]=r,i[r]=d,_=a[l=a[o=a[d]]];let c=16843009*_^65537*l^257*o^16843008*d,f=257*a[r]^16843008*r;for(let n=0;n<4;n++)t[n][d]=f=f<<24^f>>>8,e[n][r]=c=c<<24^c>>>8;}for(let n=0;n<5;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0);}_crypt(t,e){if(4!==t.length)throw new Error("invalid aes block size");const n=this._key[e],i=n.length/4-2,a=[0,0,0,0],r=this._tables[e],s=r[0],o=r[1],l=r[2],_=r[3],d=r[4];let c,f,u,h=t[0]^n[0],b=t[e?3:1]^n[1],w=t[2]^n[2],p=t[e?1:3]^n[3],x=4;for(let t=0;t<i;t++)c=s[h>>>24]^o[b>>16&255]^l[w>>8&255]^_[255&p]^n[x],f=s[b>>>24]^o[w>>16&255]^l[p>>8&255]^_[255&h]^n[x+1],u=s[w>>>24]^o[p>>16&255]^l[h>>8&255]^_[255&b]^n[x+2],p=s[p>>>24]^o[h>>16&255]^l[b>>8&255]^_[255&w]^n[x+3],x+=4,h=c,b=f,w=u;for(let t=0;t<4;t++)a[e?3&-t:t]=d[h>>>24]<<24^d[b>>16&255]<<16^d[w>>8&255]<<8^d[255&p]^n[x++],c=h,h=b,b=w,w=p,p=c;return a}}},s={ctrGladman:class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e;}reset(){this._iv=this._initIv;}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,i=255&t;255===e?(e=0,255===n?(n=0,255===i?i=0:++i):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=i;}else t+=1<<24;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]));}calculate(t,e,i){let a;if(!(a=e.length))return [];const r=n.bitLength(e);for(let n=0;n<a;n+=4){this.incCounter(i);const a=t.encrypt(i);e[n]^=a[0],e[n+1]^=a[1],e[n+2]^=a[2],e[n+3]^=a[3];}return n.clamp(e,r)}}},o={hmacSha1:class{constructor(t){const e=this,n=e._hash=a.sha1,i=[[],[]],r=n.prototype.blockSize/32;e._baseHash=[new n,new n],t.length>r&&(t=n.hash(t));for(let e=0;e<r;e++)i[0][e]=909522486^t[e],i[1][e]=1549556828^t[e];e._baseHash[0].update(i[0]),e._baseHash[1].update(i[1]),e._resultHash=new n(e._baseHash[0]);}reset(){const t=this;t._resultHash=new t._hash(t._baseHash[0]),t._updated=!1;}update(t){this._updated=!0,this._resultHash.update(t);}digest(){const t=this,e=t._resultHash.finalize(),n=new t._hash(t._baseHash[1]).update(e).finalize();return t.reset(),n}}},l={name:"PBKDF2"},_=Object.assign({hash:{name:"HMAC"}},l),d=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},l),c=["deriveBits"],f=[8,12,16],u=[16,24,32],h=[0,0,0,0],b=i.bytes,w=r.aes,p=s.ctrGladman,x=o.hmacSha1;class g{constructor(t,e,n){Object.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;if(e.password){const n=A(t,0,f[e.strength]+2);await async function(t,e,n){await k(t,n,A(e,0,f[t.strength]));const i=A(e,f[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error("Invalid pasword")}(e,n,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication),t=A(t,f[e.strength]+2);}return m(e,t,new Uint8Array(t.length-10-(t.length-10)%16),0,10,!0)}flush(){const t=this,e=t.pendingInput,n=A(e,0,e.length-10),i=A(e,e.length-10);let a=new Uint8Array(0);if(n.length){const e=b.toBits(n);t.hmac.update(e);const i=t.aesCtrGladman.update(e);a=b.fromBits(i);}let r=!0;if(t.signed){const e=A(b.fromBits(t.hmac.digest()),0,10);for(let t=0;t<10;t++)e[t]!=i[t]&&(r=!1);}return {valid:r,data:a}}}class y{constructor(t,e){Object.assign(this,{password:t,strength:e-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;let n=new Uint8Array(0);e.password&&(n=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(f[t.strength]));return await k(t,e,n),v(n,t.keys.passwordVerification)}(e,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication));const i=new Uint8Array(n.length+t.length-t.length%16);return i.set(n,0),m(e,t,i,n.length,0)}flush(){const t=this;let e=new Uint8Array(0);if(t.pendingInput.length){const n=t.aesCtrGladman.update(b.toBits(t.pendingInput));t.hmac.update(n),e=b.fromBits(n);}const n=A(b.fromBits(t.hmac.digest()),0,10);return {data:v(e,n),signature:n}}}function m(t,e,n,i,a,r){const s=e.length-a;let o;for(t.pendingInput.length&&(e=v(t.pendingInput,e),n=function(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0);}return t}(n,s-s%16)),o=0;o<=s-16;o+=16){const a=b.toBits(A(e,o,o+16));r&&t.hmac.update(a);const s=t.aesCtrGladman.update(a);r||t.hmac.update(s),n.set(b.fromBits(s),o+i);}return t.pendingInput=A(e,o),n}async function k(t,e,n){const i=(new TextEncoder).encode(e),a=await crypto.subtle.importKey("raw",i,_,!1,c),r=await crypto.subtle.deriveBits(Object.assign({salt:n},d),a,8*(2*u[t.strength]+2)),s=new Uint8Array(r);t.keys={key:b.toBits(A(s,0,u[t.strength])),authentication:b.toBits(A(s,u[t.strength],2*u[t.strength])),passwordVerification:A(s,2*u[t.strength])};}function v(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function A(t,e,n){return t.subarray(e,n)}class U{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;if(e.password){const n=z(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new Error("Invalid pasword");t=t.subarray(12);}return z(e,t)}flush(){return {valid:!0,data:new Uint8Array(0)}}}class S{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;let n,i;if(e.password){e.password=null;const a=crypto.getRandomValues(new Uint8Array(12));a[11]=e.passwordVerification,n=new Uint8Array(t.length+a.length),n.set(I(e,a),0),i=12;}else n=new Uint8Array(t.length),i=0;return n.set(I(e,t),i),n}flush(){return {data:new Uint8Array(0)}}}function z(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,n[i]);return n}function I(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,e[i]);return n}function E(t,n){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<n.length;e++)C(t,n.charCodeAt(e));}function C(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=H(t.keys[1]+B(t.keys[0])),t.keys[1]=H(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get();}function M(t){const e=2|t.keys[2];return B(Math.imul(e,1^e)>>>8)}function B(t){return 255&t}function H(t){return 4294967295&t}class V{constructor(t,{signature:n,password:i,signed:a,compressed:r,zipCrypto:s,passwordVerification:o,encryptionStrength:l},{chunkSize:_}){const d=Boolean(i);Object.assign(this,{signature:n,encrypted:d,signed:a,compressed:r,inflate:r&&new t({chunkSize:_}),crc32:a&&new e,zipCrypto:s,decrypt:d&&s?new U(i,o):new g(i,a,l)});}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new Error("Invalid signature");n=e.data;}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new DataView(new Uint8Array(4).buffer);if(e=t.crc32.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new Error("Invalid signature")}return t.compressed&&(n=await t.inflate.append(n)||new Uint8Array(0),await t.inflate.flush()),{data:n,signature:e}}}class D{constructor(t,{encrypted:n,signed:i,compressed:a,level:r,zipCrypto:s,password:o,passwordVerification:l,encryptionStrength:_},{chunkSize:d}){Object.assign(this,{encrypted:n,signed:i,compressed:a,deflate:a&&new t({level:r||5,chunkSize:d}),crc32:i&&new e,zipCrypto:s,encrypt:n&&s?new S(o,l):new y(o,_)});}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.compressed&&(n=await t.deflate.flush()||new Uint8Array(0)),t.encrypted){n=await t.encrypt.append(n);const i=t.encrypt.flush();e=i.signature;const a=new Uint8Array(n.length+i.data.length);a.set(n,0),a.set(i.data,n.length),n=a;}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const j={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate),O=function(t,e,n){return e.codecType.startsWith("deflate")?new D(t,e,n):e.codecType.startsWith("inflate")?new V(t,e,n):void 0}(n,e,t.config);},append:async t=>({data:await O.append(t.data)}),flush:()=>O.flush()};let O;addEventListener("message",(async t=>{const e=t.data,n=e.type,i=j[n];if(i)try{e.data&&(e.data=new Uint8Array(e.data));const t=await i(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data]);}catch(e){postMessage(t);}else postMessage(t);}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}});}}));function P(t){return K(t.map((([t,e])=>new Array(t).fill(e,0,t))))}function K(t){return t.reduce(((t,e)=>t.concat(Array.isArray(e)?K(e):e)),[])}const G=[0,1,2,3].concat(...P([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function W(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1;}while(--e>0);return n>>>1}t.build_tree=function(n){const i=t.dyn_tree,a=t.stat_desc.static_tree,r=t.stat_desc.elems;let s,o,l,_=-1;for(n.heap_len=0,n.heap_max=573,s=0;s<r;s++)0!==i[2*s]?(n.heap[++n.heap_len]=_=s,n.depth[s]=0):i[2*s+1]=0;for(;n.heap_len<2;)l=n.heap[++n.heap_len]=_<2?++_:0,i[2*l]=1,n.depth[l]=0,n.opt_len--,a&&(n.static_len-=a[2*l+1]);for(t.max_code=_,s=Math.floor(n.heap_len/2);s>=1;s--)n.pqdownheap(i,s);l=r;do{s=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(i,1),o=n.heap[1],n.heap[--n.heap_max]=s,n.heap[--n.heap_max]=o,i[2*l]=i[2*s]+i[2*o],n.depth[l]=Math.max(n.depth[s],n.depth[o])+1,i[2*s+1]=i[2*o+1]=l,n.heap[1]=l++,n.pqdownheap(i,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(e){const n=t.dyn_tree,i=t.stat_desc.static_tree,a=t.stat_desc.extra_bits,r=t.stat_desc.extra_base,s=t.stat_desc.max_length;let o,l,_,d,c,f,u=0;for(d=0;d<=15;d++)e.bl_count[d]=0;for(n[2*e.heap[e.heap_max]+1]=0,o=e.heap_max+1;o<573;o++)l=e.heap[o],d=n[2*n[2*l+1]+1]+1,d>s&&(d=s,u++),n[2*l+1]=d,l>t.max_code||(e.bl_count[d]++,c=0,l>=r&&(c=a[l-r]),f=n[2*l],e.opt_len+=f*(d+c),i&&(e.static_len+=f*(i[2*l+1]+c)));if(0!==u){do{for(d=s-1;0===e.bl_count[d];)d--;e.bl_count[d]--,e.bl_count[d+1]+=2,e.bl_count[s]--,u-=2;}while(u>0);for(d=s;0!==d;d--)for(l=e.bl_count[d];0!==l;)_=e.heap[--o],_>t.max_code||(n[2*_+1]!=d&&(e.opt_len+=(d-n[2*_+1])*n[2*_],n[2*_+1]=d),l--);}}(n),function(t,n,i){const a=[];let r,s,o,l=0;for(r=1;r<=15;r++)a[r]=l=l+i[r-1]<<1;for(s=0;s<=n;s++)o=t[2*s+1],0!==o&&(t[2*s]=e(a[o]++,o));}(i,t.max_code,n.bl_count);};}function L(t,e,n,i,a){const r=this;r.static_tree=t,r.extra_bits=e,r.extra_base=n,r.elems=i,r.max_length=a;}W._length_code=[0,1,2,3,4,5,6,7].concat(...P([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),W.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],W.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],W.d_code=function(t){return t<256?G[t]:G[256+(t>>>7)]},W.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],W.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],W.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],W.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],L.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],L.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],L.static_l_desc=new L(L.static_ltree,W.extra_lbits,257,286,15),L.static_d_desc=new L(L.static_dtree,W.extra_dbits,0,30,15),L.static_bl_desc=new L(null,W.extra_blbits,0,19,7);function T(t,e,n,i,a){const r=this;r.good_length=t,r.max_lazy=e,r.nice_length=n,r.max_chain=i,r.func=a;}const q=[new T(0,0,0,0,0),new T(4,4,8,4,1),new T(4,5,16,8,1),new T(4,6,32,32,1),new T(4,4,16,16,2),new T(8,16,32,32,2),new T(8,16,128,128,2),new T(8,32,128,256,2),new T(32,128,258,1024,2),new T(32,258,258,4096,2)],R=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function F(t,e,n,i){const a=t[2*e],r=t[2*n];return a<r||a==r&&i[e]<=i[n]}function J(){const t=this;let e,n,i,a,r,s,o,l,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v,A,U,S,z,I,E,C,M,B,H;const V=new W,D=new W,j=new W;let O,P,K,G,T,J,N,Q;function X(){let e;for(e=0;e<286;e++)M[2*e]=0;for(e=0;e<30;e++)B[2*e]=0;for(e=0;e<19;e++)H[2*e]=0;M[512]=1,t.opt_len=t.static_len=0,K=T=0;}function Y(t,e){let n,i=-1,a=t[1],r=0,s=7,o=4;0===a&&(s=138,o=3),t[2*(e+1)+1]=65535;for(let l=0;l<=e;l++)n=a,a=t[2*(l+1)+1],++r<s&&n==a||(r<o?H[2*n]+=r:0!==n?(n!=i&&H[2*n]++,H[32]++):r<=10?H[34]++:H[36]++,r=0,i=n,0===a?(s=138,o=3):n==a?(s=6,o=3):(s=7,o=4));}function Z(e){t.pending_buf[t.pending++]=e;}function $(t){Z(255&t),Z(t>>>8&255);}function tt(t,e){let n;const i=e;Q>16-i?(n=t,N|=n<<Q&65535,$(N),N=n>>>16-Q,Q+=i-16):(N|=t<<Q&65535,Q+=i);}function et(t,e){const n=2*t;tt(65535&e[n],65535&e[n+1]);}function nt(t,e){let n,i,a=-1,r=t[1],s=0,o=7,l=4;for(0===r&&(o=138,l=3),n=0;n<=e;n++)if(i=r,r=t[2*(n+1)+1],!(++s<o&&i==r)){if(s<l)do{et(i,H);}while(0!=--s);else 0!==i?(i!=a&&(et(i,H),s--),et(16,H),tt(s-3,2)):s<=10?(et(17,H),tt(s-3,3)):(et(18,H),tt(s-11,7));s=0,a=i,0===r?(o=138,l=3):i==r?(o=6,l=3):(o=7,l=4);}}function it(){16==Q?($(N),N=0,Q=0):Q>=8&&(Z(255&N),N>>>=8,Q-=8);}function at(e,n){let i,a,r;if(t.pending_buf[G+2*K]=e>>>8&255,t.pending_buf[G+2*K+1]=255&e,t.pending_buf[O+K]=255&n,K++,0===e?M[2*n]++:(T++,e--,M[2*(W._length_code[n]+256+1)]++,B[2*W.d_code(e)]++),0==(8191&K)&&z>2){for(i=8*K,a=m-p,r=0;r<30;r++)i+=B[2*r]*(5+W.extra_dbits[r]);if(i>>>=3,T<Math.floor(K/2)&&i<Math.floor(a/2))return !0}return K==P-1}function rt(e,n){let i,a,r,s,o=0;if(0!==K)do{i=t.pending_buf[G+2*o]<<8&65280|255&t.pending_buf[G+2*o+1],a=255&t.pending_buf[O+o],o++,0===i?et(a,e):(r=W._length_code[a],et(r+256+1,e),s=W.extra_lbits[r],0!==s&&(a-=W.base_length[r],tt(a,s)),i--,r=W.d_code(i),et(r,n),s=W.extra_dbits[r],0!==s&&(i-=W.base_dist[r],tt(i,s)));}while(o<K);et(256,e),J=e[513];}function st(){Q>8?$(N):Q>0&&Z(255&N),N=0,Q=0;}function ot(e,n,i){tt(0+(i?1:0),3),function(e,n,i){st(),J=8,i&&($(n),$(~n)),t.pending_buf.set(l.subarray(e,e+n),t.pending),t.pending+=n;}(e,n,!0);}function lt(e,n,i){let a,r,s=0;z>0?(V.build_tree(t),D.build_tree(t),s=function(){let e;for(Y(M,V.max_code),Y(B,D.max_code),j.build_tree(t),e=18;e>=3&&0===H[2*W.bl_order[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(),a=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=a&&(a=r)):a=r=n+5,n+4<=a&&-1!=e?ot(e,n,i):r==a?(tt(2+(i?1:0),3),rt(L.static_ltree,L.static_dtree)):(tt(4+(i?1:0),3),function(t,e,n){let i;for(tt(t-257,5),tt(e-1,5),tt(n-4,4),i=0;i<n;i++)tt(H[2*W.bl_order[i]+1],3);nt(M,t-1),nt(B,e-1);}(V.max_code+1,D.max_code+1,s+1),rt(M,B)),X(),i&&st();}function _t(t){lt(p>=0?p:-1,m-p,t),p=m,e.flush_pending();}function dt(){let t,n,i,a;do{if(a=_-v-m,0===a&&0===m&&0===v)a=r;else if(-1==a)a--;else if(m>=r+r-262){l.set(l.subarray(r,r+r),0),k-=r,m-=r,p-=r,t=u,i=t;do{n=65535&c[--i],c[i]=n>=r?n-r:0;}while(0!=--t);t=r,i=t;do{n=65535&d[--i],d[i]=n>=r?n-r:0;}while(0!=--t);a+=r;}if(0===e.avail_in)return;t=e.read_buf(l,m+v,a),v+=t,v>=3&&(f=255&l[m],f=(f<<w^255&l[m+1])&b);}while(v<262&&0!==e.avail_in)}function ct(t){let e,n,i=U,a=m,s=A;const _=m>r-262?m-(r-262):0;let c=C;const f=o,u=m+258;let h=l[a+s-1],b=l[a+s];A>=E&&(i>>=2),c>v&&(c=v);do{if(e=t,l[e+s]==b&&l[e+s-1]==h&&l[e]==l[a]&&l[++e]==l[a+1]){a+=2,e++;do{}while(l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&a<u);if(n=258-(u-a),a=u-258,n>s){if(k=t,s=n,n>=c)break;h=l[a+s-1],b=l[a+s];}}}while((t=65535&d[t&f])>_&&0!=--i);return s<=v?s:v}function ft(e){return e.total_in=e.total_out=0,e.msg=null,t.pending=0,t.pending_out=0,n=113,a=0,V.dyn_tree=M,V.stat_desc=L.static_l_desc,D.dyn_tree=B,D.stat_desc=L.static_d_desc,j.dyn_tree=H,j.stat_desc=L.static_bl_desc,N=0,Q=0,J=8,X(),function(){_=2*r,c[u-1]=0;for(let t=0;t<u-1;t++)c[t]=0;S=q[z].max_lazy,E=q[z].good_length,C=q[z].nice_length,U=q[z].max_chain,m=0,p=0,v=0,x=A=2,y=0,f=0;}(),0}t.depth=[],t.bl_count=[],t.heap=[],M=[],B=[],H=[],t.pqdownheap=function(e,n){const i=t.heap,a=i[n];let r=n<<1;for(;r<=t.heap_len&&(r<t.heap_len&&F(e,i[r+1],i[r],t.depth)&&r++,!F(e,a,i[r],t.depth));)i[n]=i[r],n=r,r<<=1;i[n]=a;},t.deflateInit=function(e,n,a,_,f,p){return _||(_=8),f||(f=8),p||(p=0),e.msg=null,-1==n&&(n=6),f<1||f>9||8!=_||a<9||a>15||n<0||n>9||p<0||p>2?-2:(e.dstate=t,s=a,r=1<<s,o=r-1,h=f+7,u=1<<h,b=u-1,w=Math.floor((h+3-1)/3),l=new Uint8Array(2*r),d=[],c=[],P=1<<f+6,t.pending_buf=new Uint8Array(4*P),i=4*P,G=Math.floor(P/2),O=3*P,z=n,I=p,ft(e))},t.deflateEnd=function(){return 42!=n&&113!=n&&666!=n?-2:(t.pending_buf=null,c=null,d=null,l=null,t.dstate=null,113==n?-3:0)},t.deflateParams=function(t,e,n){let i=0;return -1==e&&(e=6),e<0||e>9||n<0||n>2?-2:(q[z].func!=q[e].func&&0!==t.total_in&&(i=t.deflate(1)),z!=e&&(z=e,S=q[z].max_lazy,E=q[z].good_length,C=q[z].nice_length,U=q[z].max_chain),I=n,i)},t.deflateSetDictionary=function(t,e,i){let a,s=i,_=0;if(!e||42!=n)return -2;if(s<3)return 0;for(s>r-262&&(s=r-262,_=i-s),l.set(e.subarray(_,_+s),0),m=s,p=s,f=255&l[0],f=(f<<w^255&l[1])&b,a=0;a<=s-3;a++)f=(f<<w^255&l[a+2])&b,d[a&o]=c[f],c[f]=a;return 0},t.deflate=function(_,h){let U,E,C,M,B;if(h>4||h<0)return -2;if(!_.next_out||!_.next_in&&0!==_.avail_in||666==n&&4!=h)return _.msg=R[4],-2;if(0===_.avail_out)return _.msg=R[7],-5;var H;if(e=_,M=a,a=h,42==n&&(E=8+(s-8<<4)<<8,C=(z-1&255)>>1,C>3&&(C=3),E|=C<<6,0!==m&&(E|=32),E+=31-E%31,n=113,Z((H=E)>>8&255),Z(255&H)),0!==t.pending){if(e.flush_pending(),0===e.avail_out)return a=-1,0}else if(0===e.avail_in&&h<=M&&4!=h)return e.msg=R[7],-5;if(666==n&&0!==e.avail_in)return _.msg=R[7],-5;if(0!==e.avail_in||0!==v||0!=h&&666!=n){switch(B=-1,q[z].func){case 0:B=function(t){let n,a=65535;for(a>i-5&&(a=i-5);;){if(v<=1){if(dt(),0===v&&0==t)return 0;if(0===v)break}if(m+=v,v=0,n=p+a,(0===m||m>=n)&&(v=m-n,m=n,_t(!1),0===e.avail_out))return 0;if(m-p>=r-262&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 1:B=function(t){let n,i=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m),0!==i&&(m-i&65535)<=r-262&&2!=I&&(x=ct(i)),x>=3)if(n=at(m-k,x-3),v-=x,x<=S&&v>=3){x--;do{m++,f=(f<<w^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m;}while(0!=--x);m++;}else m+=x,x=0,f=255&l[m],f=(f<<w^255&l[m+1])&b;else n=at(0,255&l[m]),v--,m++;if(n&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 2:B=function(t){let n,i,a=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m),A=x,g=k,x=2,0!==a&&A<S&&(m-a&65535)<=r-262&&(2!=I&&(x=ct(a)),x<=5&&(1==I||3==x&&m-k>4096)&&(x=2)),A>=3&&x<=A){i=m+v-3,n=at(m-1-g,A-3),v-=A-1,A-=2;do{++m<=i&&(f=(f<<w^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m);}while(0!=--A);if(y=0,x=2,m++,n&&(_t(!1),0===e.avail_out))return 0}else if(0!==y){if(n=at(0,255&l[m-1]),n&&_t(!1),m++,v--,0===e.avail_out)return 0}else y=1,m++,v--;}return 0!==y&&(n=at(0,255&l[m-1]),y=0),_t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);}if(2!=B&&3!=B||(n=666),0==B||2==B)return 0===e.avail_out&&(a=-1),0;if(1==B){if(1==h)tt(2,3),et(256,L.static_ltree),it(),1+J+10-Q<9&&(tt(2,3),et(256,L.static_ltree),it()),J=7;else if(ot(0,0,!1),3==h)for(U=0;U<u;U++)c[U]=0;if(e.flush_pending(),0===e.avail_out)return a=-1,0}}return 4!=h?0:1};}function N(){const t=this;t.next_in_index=0,t.next_out_index=0,t.avail_in=0,t.total_in=0,t.avail_out=0,t.total_out=0;}function Q(t){const e=new N,n=(i=t&&t.chunkSize?t.chunkSize:65536)+5*(Math.floor(i/16383)+1);var i;const a=new Uint8Array(n);let r=t?t.level:-1;void 0===r&&(r=-1),e.deflateInit(r),e.next_out=a,this.append=function(t,i){let r,s,o=0,l=0,_=0;const d=[];if(t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,r=e.deflate(0),0!=r)throw new Error("deflating: "+e.msg);e.next_out_index&&(e.next_out_index==n?d.push(new Uint8Array(a)):d.push(a.slice(0,e.next_out_index))),_+=e.next_out_index,i&&e.next_in_index>0&&e.next_in_index!=o&&(i(e.next_in_index),o=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return d.length>1?(s=new Uint8Array(_),d.forEach((function(t){s.set(t,l),l+=t.length;}))):s=d[0]||new Uint8Array(0),s}},this.flush=function(){let t,i,r=0,s=0;const o=[];do{if(e.next_out_index=0,e.avail_out=n,t=e.deflate(4),1!=t&&0!=t)throw new Error("deflating: "+e.msg);n-e.avail_out>0&&o.push(a.slice(0,e.next_out_index)),s+=e.next_out_index;}while(e.avail_in>0||0===e.avail_out);return e.deflateEnd(),i=new Uint8Array(s),o.forEach((function(t){i.set(t,r),r+=t.length;})),i};}N.prototype={deflateInit:function(t,e){const n=this;return n.dstate=new J,e||(e=15),n.dstate.deflateInit(n,t,e)},deflate:function(t){const e=this;return e.dstate?e.dstate.deflate(e,t):-2},deflateEnd:function(){const t=this;if(!t.dstate)return -2;const e=t.dstate.deflateEnd();return t.dstate=null,e},deflateParams:function(t,e){const n=this;return n.dstate?n.dstate.deflateParams(n,t,e):-2},deflateSetDictionary:function(t,e){const n=this;return n.dstate?n.dstate.deflateSetDictionary(n,t,e):-2},read_buf:function(t,e,n){const i=this;let a=i.avail_in;return a>n&&(a=n),0===a?0:(i.avail_in-=a,t.set(i.next_in.subarray(i.next_in_index,i.next_in_index+a),e),i.next_in_index+=a,i.total_in+=a,a)},flush_pending:function(){const t=this;let e=t.dstate.pending;e>t.avail_out&&(e=t.avail_out),0!==e&&(t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out,t.dstate.pending_out+e),t.next_out_index),t.next_out_index+=e,t.dstate.pending_out+=e,t.total_out+=e,t.avail_out-=e,t.dstate.pending-=e,0===t.dstate.pending&&(t.dstate.pending_out=0));}};const X=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],Y=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],Z=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],$=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],tt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],et=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],nt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function it(){let t,e,n,i,a,r;function s(t,e,s,o,l,_,d,c,f,u,h){let b,w,p,x,g,y,m,k,v,A,U,S,z,I,E;A=0,g=s;do{n[t[e+A]]++,A++,g--;}while(0!==g);if(n[0]==s)return d[0]=-1,c[0]=0,0;for(k=c[0],y=1;y<=15&&0===n[y];y++);for(m=y,k<y&&(k=y),g=15;0!==g&&0===n[g];g--);for(p=g,k>g&&(k=g),c[0]=k,I=1<<y;y<g;y++,I<<=1)if((I-=n[y])<0)return -3;if((I-=n[g])<0)return -3;for(n[g]+=I,r[1]=y=0,A=1,z=2;0!=--g;)r[z]=y+=n[A],z++,A++;g=0,A=0;do{0!==(y=t[e+A])&&(h[r[y]++]=g),A++;}while(++g<s);for(s=r[p],r[0]=g=0,A=0,x=-1,S=-k,a[0]=0,U=0,E=0;m<=p;m++)for(b=n[m];0!=b--;){for(;m>S+k;){if(x++,S+=k,E=p-S,E=E>k?k:E,(w=1<<(y=m-S))>b+1&&(w-=b+1,z=m,y<E))for(;++y<E&&!((w<<=1)<=n[++z]);)w-=n[z];if(E=1<<y,u[0]+E>1440)return -3;a[x]=U=u[0],u[0]+=E,0!==x?(r[x]=g,i[0]=y,i[1]=k,y=g>>>S-k,i[2]=U-a[x-1]-y,f.set(i,3*(a[x-1]+y))):d[0]=U;}for(i[1]=m-S,A>=s?i[0]=192:h[A]<o?(i[0]=h[A]<256?0:96,i[2]=h[A++]):(i[0]=_[h[A]-o]+16+64,i[2]=l[h[A++]-o]),w=1<<m-S,y=g>>>S;y<E;y+=w)f.set(i,3*(U+y));for(y=1<<m-1;0!=(g&y);y>>>=1)g^=y;for(g^=y,v=(1<<S)-1;(g&v)!=r[x];)x--,S-=k,v=(1<<S)-1;}return 0!==I&&1!=p?-5:0}function o(s){let o;for(t||(t=[],e=[],n=new Int32Array(16),i=[],a=new Int32Array(15),r=new Int32Array(16)),e.length<s&&(e=[]),o=0;o<s;o++)e[o]=0;for(o=0;o<16;o++)n[o]=0;for(o=0;o<3;o++)i[o]=0;a.set(n.subarray(0,15),0),r.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,a,r,l){let _;return o(19),t[0]=0,_=s(n,0,19,19,null,null,a,i,r,t,e),-3==_?l.msg="oversubscribed dynamic bit lengths tree":-5!=_&&0!==i[0]||(l.msg="incomplete dynamic bit lengths tree",_=-3),_},this.inflate_trees_dynamic=function(n,i,a,r,l,_,d,c,f){let u;return o(288),t[0]=0,u=s(a,0,n,257,$,tt,_,r,c,t,e),0!=u||0===r[0]?(-3==u?f.msg="oversubscribed literal/length tree":-4!=u&&(f.msg="incomplete literal/length tree",u=-3),u):(o(288),u=s(a,n,i,0,et,nt,d,l,c,t,e),0!=u||0===l[0]&&n>257?(-3==u?f.msg="oversubscribed distance tree":-5==u?(f.msg="incomplete distance tree",u=-3):-4!=u&&(f.msg="empty distance tree with lengths",u=-3),u):0)};}it.inflate_trees_fixed=function(t,e,n,i){return t[0]=9,e[0]=5,n[0]=Y,i[0]=Z,0};function at(){const t=this;let e,n,i,a,r=0,s=0,o=0,l=0,_=0,d=0,c=0,f=0,u=0,h=0;function b(t,e,n,i,a,r,s,o){let l,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v;h=o.next_in_index,b=o.avail_in,f=s.bitb,u=s.bitk,w=s.write,p=w<s.read?s.read-w-1:s.end-w,x=X[t],g=X[e];do{for(;u<20;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(l=f&x,_=n,d=i,v=3*(d+l),0!==(c=_[v]))for(;;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15,y=_[v+2]+(f&X[c]),f>>=c,u-=c;u<15;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;for(l=f&g,_=a,d=r,v=3*(d+l),c=_[v];;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15;u<c;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(m=_[v+2]+(f&X[c]),f>>=c,u-=c,p-=y,w>=m)k=w-m,w-k>0&&2>w-k?(s.window[w++]=s.window[k++],s.window[w++]=s.window[k++],y-=2):(s.window.set(s.window.subarray(k,k+2),w),w+=2,k+=2,y-=2);else {k=w-m;do{k+=s.end;}while(k<0);if(c=s.end-k,y>c){if(y-=c,w-k>0&&c>w-k)do{s.window[w++]=s.window[k++];}while(0!=--c);else s.window.set(s.window.subarray(k,k+c),w),w+=c,k+=c,c=0;k=0;}}if(w-k>0&&y>w-k)do{s.window[w++]=s.window[k++];}while(0!=--y);else s.window.set(s.window.subarray(k,k+y),w),w+=y,k+=y,y=0;break}if(0!=(64&c))return o.msg="invalid distance code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,-3;l+=_[v+2],l+=f&X[c],v=3*(d+l),c=_[v];}break}if(0!=(64&c))return 0!=(32&c)?(y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,1):(o.msg="invalid literal/length code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,-3);if(l+=_[v+2],l+=f&X[c],v=3*(d+l),0===(c=_[v])){f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;break}}else f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;}while(p>=258&&b>=10);return y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=w,0}t.init=function(t,r,s,o,l,_){e=0,c=t,f=r,i=s,u=o,a=l,h=_,n=null;},t.proc=function(t,w,p){let x,g,y,m,k,v,A,U=0,S=0,z=0;for(z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k;;)switch(e){case 0:if(v>=258&&m>=10&&(t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,p=b(c,f,i,u,a,h,t,w),z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k,0!=p)){e=1==p?7:9;break}o=c,n=i,s=u,e=1;case 1:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>>=n[g+1],S-=n[g+1],y=n[g],0===y){l=n[g+2],e=6;break}if(0!=(16&y)){_=15&y,r=n[g+2],e=2;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}if(0!=(32&y)){e=7;break}return e=9,w.msg="invalid literal/length code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 2:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}r+=U&X[x],U>>=x,S-=x,o=f,n=a,s=h,e=3;case 3:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>=n[g+1],S-=n[g+1],y=n[g],0!=(16&y)){_=15&y,d=n[g+2],e=4;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}return e=9,w.msg="invalid distance code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 4:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}d+=U&X[x],U>>=x,S-=x,e=5;case 5:for(A=k-d;A<0;)A+=t.end;for(;0!==r;){if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);t.window[k++]=t.window[A++],v--,A==t.end&&(A=0),r--;}e=0;break;case 6:if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,t.window[k++]=l,v--,e=0;break;case 7:if(S>7&&(S-=8,m++,z--),t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,t.read!=t.write)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);e=8;case 8:return p=1,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 9:return p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);default:return p=-2,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p)}},t.free=function(){};}const rt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function st(t,e){const n=this;let i,a=0,r=0,s=0,o=0;const l=[0],_=[0],d=new at;let c=0,f=new Int32Array(4320);const u=new it;n.bitk=0,n.bitb=0,n.window=new Uint8Array(e),n.end=e,n.read=0,n.write=0,n.reset=function(t,e){e&&(e[0]=0),6==a&&d.free(t),a=0,n.bitk=0,n.bitb=0,n.read=n.write=0;},n.reset(t,null),n.inflate_flush=function(t,e){let i,a,r;return a=t.next_out_index,r=n.read,i=(r<=n.write?n.write:n.end)-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i,r==n.end&&(r=0,n.write==n.end&&(n.write=0),i=n.write-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i),t.next_out_index=a,n.read=r,e},n.proc=function(t,e){let h,b,w,p,x,g,y,m;for(p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g;;){let k,v,A,U,S,z,I,E;switch(a){case 0:for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}switch(h=7&b,c=1&h,h>>>1){case 0:b>>>=3,w-=3,h=7&w,b>>>=h,w-=h,a=1;break;case 1:k=[],v=[],A=[[]],U=[[]],it.inflate_trees_fixed(k,v,A,U),d.init(k[0],v[0],A[0],0,U[0],0),b>>>=3,w-=3,a=6;break;case 2:b>>>=3,w-=3,a=3;break;case 3:return b>>>=3,w-=3,a=9,t.msg="invalid block type",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}break;case 1:for(;w<32;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if((~b>>>16&65535)!=(65535&b))return a=9,t.msg="invalid stored block lengths",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);r=65535&b,b=w=0,a=0!==r?2:0!==c?7:0;break;case 2:if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(0===y&&(g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y&&(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y)))return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(e=0,h=r,h>x&&(h=x),h>y&&(h=y),n.window.set(t.read_buf(p,h),g),p+=h,x-=h,g+=h,y-=h,0!=(r-=h))break;a=0!==c?7:0;break;case 3:for(;w<14;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(s=h=16383&b,(31&h)>29||(h>>5&31)>29)return a=9,t.msg="too many length or distance symbols",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(h=258+(31&h)+(h>>5&31),!i||i.length<h)i=[];else for(m=0;m<h;m++)i[m]=0;b>>>=14,w-=14,o=0,a=4;case 4:for(;o<4+(s>>>10);){for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}i[rt[o++]]=7&b,b>>>=3,w-=3;}for(;o<19;)i[rt[o++]]=0;if(l[0]=7,h=u.inflate_trees_bits(i,l,_,f,t),0!=h)return -3==(e=h)&&(i=null,a=9),n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);o=0,a=5;case 5:for(;h=s,!(o>=258+(31&h)+(h>>5&31));){let r,d;for(h=l[0];w<h;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(h=f[3*(_[0]+(b&X[h]))+1],d=f[3*(_[0]+(b&X[h]))+2],d<16)b>>>=h,w-=h,i[o++]=d;else {for(m=18==d?7:d-14,r=18==d?11:3;w<h+m;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(b>>>=h,w-=h,r+=b&X[m],b>>>=m,w-=m,m=o,h=s,m+r>258+(31&h)+(h>>5&31)||16==d&&m<1)return i=null,a=9,t.msg="invalid bit length repeat",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d=16==d?i[m-1]:0;do{i[m++]=d;}while(0!=--r);o=m;}}if(_[0]=-1,S=[],z=[],I=[],E=[],S[0]=9,z[0]=6,h=s,h=u.inflate_trees_dynamic(257+(31&h),1+(h>>5&31),i,S,z,I,E,f,t),0!=h)return -3==h&&(i=null,a=9),e=h,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d.init(S[0],z[0],f,I[0],f,E[0]),a=6;case 6:if(n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,1!=(e=d.proc(n,t,e)))return n.inflate_flush(t,e);if(e=0,d.free(t),p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g,0===c){a=0;break}a=7;case 7:if(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);a=8;case 8:return e=1,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);case 9:return e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);default:return e=-2,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}}},n.free=function(t){n.reset(t,null),n.window=null,f=null;},n.set_dictionary=function(t,e,i){n.window.set(t.subarray(e,e+i),0),n.read=n.write=i;},n.sync_point=function(){return 1==a?1:0};}const ot=[0,0,255,255];function lt(){const t=this;function e(t){return t&&t.istate?(t.total_in=t.total_out=0,t.msg=null,t.istate.mode=7,t.istate.blocks.reset(t,null),0):-2}t.mode=0,t.method=0,t.was=[0],t.need=0,t.marker=0,t.wbits=0,t.inflateEnd=function(e){return t.blocks&&t.blocks.free(e),t.blocks=null,0},t.inflateInit=function(n,i){return n.msg=null,t.blocks=null,i<8||i>15?(t.inflateEnd(n),-2):(t.wbits=i,n.istate.blocks=new st(n,1<<i),e(n),0)},t.inflate=function(t,e){let n,i;if(!t||!t.istate||!t.next_in)return -2;const a=t.istate;for(e=4==e?-5:0,n=-5;;)switch(a.mode){case 0:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,8!=(15&(a.method=t.read_byte(t.next_in_index++)))){a.mode=13,t.msg="unknown compression method",a.marker=5;break}if(8+(a.method>>4)>a.wbits){a.mode=13,t.msg="invalid window size",a.marker=5;break}a.mode=1;case 1:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,i=255&t.read_byte(t.next_in_index++),((a.method<<8)+i)%31!=0){a.mode=13,t.msg="incorrect header check",a.marker=5;break}if(0==(32&i)){a.mode=7;break}a.mode=2;case 2:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need=(255&t.read_byte(t.next_in_index++))<<24&4278190080,a.mode=3;case 3:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<16&16711680,a.mode=4;case 4:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<8&65280,a.mode=5;case 5:return 0===t.avail_in?n:(n=e,t.avail_in--,t.total_in++,a.need+=255&t.read_byte(t.next_in_index++),a.mode=6,2);case 6:return a.mode=13,t.msg="need dictionary",a.marker=0,-2;case 7:if(n=a.blocks.proc(t,n),-3==n){a.mode=13,a.marker=0;break}if(0==n&&(n=e),1!=n)return n;n=e,a.blocks.reset(t,a.was),a.mode=12;case 12:return 1;case 13:return -3;default:return -2}},t.inflateSetDictionary=function(t,e,n){let i=0,a=n;if(!t||!t.istate||6!=t.istate.mode)return -2;const r=t.istate;return a>=1<<r.wbits&&(a=(1<<r.wbits)-1,i=n-a),r.blocks.set_dictionary(e,i,a),r.mode=7,0},t.inflateSync=function(t){let n,i,a,r,s;if(!t||!t.istate)return -2;const o=t.istate;if(13!=o.mode&&(o.mode=13,o.marker=0),0===(n=t.avail_in))return -5;for(i=t.next_in_index,a=o.marker;0!==n&&a<4;)t.read_byte(i)==ot[a]?a++:a=0!==t.read_byte(i)?0:4-a,i++,n--;return t.total_in+=i-t.next_in_index,t.next_in_index=i,t.avail_in=n,o.marker=a,4!=a?-3:(r=t.total_in,s=t.total_out,e(t),t.total_in=r,t.total_out=s,o.mode=7,0)},t.inflateSyncPoint=function(t){return t&&t.istate&&t.istate.blocks?t.istate.blocks.sync_point():-2};}function _t(){}function dt(t){const e=new _t,n=t&&t.chunkSize?Math.floor(2*t.chunkSize):131072,i=new Uint8Array(n);let a=!1;e.inflateInit(),e.next_out=i,this.append=function(t,r){const s=[];let o,l,_=0,d=0,c=0;if(0!==t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,0!==e.avail_in||a||(e.next_in_index=0,a=!0),o=e.inflate(0),a&&-5===o){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==o&&1!==o)throw new Error("inflating: "+e.msg);if((a||1===o)&&e.avail_in===t.length)throw new Error("inflating: bad input");e.next_out_index&&(e.next_out_index===n?s.push(new Uint8Array(i)):s.push(i.slice(0,e.next_out_index))),c+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=_&&(r(e.next_in_index),_=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return s.length>1?(l=new Uint8Array(c),s.forEach((function(t){l.set(t,d),d+=t.length;}))):l=s[0]||new Uint8Array(0),l}},this.flush=function(){e.inflateEnd();};}_t.prototype={inflateInit:function(t){const e=this;return e.istate=new lt,t||(t=15),e.istate.inflateInit(e,t)},inflate:function(t){const e=this;return e.istate?e.istate.inflate(e,t):-2},inflateEnd:function(){const t=this;if(!t.istate)return -2;const e=t.istate.inflateEnd(t);return t.istate=null,e},inflateSync:function(){const t=this;return t.istate?t.istate.inflateSync(t):-2},inflateSetDictionary:function(t,e){const n=this;return n.istate?n.istate.inflateSetDictionary(n,t,e):-2},read_byte:function(t){return this.next_in[t]},read_buf:function(t,e){return this.next_in.subarray(t,t+e)}},self.initCodec=()=>{self.Deflate=Q,self.Inflate=dt;};\n\n\t\t', n = URL.createObjectURL(new Blob([
            e
        ], {
            type: "text/javascript"
        }));
        configure({
            workerScripts: {
                inflate: [
                    n
                ],
                deflate: [
                    n
                ]
            }
        });
    }
};
"use strict";
"use strict";
"use strict";
class Stream1 {
    constructor(){
        this.size = 0;
    }
    init() {
        this.initialized = true;
    }
}
class Reader extends Stream1 {
}
class Writer extends Stream1 {
    writeUint8Array(array) {
        this.size += array.length;
    }
}
class BlobReader extends Reader {
    constructor(blob){
        super();
        this.blob = blob;
        this.size = blob.size;
    }
    async readUint8Array(offset, length) {
        const reader = new FileReader();
        return new Promise((resolve, reject)=>{
            reader.onload = (event)=>resolve(new Uint8Array(event.target.result));
            reader.onerror = ()=>reject(reader.error);
            reader.readAsArrayBuffer(this.blob.slice(offset, offset + length));
        });
    }
}
class BlobWriter extends Writer {
    constructor(contentType){
        super();
        this.contentType = contentType;
        this.arrayBuffers = [];
    }
    async writeUint8Array(array) {
        super.writeUint8Array(array);
        this.arrayBuffers.push(array.buffer);
    }
    getData() {
        if (!this.blob) {
            this.blob = new Blob(this.arrayBuffers, {
                type: this.contentType
            });
        }
        return this.blob;
    }
}
"use strict";
const MAX_32_BITS = 0xffffffff;
const MAX_16_BITS = 0xffff;
const COMPRESSION_METHOD_DEFLATE = 0x08;
const COMPRESSION_METHOD_AES = 0x63;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = 22 + 20 + 56;
const BITFLAG_ENCRYPTED = 0x01;
const BITFLAG_DATA_DESCRIPTOR = 0x0008;
const VERSION_ZIP64 = 0x2D;
const VERSION_AES = 0x33;
const DIRECTORY_SIGNATURE = "/";
const MAX_DATE = new Date(2107, 11, 31);
const MIN_DATE = new Date(1980, 0, 1);
"use strict";
const CP437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split("");
const __default8 = (stringValue)=>{
    let result = "";
    for(let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++){
        result += CP437[stringValue[indexCharacter]];
    }
    return result;
};
"use strict";
const ERR_ABORT = "Abort error";
async function processData(codec, reader, writer, offset, inputLength, config, options) {
    const chunkSize = Math.max(config.chunkSize, 64);
    return processChunk();
    async function processChunk(chunkOffset = 0, outputLength = 0) {
        const signal = options.signal;
        if (chunkOffset < inputLength) {
            testAborted(signal, codec);
            const inputData = await reader.readUint8Array(chunkOffset + offset, Math.min(chunkSize, inputLength - chunkOffset));
            const chunkLength = inputData.length;
            testAborted(signal, codec);
            const data = await codec.append(inputData);
            testAborted(signal, codec);
            outputLength += await writeData(writer, data);
            if (options.onprogress) {
                try {
                    options.onprogress(chunkOffset + chunkLength, inputLength);
                } catch (error) {}
            }
            return processChunk(chunkOffset + chunkSize, outputLength);
        } else {
            const result = await codec.flush();
            outputLength += await writeData(writer, result.data);
            return {
                signature: result.signature,
                length: outputLength
            };
        }
    }
}
function testAborted(signal, codec) {
    if (signal && signal.aborted) {
        codec.flush();
        throw new Error(ERR_ABORT);
    }
}
async function writeData(writer, data) {
    if (data.length) {
        await writer.writeUint8Array(data);
    }
    return data.length;
}
"use strict";
const PROPERTY_NAMES = [
    "filename",
    "rawFilename",
    "directory",
    "encrypted",
    "compressedSize",
    "uncompressedSize",
    "lastModDate",
    "rawLastModDate",
    "comment",
    "rawComment",
    "signature",
    "extraField",
    "rawExtraField",
    "bitFlag",
    "extraFieldZip64",
    "extraFieldUnicodePath",
    "extraFieldUnicodeComment",
    "extraFieldAES",
    "filenameUTF8",
    "commentUTF8",
    "offset",
    "zip64",
    "compressionMethod",
    "extraFieldNTFS",
    "lastAccessDate",
    "creationDate",
    "extraFieldExtendedTimestamp",
    "version",
    "versionMadeBy",
    "msDosCompatible",
    "internalFileAttribute",
    "externalFileAttribute"
];
class Entry {
    constructor(data){
        PROPERTY_NAMES.forEach((name)=>this[name] = data[name]);
    }
}
"use strict";
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const CHARSET_UTF8 = "utf-8";
const ZIP64_PROPERTIES = [
    "uncompressedSize",
    "compressedSize",
    "offset"
];
class ZipReader {
    constructor(reader, options = {}){
        Object.assign(this, {
            reader,
            options,
            config: getConfiguration()
        });
    }
    async getEntries(options = {}) {
        const zipReader = this;
        const reader = zipReader.reader;
        if (!reader.initialized) {
            await reader.init();
        }
        if (reader.size < 22) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const endOfDirectoryInfo = await seekSignature(reader, 0x06054b50, reader.size, 22, 0xffff * 16);
        if (!endOfDirectoryInfo) {
            throw new Error(ERR_EOCDR_NOT_FOUND);
        }
        const endOfDirectoryView = getDataView(endOfDirectoryInfo);
        let directoryDataLength = getUint32(endOfDirectoryView, 12);
        let directoryDataOffset = getUint32(endOfDirectoryView, 16);
        let filesLength = getUint16(endOfDirectoryView, 8);
        let prependedDataLength = 0;
        if (directoryDataOffset == 0xffffffff || directoryDataLength == 0xffffffff || filesLength == 0xffff) {
            const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - 20, 20);
            const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
            if (getUint32(endOfDirectoryLocatorView, 0) != 0x07064b50) {
                throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
            }
            directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
            let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, 56);
            let endOfDirectoryView1 = getDataView(endOfDirectoryArray);
            const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - 20 - 56;
            if (getUint32(endOfDirectoryView1, 0) != 0x06064b50 && directoryDataOffset != expectedDirectoryDataOffset) {
                const originalDirectoryDataOffset = directoryDataOffset;
                directoryDataOffset = expectedDirectoryDataOffset;
                prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
                endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);
                endOfDirectoryView1 = getDataView(endOfDirectoryArray);
            }
            if (getUint32(endOfDirectoryView1, 0) != 0x06064b50) {
                throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
            }
            filesLength = getBigUint64(endOfDirectoryView1, 32);
            directoryDataLength = getBigUint64(endOfDirectoryView1, 40);
            directoryDataOffset -= directoryDataLength;
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        let offset = 0;
        let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
        let directoryView = getDataView(directoryArray);
        const expectedDirectoryDataOffset1 = endOfDirectoryInfo.offset - directoryDataLength;
        if (getUint32(directoryView, offset) != 0x02014b50 && directoryDataOffset != expectedDirectoryDataOffset1) {
            const originalDirectoryDataOffset1 = directoryDataOffset;
            directoryDataOffset = expectedDirectoryDataOffset1;
            prependedDataLength = directoryDataOffset - originalDirectoryDataOffset1;
            directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength);
            directoryView = getDataView(directoryArray);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const entries = [];
        for(let indexFile = 0; indexFile < filesLength; indexFile++){
            const fileEntry = new ZipEntry(reader, zipReader.config, zipReader.options);
            if (getUint32(directoryView, offset) != 0x02014b50) {
                throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
            }
            readCommonHeader(fileEntry, directoryView, offset + 6);
            const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
            const filenameOffset = offset + 46;
            const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
            const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
            const versionMadeBy = getUint16(directoryView, offset + 4);
            const msDosCompatible = (versionMadeBy & 0) == 0;
            Object.assign(fileEntry, {
                versionMadeBy,
                msDosCompatible,
                compressedSize: 0,
                uncompressedSize: 0,
                commentLength: getUint16(directoryView, offset + 32),
                directory: msDosCompatible && (getUint8(directoryView, offset + 38) & 0x10) == 0x10,
                offset: getUint32(directoryView, offset + 42) + prependedDataLength,
                internalFileAttribute: getUint32(directoryView, offset + 34),
                externalFileAttribute: getUint32(directoryView, offset + 38),
                rawFilename: directoryArray.subarray(filenameOffset, extraFieldOffset),
                filenameUTF8: languageEncodingFlag,
                commentUTF8: languageEncodingFlag,
                rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
            });
            const endOffset = commentOffset + fileEntry.commentLength;
            fileEntry.rawComment = directoryArray.subarray(commentOffset, endOffset);
            fileEntry.filename = decodeString(fileEntry.rawFilename, fileEntry.filenameUTF8 ? CHARSET_UTF8 : getOptionValue(zipReader, options, "filenameEncoding"));
            fileEntry.comment = decodeString(fileEntry.rawComment, fileEntry.commentUTF8 ? CHARSET_UTF8 : getOptionValue(zipReader, options, "commentEncoding"));
            if (!fileEntry.directory && fileEntry.filename.endsWith(DIRECTORY_SIGNATURE)) {
                fileEntry.directory = true;
            }
            readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
            const entry = new Entry(fileEntry);
            entry.getData = (writer, options)=>fileEntry.getData(writer, entry, options);
            entries.push(entry);
            offset = endOffset;
            if (options.onprogress) {
                try {
                    options.onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
                } catch (error) {}
            }
        }
        return entries;
    }
    async close() {}
}
class ZipEntry {
    constructor(reader, config, options){
        Object.assign(this, {
            reader,
            config,
            options
        });
    }
    async getData(writer, fileEntry, options = {}) {
        const zipEntry = this;
        const { reader , offset , extraFieldAES , compressionMethod , config , bitFlag , signature , rawLastModDate , compressedSize  } = zipEntry;
        const localDirectory = zipEntry.localDirectory = {};
        if (!reader.initialized) {
            await reader.init();
        }
        let dataArray = await readUint8Array(reader, offset, 30);
        const dataView = getDataView(dataArray);
        let password = getOptionValue(zipEntry, options, "password");
        password = password && password.length && password;
        if (extraFieldAES) {
            if (extraFieldAES.originalCompressionMethod != 0x63) {
                throw new Error(ERR_UNSUPPORTED_COMPRESSION);
            }
        }
        if (compressionMethod != 0x00 && compressionMethod != 0x08) {
            throw new Error(ERR_UNSUPPORTED_COMPRESSION);
        }
        if (getUint32(dataView, 0) != 0x04034b50) {
            throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
        }
        readCommonHeader(localDirectory, dataView, 4);
        dataArray = await readUint8Array(reader, offset, 30 + localDirectory.filenameLength + localDirectory.extraFieldLength);
        localDirectory.rawExtraField = dataArray.subarray(30 + localDirectory.filenameLength);
        readCommonFooter(zipEntry, localDirectory, dataView, 4);
        fileEntry.lastAccessDate = localDirectory.lastAccessDate;
        fileEntry.creationDate = localDirectory.creationDate;
        const encrypted = zipEntry.encrypted && localDirectory.encrypted;
        const zipCrypto = encrypted && !extraFieldAES;
        if (encrypted) {
            if (!zipCrypto && extraFieldAES.strength === undefined) {
                throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
            } else if (!password) {
                throw new Error(ERR_ENCRYPTED);
            }
        }
        const codec = await createCodec1(config.Inflate, {
            codecType: CODEC_INFLATE,
            password,
            zipCrypto,
            encryptionStrength: extraFieldAES && extraFieldAES.strength,
            signed: getOptionValue(zipEntry, options, "checkSignature"),
            passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 0xFF : signature >>> 24 & 0xFF),
            signature,
            compressed: compressionMethod != 0,
            encrypted,
            useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers")
        }, config);
        if (!writer.initialized) {
            await writer.init();
        }
        const signal = getOptionValue(zipEntry, options, "signal");
        const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
        await processData(codec, reader, writer, dataOffset, compressedSize, config, {
            onprogress: options.onprogress,
            signal
        });
        return writer.getData();
    }
}
function readCommonHeader(directory, dataView, offset) {
    const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
    const encrypted = (rawBitFlag & 0x01) == 0x01;
    const rawLastModDate = getUint32(dataView, offset + 6);
    Object.assign(directory, {
        encrypted,
        version: getUint16(dataView, offset),
        bitFlag: {
            level: (rawBitFlag & 0x06) >> 1,
            dataDescriptor: (rawBitFlag & 0x0008) == 0x0008,
            languageEncodingFlag: (rawBitFlag & 0x0800) == 0x0800
        },
        rawLastModDate,
        lastModDate: getDate(rawLastModDate),
        filenameLength: getUint16(dataView, offset + 22),
        extraFieldLength: getUint16(dataView, offset + 24)
    });
}
function readCommonFooter(fileEntry, directory, dataView, offset) {
    const rawExtraField = directory.rawExtraField;
    const extraField = directory.extraField = new Map();
    const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
    let offsetExtraField = 0;
    try {
        while(offsetExtraField < rawExtraField.length){
            const type = getUint16(rawExtraFieldView, offsetExtraField);
            const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
            extraField.set(type, {
                type,
                data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
            });
            offsetExtraField += 4 + size;
        }
    } catch (error) {}
    const compressionMethod = getUint16(dataView, offset + 4);
    directory.signature = getUint32(dataView, offset + 10);
    directory.uncompressedSize = getUint32(dataView, offset + 18);
    directory.compressedSize = getUint32(dataView, offset + 14);
    const extraFieldZip64 = extraField.get(0x0001);
    if (extraFieldZip64) {
        readExtraFieldZip64(extraFieldZip64, directory);
        directory.extraFieldZip64 = extraFieldZip64;
    }
    const extraFieldUnicodePath = extraField.get(0x7075);
    if (extraFieldUnicodePath) {
        readExtraFieldUnicode(extraFieldUnicodePath, "filename", "rawFilename", directory, fileEntry);
        directory.extraFieldUnicodePath = extraFieldUnicodePath;
    }
    const extraFieldUnicodeComment = extraField.get(0x6375);
    if (extraFieldUnicodeComment) {
        readExtraFieldUnicode(extraFieldUnicodeComment, "comment", "rawComment", directory, fileEntry);
        directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
    }
    const extraFieldAES = extraField.get(0x9901);
    if (extraFieldAES) {
        readExtraFieldAES(extraFieldAES, directory, compressionMethod);
        directory.extraFieldAES = extraFieldAES;
    } else {
        directory.compressionMethod = compressionMethod;
    }
    const extraFieldNTFS = extraField.get(0x000a);
    if (extraFieldNTFS) {
        readExtraFieldNTFS(extraFieldNTFS, directory);
        directory.extraFieldNTFS = extraFieldNTFS;
    }
    const extraFieldExtendedTimestamp = extraField.get(0x5455);
    if (extraFieldExtendedTimestamp) {
        readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);
        directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
    }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
    directory.zip64 = true;
    const extraFieldView = getDataView(extraFieldZip64.data);
    extraFieldZip64.values = [];
    for(let indexValue = 0; indexValue < Math.floor(extraFieldZip64.data.length / 8); indexValue++){
        extraFieldZip64.values.push(getBigUint64(extraFieldView, 0 + indexValue * 8));
    }
    const missingProperties = ZIP64_PROPERTIES.filter((propertyName)=>directory[propertyName] == 0xffffffff);
    for(let indexMissingProperty = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++){
        extraFieldZip64[missingProperties[indexMissingProperty]] = extraFieldZip64.values[indexMissingProperty];
    }
    ZIP64_PROPERTIES.forEach((propertyName)=>{
        if (directory[propertyName] == 0xffffffff) {
            if (extraFieldZip64[propertyName] !== undefined) {
                directory[propertyName] = extraFieldZip64[propertyName];
            } else {
                throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
            }
        }
    });
}
function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
    const extraFieldView = getDataView(extraFieldUnicode.data);
    extraFieldUnicode.version = getUint8(extraFieldView, 0);
    extraFieldUnicode.signature = getUint32(extraFieldView, 1);
    const crc32 = new Crc32();
    crc32.append(fileEntry[rawPropertyName]);
    const dataViewSignature = getDataView(new Uint8Array(4));
    dataViewSignature.setUint32(0, crc32.get(), true);
    extraFieldUnicode[propertyName] = new TextDecoder().decode(extraFieldUnicode.data.subarray(5));
    extraFieldUnicode.valid = !fileEntry.bitFlag.languageEncodingFlag && extraFieldUnicode.signature == getUint32(dataViewSignature, 0);
    if (extraFieldUnicode.valid) {
        directory[propertyName] = extraFieldUnicode[propertyName];
        directory[propertyName + "UTF8"] = true;
    }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
    const extraFieldView = getDataView(extraFieldAES.data);
    extraFieldAES.vendorVersion = getUint8(extraFieldView, 0);
    extraFieldAES.vendorId = getUint8(extraFieldView, 2);
    const strength = getUint8(extraFieldView, 4);
    extraFieldAES.strength = strength;
    extraFieldAES.originalCompressionMethod = compressionMethod;
    directory.compressionMethod = extraFieldAES.compressionMethod = getUint16(extraFieldView, 5);
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
    const extraFieldView = getDataView(extraFieldNTFS.data);
    let offsetExtraField = 4;
    let tag1Data;
    try {
        while(offsetExtraField < extraFieldNTFS.data.length && !tag1Data){
            const tagValue = getUint16(extraFieldView, offsetExtraField);
            const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
            if (tagValue == 0x0001) {
                tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
            }
            offsetExtraField += 4 + attributeSize;
        }
    } catch (error) {}
    try {
        if (tag1Data && tag1Data.length == 24) {
            const tag1View = getDataView(tag1Data);
            const rawLastModDate = tag1View.getBigUint64(0, true);
            const rawLastAccessDate = tag1View.getBigUint64(8, true);
            const rawCreationDate = tag1View.getBigUint64(16, true);
            Object.assign(extraFieldNTFS, {
                rawLastModDate,
                rawLastAccessDate,
                rawCreationDate
            });
            const lastModDate = getDateNTFS(rawLastModDate);
            const lastAccessDate = getDateNTFS(rawLastAccessDate);
            const creationDate = getDateNTFS(rawCreationDate);
            const extraFieldData = {
                lastModDate,
                lastAccessDate,
                creationDate
            };
            Object.assign(extraFieldNTFS, extraFieldData);
            Object.assign(directory, extraFieldData);
        }
    } catch (error1) {}
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {
    const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
    const flags = getUint8(extraFieldView, 0);
    const timeProperties = [];
    const timeRawProperties = [];
    if ((flags & 0x1) == 0x1) {
        timeProperties.push("lastModDate");
        timeRawProperties.push("rawLastModDate");
    }
    if ((flags & 0x2) == 0x2) {
        timeProperties.push("lastAccessDate");
        timeRawProperties.push("rawLastAccessDate");
    }
    if ((flags & 0x4) == 0x4) {
        timeProperties.push("creationDate");
        timeRawProperties.push("rawCreationDate");
    }
    let offset = 1;
    timeProperties.forEach((propertyName, indexProperty)=>{
        if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
            const time = getUint32(extraFieldView, offset);
            directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
            const rawPropertyName = timeRawProperties[indexProperty];
            extraFieldExtendedTimestamp[rawPropertyName] = time;
        }
        offset += 4;
    });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
    const signatureArray = new Uint8Array(4);
    const signatureView = getDataView(signatureArray);
    setUint32(signatureView, 0, signature);
    const maximumBytes = minimumBytes + maximumLength;
    return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
    async function seek(length) {
        const offset = startOffset - length;
        const bytes = await readUint8Array(reader, offset, length);
        for(let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--){
            if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
                return {
                    offset: offset + indexByte,
                    buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
                };
            }
        }
    }
}
function getOptionValue(zipReader, options, name) {
    return options[name] === undefined ? zipReader.options[name] : options[name];
}
function decodeString(value, encoding) {
    if (!encoding || encoding.trim().toLowerCase() == "cp437") {
        return __default8(value);
    } else {
        return new TextDecoder(encoding).decode(value);
    }
}
function getDate(timeRaw) {
    const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
    try {
        return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
    } catch (error) {}
}
function getDateNTFS(timeRaw) {
    return new Date(Number(timeRaw / BigInt(10000) - BigInt(11644473600000)));
}
function getUint8(view, offset) {
    return view.getUint8(offset);
}
function getUint16(view, offset) {
    return view.getUint16(offset, true);
}
function getUint32(view, offset) {
    return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
    return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
    view.setUint32(offset, value, true);
}
function getDataView(array) {
    return new DataView(array.buffer);
}
function readUint8Array(reader, offset, size) {
    return reader.readUint8Array(offset, size);
}
"use strict";
const ERR_DUPLICATED_NAME = "File already exists";
const ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
const ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
const ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
const ERR_INVALID_VERSION = "Version exceeds 65535";
const ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
const ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
const ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
const ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported";
const EXTRAFIELD_DATA_AES = new Uint8Array([
    0x07,
    0x00,
    0x02,
    0x00,
    0x41,
    0x45,
    0x03,
    0x00,
    0x00
]);
let workers = 0;
class ZipWriter {
    constructor(writer, options = {}){
        Object.assign(this, {
            writer,
            options,
            config: getConfiguration(),
            files: new Map(),
            offset: writer.size,
            pendingCompressedSize: 0,
            pendingEntries: []
        });
    }
    async add(name = "", reader, options = {}) {
        const zipWriter = this;
        if (workers < zipWriter.config.maxWorkers) {
            workers++;
            try {
                return await addFile(zipWriter, name, reader, options);
            } finally{
                workers--;
                const pendingEntry = zipWriter.pendingEntries.shift();
                if (pendingEntry) {
                    zipWriter.add(pendingEntry.name, pendingEntry.reader, pendingEntry.options).then(pendingEntry.resolve).catch(pendingEntry.reject);
                }
            }
        } else {
            return new Promise((resolve, reject)=>zipWriter.pendingEntries.push({
                    name,
                    reader,
                    options,
                    resolve,
                    reject
                }));
        }
    }
    async close(comment = new Uint8Array(0), options = {}) {
        await closeFile(this, comment, options);
        return this.writer.getData();
    }
}
async function addFile(zipWriter, name, reader, options) {
    name = name.trim();
    if (options.directory && !name.endsWith(DIRECTORY_SIGNATURE)) {
        name += DIRECTORY_SIGNATURE;
    } else {
        options.directory = name.endsWith(DIRECTORY_SIGNATURE);
    }
    if (zipWriter.files.has(name)) {
        throw new Error(ERR_DUPLICATED_NAME);
    }
    const rawFilename = new TextEncoder().encode(name);
    if (rawFilename.length > 0xffff) {
        throw new Error(ERR_INVALID_ENTRY_NAME);
    }
    const comment = options.comment || "";
    const rawComment = new TextEncoder().encode(comment);
    if (rawComment.length > 0xffff) {
        throw new Error(ERR_INVALID_ENTRY_COMMENT);
    }
    const version = zipWriter.options.version || options.version || 0;
    if (version > 0xffff) {
        throw new Error(ERR_INVALID_VERSION);
    }
    const versionMadeBy = zipWriter.options.versionMadeBy || options.versionMadeBy || 20;
    if (versionMadeBy > 0xffff) {
        throw new Error(ERR_INVALID_VERSION);
    }
    const lastModDate = getOptionValue1(zipWriter, options, "lastModDate") || new Date();
    const lastAccessDate = getOptionValue1(zipWriter, options, "lastAccessDate");
    const creationDate = getOptionValue1(zipWriter, options, "creationDate");
    const password = getOptionValue1(zipWriter, options, "password");
    const encryptionStrength = getOptionValue1(zipWriter, options, "encryptionStrength") || 3;
    const zipCrypto = getOptionValue1(zipWriter, options, "zipCrypto");
    if (password !== undefined && encryptionStrength !== undefined && (encryptionStrength < 1 || encryptionStrength > 3)) {
        throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
    }
    let rawExtraField = new Uint8Array(0);
    const extraField = options.extraField;
    if (extraField) {
        let extraFieldSize = 0;
        let offset = 0;
        extraField.forEach((data)=>extraFieldSize += 4 + data.length);
        rawExtraField = new Uint8Array(extraFieldSize);
        extraField.forEach((data, type)=>{
            if (type > 0xffff) {
                throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
            }
            if (data.length > 0xffff) {
                throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
            }
            arraySet(rawExtraField, new Uint16Array([
                type
            ]), offset);
            arraySet(rawExtraField, new Uint16Array([
                data.length
            ]), offset + 2);
            arraySet(rawExtraField, data, offset + 4);
            offset += 4 + data.length;
        });
    }
    let extendedTimestamp = getOptionValue1(zipWriter, options, "extendedTimestamp");
    if (extendedTimestamp === undefined) {
        extendedTimestamp = true;
    }
    let maximumCompressedSize = 0;
    let keepOrder = getOptionValue1(zipWriter, options, "keepOrder");
    if (keepOrder === undefined) {
        keepOrder = true;
    }
    let uncompressedSize = 0;
    let msDosCompatible = getOptionValue1(zipWriter, options, "msDosCompatible");
    if (msDosCompatible === undefined) {
        msDosCompatible = true;
    }
    const internalFileAttribute = getOptionValue1(zipWriter, options, "internalFileAttribute") || 0;
    const externalFileAttribute = getOptionValue1(zipWriter, options, "externalFileAttribute") || 0;
    if (reader) {
        if (!reader.initialized) {
            await reader.init();
        }
        uncompressedSize = reader.size;
        maximumCompressedSize = getMaximumCompressedSize1(uncompressedSize);
    }
    let zip64 = options.zip64 || zipWriter.options.zip64 || false;
    if (zipWriter.offset + zipWriter.pendingCompressedSize >= 0xffffffff || uncompressedSize >= 0xffffffff || maximumCompressedSize >= 0xffffffff) {
        if (options.zip64 === false || zipWriter.options.zip64 === false || !keepOrder) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    zipWriter.pendingCompressedSize += maximumCompressedSize;
    await Promise.resolve();
    const level = getOptionValue1(zipWriter, options, "level");
    const useWebWorkers = getOptionValue1(zipWriter, options, "useWebWorkers");
    const bufferedWrite = getOptionValue1(zipWriter, options, "bufferedWrite");
    let dataDescriptor = getOptionValue1(zipWriter, options, "dataDescriptor");
    let dataDescriptorSignature = getOptionValue1(zipWriter, options, "dataDescriptorSignature");
    const signal = getOptionValue1(zipWriter, options, "signal");
    if (dataDescriptor === undefined) {
        dataDescriptor = true;
    }
    if (dataDescriptor && dataDescriptorSignature === undefined) {
        dataDescriptorSignature = true;
    }
    const fileEntry = await getFileEntry(zipWriter, name, reader, Object.assign({}, options, {
        rawFilename,
        rawComment,
        version,
        versionMadeBy,
        lastModDate,
        lastAccessDate,
        creationDate,
        rawExtraField,
        zip64,
        password,
        level,
        useWebWorkers,
        encryptionStrength,
        extendedTimestamp,
        zipCrypto,
        bufferedWrite,
        keepOrder,
        dataDescriptor,
        dataDescriptorSignature,
        signal,
        msDosCompatible,
        internalFileAttribute,
        externalFileAttribute
    }));
    if (maximumCompressedSize) {
        zipWriter.pendingCompressedSize -= maximumCompressedSize;
    }
    Object.assign(fileEntry, {
        name,
        comment,
        extraField
    });
    return new Entry(fileEntry);
}
async function getFileEntry(zipWriter, name, reader, options) {
    const files = zipWriter.files;
    const writer = zipWriter.writer;
    const previousFileEntry = Array.from(files.values()).pop();
    let fileEntry = {};
    let bufferedWrite;
    let resolveLockUnbufferedWrite;
    let resolveLockCurrentFileEntry;
    files.set(name, fileEntry);
    try {
        let lockPreviousFileEntry;
        let fileWriter;
        let lockCurrentFileEntry;
        if (options.keepOrder) {
            lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
        }
        fileEntry.lock = lockCurrentFileEntry = new Promise((resolve)=>resolveLockCurrentFileEntry = resolve);
        if (options.bufferedWrite || zipWriter.lockWrite || !options.dataDescriptor) {
            fileWriter = new BlobWriter();
            fileWriter.init();
            bufferedWrite = true;
        } else {
            zipWriter.lockWrite = new Promise((resolve)=>resolveLockUnbufferedWrite = resolve);
            if (!writer.initialized) {
                await writer.init();
            }
            fileWriter = writer;
        }
        fileEntry = await createFileEntry(reader, fileWriter, zipWriter.config, options);
        fileEntry.lock = lockCurrentFileEntry;
        files.set(name, fileEntry);
        fileEntry.filename = name;
        if (bufferedWrite) {
            let indexWrittenData = 0;
            const blob = fileWriter.getData();
            await Promise.all([
                zipWriter.lockWrite,
                lockPreviousFileEntry
            ]);
            let pendingFileEntry;
            do {
                pendingFileEntry = Array.from(files.values()).find((fileEntry)=>fileEntry.writingBufferedData);
                if (pendingFileEntry) {
                    await pendingFileEntry.lock;
                }
            }while (pendingFileEntry && pendingFileEntry.lock)
            fileEntry.writingBufferedData = true;
            if (!options.dataDescriptor) {
                const headerLength = 26;
                const arrayBuffer = await sliceAsArrayBuffer(blob, 0, 26);
                const arrayBufferView = new DataView(arrayBuffer);
                if (!fileEntry.encrypted || options.zipCrypto) {
                    setUint321(arrayBufferView, 14, fileEntry.signature);
                }
                if (fileEntry.zip64) {
                    setUint321(arrayBufferView, 18, 0xffffffff);
                    setUint321(arrayBufferView, 22, 0xffffffff);
                } else {
                    setUint321(arrayBufferView, 18, fileEntry.compressedSize);
                    setUint321(arrayBufferView, 22, fileEntry.uncompressedSize);
                }
                await writer.writeUint8Array(new Uint8Array(arrayBuffer));
                indexWrittenData = headerLength;
            }
            await writeBlob(writer, blob, indexWrittenData);
            delete fileEntry.writingBufferedData;
        }
        fileEntry.offset = zipWriter.offset;
        if (fileEntry.zip64) {
            const rawExtraFieldZip64View = getDataView1(fileEntry.rawExtraFieldZip64);
            setBigUint64(rawExtraFieldZip64View, 20, BigInt(fileEntry.offset));
        } else if (fileEntry.offset >= 0xffffffff) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        }
        zipWriter.offset += fileEntry.length;
        return fileEntry;
    } catch (error) {
        if (bufferedWrite && fileEntry.writingBufferedData || !bufferedWrite && fileEntry.dataWritten) {
            error.corruptedEntry = zipWriter.hasCorruptedEntries = true;
            if (fileEntry.uncompressedSize) {
                zipWriter.offset += fileEntry.uncompressedSize;
            }
        }
        files.delete(name);
        throw error;
    } finally{
        resolveLockCurrentFileEntry();
        if (resolveLockUnbufferedWrite) {
            resolveLockUnbufferedWrite();
        }
    }
}
async function createFileEntry(reader, writer, config, options) {
    const { rawFilename , lastAccessDate , creationDate , password , level , zip64 , zipCrypto , dataDescriptor , dataDescriptorSignature , directory , version , versionMadeBy , rawComment , rawExtraField , useWebWorkers , onprogress , signal , encryptionStrength , extendedTimestamp , msDosCompatible , internalFileAttribute , externalFileAttribute  } = options;
    const encrypted = Boolean(password && password.length);
    const compressed = level !== 0 && !directory;
    let rawExtraFieldAES;
    if (encrypted && !zipCrypto) {
        rawExtraFieldAES = new Uint8Array(EXTRAFIELD_DATA_AES.length + 2);
        const extraFieldAESView = getDataView1(rawExtraFieldAES);
        setUint16(extraFieldAESView, 0, 0x9901);
        arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
        setUint8(extraFieldAESView, 8, encryptionStrength);
    } else {
        rawExtraFieldAES = new Uint8Array(0);
    }
    let rawExtraFieldNTFS;
    let rawExtraFieldExtendedTimestamp;
    if (extendedTimestamp) {
        rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
        const extraFieldExtendedTimestampView = getDataView1(rawExtraFieldExtendedTimestamp);
        setUint16(extraFieldExtendedTimestampView, 0, 0x5455);
        setUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);
        const extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);
        setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
        setUint321(extraFieldExtendedTimestampView, 5, Math.floor(options.lastModDate.getTime() / 1000));
        if (lastAccessDate) {
            setUint321(extraFieldExtendedTimestampView, 9, Math.floor(lastAccessDate.getTime() / 1000));
        }
        if (creationDate) {
            setUint321(extraFieldExtendedTimestampView, 13, Math.floor(creationDate.getTime() / 1000));
        }
        try {
            rawExtraFieldNTFS = new Uint8Array(36);
            const extraFieldNTFSView = getDataView1(rawExtraFieldNTFS);
            const lastModTimeNTFS = getTimeNTFS(options.lastModDate);
            setUint16(extraFieldNTFSView, 0, 0x000a);
            setUint16(extraFieldNTFSView, 2, 32);
            setUint16(extraFieldNTFSView, 8, 0x0001);
            setUint16(extraFieldNTFSView, 10, 24);
            setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
        } catch (error) {
            rawExtraFieldNTFS = new Uint8Array(0);
        }
    } else {
        rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);
    }
    const fileEntry = {
        version: version || 0x14,
        versionMadeBy,
        zip64,
        directory: Boolean(directory),
        filenameUTF8: true,
        rawFilename,
        commentUTF8: true,
        rawComment,
        rawExtraFieldZip64: zip64 ? new Uint8Array(24 + 4) : new Uint8Array(0),
        rawExtraFieldExtendedTimestamp,
        rawExtraFieldNTFS,
        rawExtraFieldAES,
        rawExtraField,
        extendedTimestamp,
        msDosCompatible,
        internalFileAttribute,
        externalFileAttribute
    };
    let uncompressedSize = fileEntry.uncompressedSize = 0;
    let bitFlag = 0x0800;
    if (dataDescriptor) {
        bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;
    }
    let compressionMethod = 0x00;
    if (compressed) {
        compressionMethod = COMPRESSION_METHOD_DEFLATE;
    }
    if (zip64) {
        fileEntry.version = fileEntry.version > VERSION_ZIP64 ? fileEntry.version : VERSION_ZIP64;
    }
    if (encrypted) {
        bitFlag = bitFlag | BITFLAG_ENCRYPTED;
        if (!zipCrypto) {
            fileEntry.version = fileEntry.version > VERSION_AES ? fileEntry.version : VERSION_AES;
            compressionMethod = COMPRESSION_METHOD_AES;
            if (compressed) {
                fileEntry.rawExtraFieldAES[9] = COMPRESSION_METHOD_DEFLATE;
            }
        }
    }
    fileEntry.compressionMethod = compressionMethod;
    const headerArray = fileEntry.headerArray = new Uint8Array(26);
    const headerView = getDataView1(headerArray);
    setUint16(headerView, 0, fileEntry.version);
    setUint16(headerView, 2, bitFlag);
    setUint16(headerView, 4, compressionMethod);
    const dateArray = new Uint32Array(1);
    const dateView = getDataView1(dateArray);
    let lastModDate;
    if (options.lastModDate < MIN_DATE) {
        lastModDate = MIN_DATE;
    } else if (options.lastModDate > MAX_DATE) {
        lastModDate = MAX_DATE;
    } else {
        lastModDate = options.lastModDate;
    }
    setUint16(dateView, 0, (lastModDate.getHours() << 6 | lastModDate.getMinutes()) << 5 | lastModDate.getSeconds() / 2);
    setUint16(dateView, 2, (lastModDate.getFullYear() - 1980 << 4 | lastModDate.getMonth() + 1) << 5 | lastModDate.getDate());
    const rawLastModDate = dateArray[0];
    setUint321(headerView, 6, rawLastModDate);
    setUint16(headerView, 22, rawFilename.length);
    const extraFieldLength = rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + fileEntry.rawExtraField.length;
    setUint16(headerView, 24, extraFieldLength);
    const localHeaderArray = new Uint8Array(30 + rawFilename.length + extraFieldLength);
    const localHeaderView = getDataView1(localHeaderArray);
    setUint321(localHeaderView, 0, 0x04034b50);
    arraySet(localHeaderArray, headerArray, 4);
    arraySet(localHeaderArray, rawFilename, 30);
    arraySet(localHeaderArray, rawExtraFieldAES, 30 + rawFilename.length);
    arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + rawFilename.length + rawExtraFieldAES.length);
    arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);
    arraySet(localHeaderArray, fileEntry.rawExtraField, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);
    let result;
    let compressedSize = 0;
    if (reader) {
        uncompressedSize = fileEntry.uncompressedSize = reader.size;
        const codec = await createCodec1(config.Deflate, {
            codecType: CODEC_DEFLATE,
            level,
            password,
            encryptionStrength,
            zipCrypto: encrypted && zipCrypto,
            passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & 0xFF,
            signed: true,
            compressed,
            encrypted,
            useWebWorkers
        }, config);
        await writer.writeUint8Array(localHeaderArray);
        fileEntry.dataWritten = true;
        result = await processData(codec, reader, writer, 0, uncompressedSize, config, {
            onprogress,
            signal
        });
        compressedSize = result.length;
    } else {
        await writer.writeUint8Array(localHeaderArray);
        fileEntry.dataWritten = true;
    }
    let dataDescriptorArray = new Uint8Array(0);
    let dataDescriptorView, dataDescriptorOffset = 0;
    if (dataDescriptor) {
        dataDescriptorArray = new Uint8Array(zip64 ? dataDescriptorSignature ? 24 : 20 : dataDescriptorSignature ? 16 : 12);
        dataDescriptorView = getDataView1(dataDescriptorArray);
        if (dataDescriptorSignature) {
            dataDescriptorOffset = 4;
            setUint321(dataDescriptorView, 0, 0x08074b50);
        }
    }
    if (reader) {
        const signature = result.signature;
        if ((!encrypted || zipCrypto) && signature !== undefined) {
            setUint321(headerView, 10, signature);
            fileEntry.signature = signature;
            if (dataDescriptor) {
                setUint321(dataDescriptorView, dataDescriptorOffset, signature);
            }
        }
        if (zip64) {
            const rawExtraFieldZip64View = getDataView1(fileEntry.rawExtraFieldZip64);
            setUint16(rawExtraFieldZip64View, 0, 0x0001);
            setUint16(rawExtraFieldZip64View, 2, 24);
            setUint321(headerView, 14, 0xffffffff);
            setBigUint64(rawExtraFieldZip64View, 12, BigInt(compressedSize));
            setUint321(headerView, 18, 0xffffffff);
            setBigUint64(rawExtraFieldZip64View, 4, BigInt(uncompressedSize));
            if (dataDescriptor) {
                setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
                setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
            }
        } else {
            setUint321(headerView, 14, compressedSize);
            setUint321(headerView, 18, uncompressedSize);
            if (dataDescriptor) {
                setUint321(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
                setUint321(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
            }
        }
    }
    if (dataDescriptor) {
        await writer.writeUint8Array(dataDescriptorArray);
    }
    const length = localHeaderArray.length + compressedSize + dataDescriptorArray.length;
    Object.assign(fileEntry, {
        compressedSize,
        lastModDate,
        rawLastModDate,
        creationDate,
        lastAccessDate,
        encrypted,
        length
    });
    return fileEntry;
}
async function closeFile(zipWriter, comment, options) {
    const writer = zipWriter.writer;
    const files = zipWriter.files;
    let offset = 0;
    let directoryDataLength = 0;
    let directoryOffset = zipWriter.offset;
    let filesLength = files.size;
    for (const [, fileEntry] of files){
        directoryDataLength += 46 + fileEntry.rawFilename.length + fileEntry.rawComment.length + fileEntry.rawExtraFieldZip64.length + fileEntry.rawExtraFieldAES.length + fileEntry.rawExtraFieldExtendedTimestamp.length + fileEntry.rawExtraFieldNTFS.length + fileEntry.rawExtraField.length;
    }
    let zip64 = options.zip64 || zipWriter.options.zip64 || false;
    if (directoryOffset >= 0xffffffff || directoryDataLength >= 0xffffffff || filesLength >= 0xffff) {
        if (options.zip64 === false || zipWriter.options.zip64 === false) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    const directoryArray = new Uint8Array(directoryDataLength + (zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : 22));
    const directoryView = getDataView1(directoryArray);
    if (comment && comment.length) {
        if (comment.length <= 0xffff) {
            setUint16(directoryView, offset + 20, comment.length);
        } else {
            throw new Error(ERR_INVALID_COMMENT);
        }
    }
    for (const [indexFileEntry, fileEntry1] of Array.from(files.values()).entries()){
        const { rawFilename , rawExtraFieldZip64 , rawExtraFieldAES , rawExtraField , rawComment , versionMadeBy , headerArray , directory , zip64: zip641 , msDosCompatible , internalFileAttribute , externalFileAttribute  } = fileEntry1;
        let rawExtraFieldExtendedTimestamp;
        let rawExtraFieldNTFS;
        if (fileEntry1.extendedTimestamp) {
            rawExtraFieldNTFS = fileEntry1.rawExtraFieldNTFS;
            rawExtraFieldExtendedTimestamp = new Uint8Array(9);
            const extraFieldExtendedTimestampView = getDataView1(rawExtraFieldExtendedTimestamp);
            setUint16(extraFieldExtendedTimestampView, 0, 0x5455);
            setUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);
            setUint8(extraFieldExtendedTimestampView, 4, 0x1);
            setUint321(extraFieldExtendedTimestampView, 5, Math.floor(fileEntry1.lastModDate.getTime() / 1000));
        } else {
            rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);
        }
        const extraFieldLength = rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + rawExtraField.length;
        setUint321(directoryView, offset, 0x02014b50);
        setUint16(directoryView, offset + 4, versionMadeBy);
        arraySet(directoryArray, headerArray, offset + 6);
        setUint16(directoryView, offset + 30, extraFieldLength);
        setUint16(directoryView, offset + 32, rawComment.length);
        setUint321(directoryView, offset + 34, internalFileAttribute);
        if (externalFileAttribute) {
            setUint321(directoryView, offset + 38, externalFileAttribute);
        } else if (directory && msDosCompatible) {
            setUint8(directoryView, offset + 38, 0x10);
        }
        if (zip641) {
            setUint321(directoryView, offset + 42, 0xffffffff);
        } else {
            setUint321(directoryView, offset + 42, fileEntry1.offset);
        }
        arraySet(directoryArray, rawFilename, offset + 46);
        arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + rawFilename.length);
        arraySet(directoryArray, rawExtraFieldAES, offset + 46 + rawFilename.length + rawExtraFieldZip64.length);
        arraySet(directoryArray, rawExtraFieldExtendedTimestamp, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length);
        arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);
        arraySet(directoryArray, rawExtraField, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);
        arraySet(directoryArray, rawComment, offset + 46 + rawFilename.length + extraFieldLength);
        offset += 46 + rawFilename.length + extraFieldLength + rawComment.length;
        if (options.onprogress) {
            try {
                options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry1));
            } catch (error) {}
        }
    }
    if (zip64) {
        setUint321(directoryView, offset, 0x06064b50);
        setBigUint64(directoryView, offset + 4, BigInt(44));
        setUint16(directoryView, offset + 12, 45);
        setUint16(directoryView, offset + 14, 45);
        setBigUint64(directoryView, offset + 24, BigInt(filesLength));
        setBigUint64(directoryView, offset + 32, BigInt(filesLength));
        setBigUint64(directoryView, offset + 40, BigInt(directoryDataLength));
        setBigUint64(directoryView, offset + 48, BigInt(directoryOffset));
        setUint321(directoryView, offset + 56, 0x07064b50);
        setBigUint64(directoryView, offset + 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
        setUint321(directoryView, offset + 72, 1);
        filesLength = MAX_16_BITS;
        directoryOffset = MAX_32_BITS;
        directoryDataLength = MAX_32_BITS;
        offset += 76;
    }
    setUint321(directoryView, offset, 0x06054b50);
    setUint16(directoryView, offset + 8, filesLength);
    setUint16(directoryView, offset + 10, filesLength);
    setUint321(directoryView, offset + 12, directoryDataLength);
    setUint321(directoryView, offset + 16, directoryOffset);
    await writer.writeUint8Array(directoryArray);
    if (comment && comment.length) {
        await writer.writeUint8Array(comment);
    }
}
function sliceAsArrayBuffer(blob, start, end) {
    const fileReader = new FileReader();
    return new Promise((resolve, reject)=>{
        fileReader.onload = (event)=>resolve(event.target.result);
        fileReader.onerror = ()=>reject(fileReader.error);
        fileReader.readAsArrayBuffer(start || end ? blob.slice(start, end) : blob);
    });
}
async function writeBlob(writer, blob, start = 0) {
    const blockSize = 512 * 1024 * 1024;
    await writeSlice();
    async function writeSlice() {
        if (start < blob.size) {
            const arrayBuffer = await sliceAsArrayBuffer(blob, start, start + blockSize);
            await writer.writeUint8Array(new Uint8Array(arrayBuffer));
            start += blockSize;
            await writeSlice();
        }
    }
}
function getTimeNTFS(date) {
    if (date) {
        return (BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000);
    }
}
function getOptionValue1(zipWriter, options, name) {
    return options[name] === undefined ? zipWriter.options[name] : options[name];
}
function getMaximumCompressedSize1(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
function setUint8(view, offset, value) {
    view.setUint8(offset, value);
}
function setUint16(view, offset, value) {
    view.setUint16(offset, value, true);
}
function setUint321(view, offset, value) {
    view.setUint32(offset, value, true);
}
function setBigUint64(view, offset, value) {
    view.setBigUint64(offset, value, true);
}
function arraySet(array, typedArray, offset) {
    array.set(typedArray, offset);
}
function getDataView1(array) {
    return new DataView(array.buffer);
}
"use strict";
"use strict";
__default7();
"use strict";
configure({
    Deflate: ZipDeflate,
    Inflate: ZipInflate
});
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
async function createWalkEntry(path) {
    path = toPathString(path);
    path = normalize3(path);
    const name = basename2(path);
    const info = await Deno.stat(path);
    return {
        path,
        name,
        isFile: info.isFile,
        isDirectory: info.isDirectory,
        isSymlink: info.isSymlink
    };
}
function toPathString(path) {
    return path instanceof URL ? fromFileUrl2(path) : path;
}
function include(path, exts, match, skip) {
    if (exts && !exts.some((ext)=>path.endsWith(ext))) {
        return false;
    }
    if (match && !match.some((pattern)=>!!path.match(pattern))) {
        return false;
    }
    if (skip && skip.some((pattern)=>!!path.match(pattern))) {
        return false;
    }
    return true;
}
function wrapErrorWithRootPath(err, root) {
    if (err instanceof Error && "root" in err) return err;
    const e = new Error();
    e.root = root;
    e.message = err instanceof Error ? `${err.message} for path "${root}"` : `[non-error thrown] for path "${root}"`;
    e.stack = err instanceof Error ? err.stack : undefined;
    e.cause = err instanceof Error ? err.cause : undefined;
    return e;
}
async function* walk(root, { maxDepth =Infinity , includeFiles =true , includeDirs =true , followSymlinks =false , exts =undefined , match =undefined , skip =undefined  } = {}) {
    if (maxDepth < 0) {
        return;
    }
    root = toPathString(root);
    if (includeDirs && include(root, exts, match, skip)) {
        yield await createWalkEntry(root);
    }
    if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
        return;
    }
    try {
        for await (const entry of Deno.readDir(root)){
            assert(entry.name != null);
            let path = join3(root, entry.name);
            let { isSymlink , isDirectory  } = entry;
            if (isSymlink) {
                if (!followSymlinks) continue;
                path = await Deno.realPath(path);
                ({ isSymlink , isDirectory  } = await Deno.lstat(path));
            }
            if (isSymlink || isDirectory) {
                yield* walk(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip
                });
            } else if (includeFiles && include(path, exts, match, skip)) {
                yield {
                    path,
                    ...entry
                };
            }
        }
    } catch (err) {
        throw wrapErrorWithRootPath(err, normalize3(root));
    }
}
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class LineStream extends TransformStream {
    #bufs = new BytesList();
    #prevHadCR = false;
    constructor(){
        super({
            transform: (chunk, controller)=>{
                this.#handle(chunk, controller);
            },
            flush: (controller)=>{
                controller.enqueue(this.#mergeBufs(false));
            }
        });
    }
    #handle(chunk, controller) {
        const lfIndex = chunk.indexOf(LF);
        if (this.#prevHadCR) {
            this.#prevHadCR = false;
            if (lfIndex === 0) {
                controller.enqueue(this.#mergeBufs(true));
                this.#handle(chunk.subarray(1), controller);
                return;
            }
        }
        if (lfIndex === -1) {
            if (chunk.at(-1) === CR) {
                this.#prevHadCR = true;
            }
            this.#bufs.add(chunk);
        } else {
            let crOrLfIndex = lfIndex;
            if (chunk[lfIndex - 1] === CR) {
                crOrLfIndex--;
            }
            this.#bufs.add(chunk.subarray(0, crOrLfIndex));
            controller.enqueue(this.#mergeBufs(false));
            this.#handle(chunk.subarray(lfIndex + 1), controller);
        }
    }
    #mergeBufs(prevHadCR) {
        const mergeBuf = this.#bufs.concat();
        this.#bufs = new BytesList();
        if (prevHadCR) {
            return mergeBuf.subarray(0, -1);
        } else {
            return mergeBuf;
        }
    }
}
class TextLineStream extends TransformStream {
    #allowCR;
    #buf = "";
    constructor(options){
        super({
            transform: (chunk, controller)=>this.#handle(chunk, controller),
            flush: (controller)=>this.#handle("\r\n", controller)
        });
        this.#allowCR = options?.allowCR ?? false;
    }
    #handle(chunk1, controller1) {
        chunk1 = this.#buf + chunk1;
        for(;;){
            const lfIndex1 = chunk1.indexOf("\n");
            if (this.#allowCR) {
                const crIndex = chunk1.indexOf("\r");
                if (crIndex !== -1 && crIndex !== chunk1.length - 1 && (lfIndex1 === -1 || lfIndex1 - 1 > crIndex)) {
                    controller1.enqueue(chunk1.slice(0, crIndex));
                    chunk1 = chunk1.slice(crIndex + 1);
                    continue;
                }
            }
            if (lfIndex1 !== -1) {
                let crOrLfIndex1 = lfIndex1;
                if (chunk1[lfIndex1 - 1] === "\r") {
                    crOrLfIndex1--;
                }
                controller1.enqueue(chunk1.slice(0, crOrLfIndex1));
                chunk1 = chunk1.slice(lfIndex1 + 1);
                continue;
            }
            break;
        }
        this.#buf = chunk1;
    }
}
class DelimiterStream extends TransformStream {
    #bufs = new BytesList();
    #delimiter;
    #inspectIndex = 0;
    #matchIndex = 0;
    #delimLen;
    #delimLPS;
    constructor(delimiter){
        super({
            transform: (chunk, controller)=>{
                this.#handle(chunk, controller);
            },
            flush: (controller)=>{
                controller.enqueue(this.#bufs.concat());
            }
        });
        this.#delimiter = delimiter;
        this.#delimLen = delimiter.length;
        this.#delimLPS = createLPS(delimiter);
    }
    #handle(chunk2, controller2) {
        this.#bufs.add(chunk2);
        let localIndex = 0;
        while(this.#inspectIndex < this.#bufs.size()){
            if (chunk2[localIndex] === this.#delimiter[this.#matchIndex]) {
                this.#inspectIndex++;
                localIndex++;
                this.#matchIndex++;
                if (this.#matchIndex === this.#delimLen) {
                    const matchEnd = this.#inspectIndex - this.#delimLen;
                    const readyBytes = this.#bufs.slice(0, matchEnd);
                    controller2.enqueue(readyBytes);
                    this.#bufs.shift(this.#inspectIndex);
                    this.#inspectIndex = 0;
                    this.#matchIndex = 0;
                }
            } else {
                if (this.#matchIndex === 0) {
                    this.#inspectIndex++;
                    localIndex++;
                } else {
                    this.#matchIndex = this.#delimLPS[this.#matchIndex - 1];
                }
            }
        }
    }
}
function createLPS(pat) {
    const lps = new Uint8Array(pat.length);
    lps[0] = 0;
    let prefixEnd = 0;
    let i = 1;
    while(i < lps.length){
        if (pat[i] == pat[prefixEnd]) {
            prefixEnd++;
            lps[i] = prefixEnd;
            i++;
        } else if (prefixEnd === 0) {
            lps[i] = 0;
            i++;
        } else {
            prefixEnd = lps[prefixEnd - 1];
        }
    }
    return lps;
}
function mergeReadableStreams(...streams) {
    const resolvePromises = streams.map(()=>deferred());
    return new ReadableStream({
        start (controller) {
            Promise.all(resolvePromises).then(()=>{
                controller.close();
            });
            try {
                for (const [key, stream] of Object.entries(streams)){
                    (async ()=>{
                        for await (const data of stream){
                            controller.enqueue(data);
                        }
                        resolvePromises[+key].resolve();
                    })();
                }
            } catch (e) {
                controller.error(e);
            }
        }
    });
}
class MapTransform extends TransformStream {
    constructor(mapFunction){
        super(new MapTransformer(mapFunction));
    }
}
class MapTransformer {
    constructor(mapFunction){
        this.mapFunction = mapFunction;
    }
    transform(str, controller) {
        controller.enqueue(this.mapFunction(str));
    }
    mapFunction;
}
class FilterTransform extends TransformStream {
    constructor(filterFunction){
        super(new FilterTransformer(filterFunction));
    }
}
class FilterTransformer {
    constructor(filterFunction){
        this.filterFunction = filterFunction;
    }
    transform(str, controller) {
        if (this.filterFunction(str)) {
            controller.enqueue(str);
        }
    }
    filterFunction;
}
class GrepoTransform extends TransformStream {
    constructor(regex){
        super(new GrepoTransformer(regex));
    }
}
class GrepoTransformer {
    constructor(regex){
        this.regex = regex;
    }
    transform(str, controller) {
        const matchs = String(str).match(this.regex);
        matchs?.forEach((value)=>controller.enqueue(value));
    }
    regex;
}
async function streamToArray(stream) {
    const array = [];
    const reader = stream.getReader();
    let res;
    while(!res?.done){
        res = await reader.read();
        if (res.value) {
            array.push(res.value);
        }
    }
    reader.releaseLock();
    return array;
}
class HeadTransform extends TransformStream {
    constructor(max){
        super(new HeadTransformer(max));
    }
}
class HeadTransformer {
    count;
    constructor(max){
        this.max = max;
        this.count = 0;
    }
    transform(line, controller) {
        if (this.count < this.max) {
            this.count++;
            controller.enqueue(line);
        }
    }
    max;
}
class TailTransform extends TransformStream {
    constructor(max){
        super(new TailTransformer(max));
    }
}
class TailTransformer {
    buffer;
    constructor(max){
        this.max = max;
        this.buffer = [];
    }
    transform(line) {
        this.buffer.push(line);
        if (this.buffer.length > this.max + 1) {
            this.buffer.shift();
        }
    }
    flush(controller) {
        if (this.buffer.length) {
            if (this.buffer[this.buffer.length - 1] === "") {
                this.buffer.pop();
            } else {
                this.buffer.shift();
            }
        }
        for (const line of this.buffer){
            controller.enqueue(line);
        }
    }
    max;
}
class SpongeTransform extends TransformStream {
    constructor(){
        super(new SpongeTransformer());
    }
}
class SpongeTransformer {
    buffer = [];
    constructor(){}
    transform(line) {
        this.buffer.push(line);
    }
    flush(controller) {
        for (const line of this.buffer){
            controller.enqueue(line);
        }
    }
}
class UniqTransform extends TransformStream {
    constructor(){
        super(new UniqTransformer());
    }
}
class UniqTransformer {
    buffer;
    transform(line, controller) {
        if (this.buffer !== line) {
            this.buffer = line;
            controller.enqueue(line);
        }
    }
}
class SortTransform extends TransformStream {
    constructor(compareFn){
        super(new SortTransformer(compareFn));
    }
}
class SortTransformer {
    buffer;
    constructor(compareFn){
        this.compareFn = compareFn;
        this.buffer = [];
    }
    transform(line) {
        this.buffer.push(line);
    }
    flush(controller) {
        this.buffer.sort(this.compareFn);
        for (const line of this.buffer){
            controller.enqueue(line);
        }
    }
    compareFn;
}
class MapAwaitTransform extends TransformStream {
    constructor(mapFunction){
        super(new MapAwaitTransformer(mapFunction));
    }
}
class MapAwaitTransformer {
    constructor(mapFunction){
        this.mapFunction = mapFunction;
    }
    transform(chunk, controller) {
        return this.mapFunction(chunk).then((r)=>controller.enqueue(r));
    }
    mapFunction;
}
function parseCmdString(cmdOrStr) {
    return cmdOrStr instanceof Array ? cmdOrStr : cmdOrStr.trim().match(/((?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^ "']+)+)/g).map((p)=>p.match(/^"((\\"|[^"])*)"$/) ? p.replace(/^"((\\"|[^"])*)"$/, "$1") : p.match(/^'((\\'|[^'])*)'$/) ? p.replace(/^'((\\'|[^'])*)'$/, "$1") : p);
}
class MapAwaitParallelTransform extends TransformStream {
    readable;
    writable;
    lastId;
    readableController;
    pendingPromises;
    deferredClose;
    constructor(mapFunction, max){
        super();
        this.mapFunction = mapFunction;
        this.max = max;
        this.lastId = 0;
        this.pendingPromises = [];
        this.deferredClose = deferred();
        this.readable = new ReadableStream({
            start: (controller)=>{
                this.readableController = controller;
            }
        });
        this.writable = new WritableStream({
            write: this.enqueue.bind(this),
            close: async ()=>{
                this.deferredClose.resolve(-1);
                await Promise.all(this.pendingPromises.map((e)=>e.promise));
                this.readableController?.close();
            }
        });
    }
    async enqueue(chunk) {
        if (this.max && this.pendingPromises.length === this.max) {
            const racePromises = this.pendingPromises.map((e)=>e.promise);
            const id = await Promise.race([
                this.deferredClose,
                ...racePromises
            ]);
            const index = this.pendingPromises.findIndex((el)=>el.id === id);
            this.pendingPromises.splice(index, 1);
        }
        const id1 = ++this.lastId;
        const promise = this.mapFunction(chunk).then((result)=>{
            this.readableController.enqueue(result);
            return id1;
        });
        this.pendingPromises.push({
            id: id1,
            promise
        });
    }
    mapFunction;
    max;
}
class RunError extends Error {
    constructor(message, runStream){
        super(message);
        this.message = message;
        this.runStream = runStream;
    }
    message;
    runStream;
}
function arrayToStream(array) {
    return new ReadableStream({
        start (controller) {
            array.map((e)=>controller.enqueue(e));
            controller.close();
        }
    });
}
function dirToStream(path) {
    return new ReadableStream({
        async start (controller) {
            for await (const dirEntry of Deno.readDir(path)){
                controller.enqueue(dirEntry);
            }
            controller.close();
        }
    });
}
function walkToStream(path, opt) {
    return new ReadableStream({
        async start (controller) {
            for await (const dirEntry of walk(path, opt)){
                controller.enqueue(dirEntry);
            }
            controller.close();
        }
    });
}
function promiseToStream(promise) {
    return new ReadableStream({
        start (controller) {
            promise.then(async (readableStream)=>{
                const reader = readableStream.getReader();
                let res;
                while(!res?.done){
                    res = await reader.read();
                    controller.enqueue(res.value);
                }
                controller.close();
            });
        }
    });
}
class Stream2 {
    static fromRun(cmdOrStr, opt) {
        return new RunStream(cmdOrStr, opt);
    }
    static fromFile(file) {
        return new FileStream(file);
    }
    static fromArray(array) {
        return new LineStream1(undefined, arrayToStream(array));
    }
    static fromString(str) {
        return new LineStream1(undefined, arrayToStream(str.split("\n")));
    }
    static fromDir(path) {
        return new LineStream1(undefined, dirToStream(path));
    }
    static fromWalk(path, opt) {
        return new LineStream1(undefined, walkToStream(path, opt));
    }
    static fromFetch(url, requestInit) {
        return new LineStream1(undefined, promiseToStream(fetch(url, requestInit).then((r)=>r.body.pipeThrough(new TextDecoderStream()))));
    }
    static verbose = false;
    static setVerbose(verbose) {
        Stream2.verbose = verbose;
    }
    static processCount = 0;
    static processDone = 0;
    static processEventListener = [];
    static subscribeProcessEvent(listener) {
        Stream2.processEventListener.push(listener);
    }
    static unsubscribeProcessEvent(listener) {
        Stream2.processEventListener = Stream2.processEventListener.filter((l)=>l !== listener);
    }
    static sendProcessEvent() {
        Stream2.processEventListener.forEach((listener)=>listener({
                processCount: Stream2.processCount,
                processDone: Stream2.processDone
            }));
    }
    static resetProcessCount() {
        Stream2.processCount = 0;
        Stream2.processDone = 0;
    }
    static incProcessCount() {
        Stream2.processCount++;
        Stream2.sendProcessEvent();
    }
    static incProcessDone() {
        Stream2.processDone++;
        Stream2.sendProcessEvent();
    }
    static cwd;
    static setCwd(newCwd) {
        Stream2.cwd = newCwd;
    }
    static getCwd() {
        return Stream2.cwd;
    }
}
function getRunStream(stream) {
    if (stream instanceof RunStream) {
        return stream;
    }
    return undefined;
}
class LineStream1 {
    promisesToWaitOnClose;
    constructor(parent, linesStream){
        this.parent = parent;
        this.linesStream = linesStream;
        this.promisesToWaitOnClose = [];
    }
    getParents() {
        if (this.parent) {
            return [
                ...this.parent.getParents(),
                this.parent
            ];
        } else {
            return [];
        }
    }
    getLineReadableStream() {
        return this.linesStream;
    }
    toByteReadableStream() {
        let isFirst = true;
        const addLineBreakFn = (line)=>{
            if (isFirst) {
                isFirst = false;
                return line;
            } else {
                return "\n" + line;
            }
        };
        return this.getLineReadableStream().pipeThrough(new MapTransform(addLineBreakFn)).pipeThrough(new TextEncoderStream());
    }
    async wait(opt) {
        if (!this.getLineReadableStream().locked) {
            await this.getLineReadableStream().pipeTo(new WritableStream());
        }
        await this.parent?.wait(opt);
        if (this.promisesToWaitOnClose.length) {
            await Promise.all(this.promisesToWaitOnClose);
        }
        return this;
    }
    map(mapFunction) {
        return this.transform(new MapTransform(mapFunction));
    }
    tap(tapFunction) {
        return this.transform(new MapTransform((str)=>{
            tapFunction(str);
            return str;
        }));
    }
    log(transform) {
        return this.tap((line)=>transform ? console.log(transform(line)) : console.log(line));
    }
    logJson(replacer = null, space = "  ") {
        return this.log((el)=>JSON.stringify(el, replacer, space));
    }
    logWithTimestamp(transform) {
        return this.tap((line)=>transform ? console.log(transform(`${new Date().toISOString()} ${line}`)) : console.log(`${new Date().toISOString()} ${line}`));
    }
    filter(filterFunction) {
        return this.transform(new FilterTransform(filterFunction));
    }
    transform(transformStream) {
        return new LineStream1(this, this.getLineReadableStream().pipeThrough(transformStream));
    }
    grep(regex, opt) {
        const regEx = regex instanceof RegExp ? regex : new RegExp(regex);
        if (opt?.onlyMatching) {
            return this.transform(new GrepoTransform(regEx));
        } else {
            return this.filter((line)=>regEx.test(String(line)));
        }
    }
    grepo(regex) {
        return this.grep(regex, {
            onlyMatching: true
        });
    }
    async toArray() {
        const array = await streamToArray(this.getLineReadableStream());
        await this.wait();
        return array;
    }
    async toFile(file) {
        const firstStream = this.getParents()[0];
        const firstStreamFile = firstStream?.["file"];
        if (typeof file === "string" && firstStreamFile && firstStreamFile === file) {
            if (Stream2.verbose) {
                console.log("The output file is the same as the input, wait the end on the input stream before write the file");
            }
            const bytes = await this.toBytes();
            const fsFile = await Deno.create(file);
            await fsFile.write(bytes);
            fsFile.close();
            return this.wait();
        } else {
            let fsFile1;
            if (typeof file === "string") {
                fsFile1 = await Deno.create(file);
            } else {
                fsFile1 = file;
            }
            await this.toByteReadableStream().pipeTo(fsFile1.writable);
            return this.wait();
        }
    }
    async toString() {
        const decoder = new TextDecoder();
        return (await this.toArray()).map((v)=>v instanceof Uint8Array ? decoder.decode(v) : v).join("\n");
    }
    async toBytes() {
        return new TextEncoder().encode(await this.toString());
    }
    run(cmdOrStr, opt = {}) {
        return new RunStream(cmdOrStr, opt, this);
    }
    toIterable() {
        const stream = this.getLineReadableStream();
        return async function*() {
            const reader = stream.getReader();
            let res;
            while(!res?.done){
                res = await reader.read();
                if (!res?.done) {
                    yield res.value;
                }
            }
        }();
    }
    cut(delim, indexes) {
        return this.map((line)=>{
            const parts = String(line).split(delim);
            return indexes.map((i)=>parts[i]);
        });
    }
    replace(searchValue, replacer) {
        return this.map((line)=>String(line).replace(searchValue, replacer));
    }
    replaceAll(searchValue, replacer) {
        return this.map((line)=>String(line).replaceAll(searchValue, replacer));
    }
    tee(path) {
        if (this.linesStream) {
            const streams = this.linesStream.tee();
            this.linesStream = streams[0];
            const promise = new LineStream1(undefined, streams[1]).toFile(path);
            this.promisesToWaitOnClose.push(promise);
            return this;
        } else {
            const streams1 = this.toByteReadableStream().tee();
            this.promisesToWaitOnClose.push(Deno.create(path).then((file)=>streams1[1].pipeTo(file.writable)));
            return new LineStream1(this, streams1[0].pipeThrough(new TextDecoderStream()));
        }
    }
    head(max = 1) {
        return this.transform(new HeadTransform(max));
    }
    tail(max = 1) {
        return this.transform(new TailTransform(max));
    }
    sponge() {
        return this.transform(new SpongeTransform());
    }
    uniq() {
        return this.transform(new UniqTransform());
    }
    sort(compareFn) {
        return this.transform(new SortTransform(compareFn));
    }
    async success() {
        await this.wait({
            checkSuccess: true
        });
        const isFail = [
            ...this.getParents(),
            this
        ].map(getRunStream).some((r)=>r?.processStatus?.success === false);
        return !isFail;
    }
    async fail() {
        return !await this.success();
    }
    mapAwait(mapFunction) {
        return this.transform(new MapAwaitTransform(mapFunction));
    }
    mapAwaitParallel(mapFunction, max) {
        return this.transform(new MapAwaitParallelTransform(mapFunction, max));
    }
    xargsN1(cmdOrStr, opt) {
        const cmd = parseCmdString(cmdOrStr);
        return this.mapAwait((e)=>waitRun([
                ...cmd,
                String(e)
            ], opt));
    }
    xargsN1P(cmdOrStr, max, opt) {
        const cmd = parseCmdString(cmdOrStr);
        return this.mapAwaitParallel((e)=>waitRun([
                ...cmd,
                String(e)
            ], opt), max);
    }
    parent;
    linesStream;
}
class FileStream extends LineStream1 {
    fsFile;
    constructor(file, parent){
        super(parent);
        this.file = file;
        this.fsFile = typeof file === "string" ? Deno.openSync(file) : file;
    }
    getLineReadableStream() {
        if (!this.linesStream) {
            this.linesStream = this.toByteReadableStream().pipeThrough(new TextDecoderStream()).pipeThrough(new TextLineStream());
        }
        return this.linesStream;
    }
    wait() {
        return Promise.resolve(this);
    }
    async toBytes() {
        if (Stream2.verbose) {
            console.log("ReadAll file", this.file);
        }
        const bytes = await readAll(this.fsFile);
        Deno.close(this.fsFile.rid);
        return bytes;
    }
    async toString() {
        return new TextDecoder().decode(await this.toBytes());
    }
    toByteReadableStream() {
        if (Stream2.verbose) {
            console.log("Open readable of file", this.file);
        }
        return this.fsFile.readable;
    }
    async toFile(file) {
        const fsFile = typeof file === "string" ? await Deno.create(file) : file;
        await this.fsFile.readable.pipeTo(fsFile.writable);
        return this.wait();
    }
    file;
}
Stream2.setCwd;
const run2 = Stream2.fromRun;
Stream2.fromFile;
function waitRun(cmdOrStr, opt) {
    return Stream2.fromRun(cmdOrStr, opt).wait();
}
class RunStream extends LineStream1 {
    processCmd;
    process;
    processStatus;
    runningOpt;
    isClosed;
    cwd;
    pipeToEndPromise;
    constructor(cmdOrStr, opt, parent){
        super(parent);
        this.cmdOrStr = cmdOrStr;
        this.opt = opt;
        this.parent = parent;
        this.isClosed = false;
        this.processCmd = parseCmdString(cmdOrStr);
        this.cwd = Stream2.getCwd() || Deno.cwd();
    }
    getLineReadableStream() {
        if (!this.linesStream) {
            this.linesStream = this.toByteReadableStream().pipeThrough(new TextDecoderStream()).pipeThrough(new TextLineStream());
        }
        return this.linesStream;
    }
    start(opt) {
        if (!this.process) {
            this.runningOpt = opt;
            if (this.parent) {
                const parentStream = this.parent.toByteReadableStream();
                Stream2.incProcessCount();
                const fullOpt = {
                    cmd: this.processCmd,
                    cwd: this.cwd,
                    ...this.opt,
                    ...opt,
                    stdin: "piped"
                };
                if (Stream2.verbose) {
                    console.log("start processCmd: ", {
                        processCmd: this.processCmd,
                        opt: fullOpt
                    });
                }
                this.process = Deno.run(fullOpt);
                this.pipeToEndPromise = parentStream.pipeTo(this.process.stdin.writable);
            } else {
                Stream2.incProcessCount();
                const fullOpt1 = {
                    cmd: this.processCmd,
                    cwd: this.cwd,
                    ...this.opt,
                    ...opt
                };
                if (Stream2.verbose) {
                    console.log("start processCmd: ", {
                        processCmd: this.processCmd,
                        opt: fullOpt1
                    });
                }
                this.process = Deno.run(fullOpt1);
            }
        } else if (opt) {
            if (this.opt?.output === "stderr" || this.opt?.output === "merged") {
                assert1(this.runningOpt?.stderr === "piped", `Already running and the opt param is not empty. Use start({ stderr: "piped" })`);
            }
            if (this.opt?.output === "stdout" || this.opt?.output === "merged") {
                assert1(this.runningOpt?.stdout === "piped", `Already running and the opt param is not empty. Use start({ stdout: "piped" })`);
            }
        }
        return this;
    }
    async toString() {
        return new TextDecoder().decode(await this.toBytes());
    }
    async toBytes() {
        const buffer = new Buffer();
        const reader = this.toByteReadableStream().getReader();
        let res;
        while(!res?.done){
            res = await reader.read();
            if (res.value) {
                await buffer.write(res.value);
            }
        }
        await this.wait();
        return buffer.bytes();
    }
    async wait(opt) {
        if (!this.isClosed) {
            this.start();
            await this.parent?.wait(opt);
            await this.pipeToEndPromise;
            if (!this.processStatus) {
                this.processStatus = await this.process.status();
            }
            this.process.close();
            Stream2.incProcessDone();
            if (!this.processStatus?.success) {
                if (this.opt?.exitCodeOnFail !== undefined) {
                    Deno.exit(this.opt.exitCodeOnFail);
                }
                if (opt?.checkSuccess) {
                    if (this.opt?.allowFail === false) {
                        console.warn("[RunStream] allowFail===false but checkSuccess is requested");
                        throw new RunError(`Fail, process exit code : ${this.processStatus?.code}`, this);
                    }
                } else if (!this.opt?.allowFail) {
                    throw new Error(`Fail, process exit code : ${this.processStatus?.code}`);
                }
            }
            this.isClosed = true;
        }
        return this;
    }
    toByteReadableStream() {
        switch(this.opt?.output){
            case undefined:
            case "stdout":
                this.start({
                    stdout: "piped"
                });
                return this.process.stdout.readable;
            case "stderr":
                this.start({
                    stderr: "piped"
                });
                return this.process.stderr.readable;
            case "merged":
                {
                    this.start({
                        stdout: "piped",
                        stderr: "piped"
                    });
                    return mergeReadableStreams(transformReadable(this.process.stdout.readable, this.opt?.mergedTransform?.stdout), transformReadable(this.process.stderr.readable, this.opt?.mergedTransform?.stderr));
                }
        }
    }
    getStdOutAndStdErr() {
        this.start({
            stdout: "piped",
            stderr: "piped"
        });
        return {
            stdout: new LineStream1(this, this.process.stdout.readable),
            stderr: new LineStream1(this, this.process.stderr.readable)
        };
    }
    async toFile(file) {
        let fsFile;
        if (typeof file === "string") {
            fsFile = await Deno.create(file);
        } else {
            fsFile = file;
        }
        await this.toByteReadableStream().pipeTo(fsFile.writable);
        return await this.wait();
    }
    cmdOrStr;
    opt;
    parent;
}
function transformReadable(readable, transformer) {
    return transformer ? readable.pipeThrough(new TextDecoderStream()).pipeThrough(new TextLineStream()).pipeThrough(new MapTransform((s)=>transformer(s) + "\n")).pipeThrough(new TextEncoderStream()) : readable;
}
const en = {
    partQuestion: "Choose your part",
    partTitle: "Part",
    storyQuestion: "Choose your story",
    NightModeTransition: "Want to listen to a new story?"
};
const fr = {
    partQuestion: "Choisis ta partie",
    partTitle: "Partie",
    storyQuestion: "Choisis ton histoire",
    NightModeTransition: "Tu veux couter une nouvelle histoire ?"
};
async function initI18n(lng) {
    await __default2.init({
        lng,
        fallbackLng: "en-US",
        resources: {
            "en-US": {
                translation: en
            },
            "fr-FR": {
                translation: fr
            }
        }
    }, undefined);
}
async function getLang() {
    let LANG;
    if (Deno.build.os === "windows") {
        LANG = await run2([
            "powershell",
            "-NoProfile",
            "Get-UICulture|select -ExpandProperty Name"
        ]).toString();
    } else {
        if ((await Deno.permissions.query({
            name: "env"
        })).state === "granted") {
            LANG = Deno.env.get("LANG");
        } else {
            console.error(yellow(`Missing Deno env permission ! add "--allow-env" to permit lang detection`));
        }
    }
    let lang;
    const langRegex = /^([a-zA-Z_-]+)\.?/;
    if (LANG && langRegex.test(LANG)) {
        lang = langRegex.exec(LANG)[1].replace(/_/g, "-");
    }
    return lang || "en-US";
}
async function ls(path) {
    const entries = [];
    for await (const entry of Deno.readDir(path)){
        entries.push(entry);
    }
    return entries.sort((e1, e2)=>e1.name.localeCompare(e2.name));
}
async function fsToFolder(path, genSha1 = true) {
    const folder = {
        name: basename2(path),
        files: []
    };
    const entries = await ls(path);
    const lang = (await getLang()).substring(0, 2);
    entries.sort((a, b)=>a.name.localeCompare(b.name, lang, {
            numeric: true
        }));
    for (const entry of entries){
        if (entry.isDirectory) {
            folder.files.push(await fsToFolder(join3(path, entry.name), genSha1));
        } else {
            folder.files.push({
                name: entry.name,
                sha1: genSha1 ? await getSha1(join3(path, entry.name)) : ""
            });
        }
    }
    return folder;
}
async function getSha1(path) {
    const sha1Hash = createHash("sha1");
    const data = await Deno.readFile(path);
    sha1Hash.update(data);
    return sha1Hash.toString();
}
let ffmpegCommand = [];
async function checkCommand(cmd, exitCodeExpected) {
    console.log("checkCommand", cmd);
    try {
        const process1 = Deno.run({
            cmd,
            stdin: "null",
            stdout: "null",
            stderr: "null"
        });
        const status = await process1.status();
        process1.close();
        return status.code === exitCodeExpected;
    } catch (_e) {
        return false;
    }
}
function getInstallDir() {
    if (basename2(Deno.execPath()).match(/^deno/i)) {
        const fromFileUrl = Deno.build.os === "windows" ? mod.fromFileUrl : mod1.fromFileUrl;
        if (Deno.mainModule.match(/^http/)) {
            return ".";
        } else {
            return dirname2(fromFileUrl(Deno.mainModule));
        }
    } else {
        return dirname2(Deno.execPath());
    }
}
async function getFfmpegCommand() {
    if (ffmpegCommand.length === 0) {
        if (Deno.build.os === "windows") {
            const winFfmpeg = `${getInstallDir()}\\tools\\ffmpeg.exe`;
            if (await checkCommand([
                winFfmpeg,
                "-version"
            ], 0)) {
                ffmpegCommand = [
                    winFfmpeg
                ];
            } else {
                console.error(`
Command ffmpeg not found,
use --skip-extract-image-from-mp3 to skip image item generation
or check your install, ffmpeg should be present in studio-pack-generator/tools/ffmpeg.exe
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "ffmpeg",
                "-version"
            ], 0)) {
                ffmpegCommand = [
                    "ffmpeg"
                ];
            } else {
                console.error(`
Command ffmpeg (from ffmpeg) not found,
use --skip-image-item-gen to skip image item generation
or install ffmpeg : sudo apt install -y ffmpeg
`);
                Deno.exit(3);
            }
        }
    }
    return ffmpegCommand;
}
let pico2waveCommand = [];
async function getPico2waveCommand() {
    if (pico2waveCommand.length === 0) {
        if (Deno.build.os === "windows") {
            if (await checkCommand([
                "wsl",
                "pico2wave",
                "--version"
            ], 1)) {
                pico2waveCommand = [
                    "wsl",
                    "pico2wave"
                ];
            } else {
                console.error(`
Command pico2wave (from libttspico-utils) not found,
use --skip-audio-item-gen to skip audio item generation
or install pico2wave :
       wsl sudo apt update
       wsl sudo apt install -y libttspico-utils
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "pico2wave",
                "--version"
            ], 1)) {
                pico2waveCommand = [
                    "pico2wave"
                ];
            } else {
                console.error(`
Command pico2wave (from libttspico-utils) not found,
use --skip-audio-item-gen to skip audio item generation
or install pico2wave : sudo apt install -y libttspico-utils
`);
                Deno.exit(3);
            }
        }
    }
    return pico2waveCommand;
}
let convertCommand = [];
async function getConvertCommand() {
    if (convertCommand.length === 0) {
        if (Deno.build.os === "windows") {
            const winConvert = `${getInstallDir()}\\tools\\convert.exe`;
            if (await checkCommand([
                winConvert,
                "--version"
            ], 0)) {
                convertCommand = [
                    winConvert
                ];
            } else {
                console.error(`
Command convert (from ImageMagick) not found,
use --skip-image-item-gen to skip image item generation
or check your install, ImageMagick should be present in studio-pack-generator/tools/convert.exe
`);
                Deno.exit(3);
            }
        } else {
            if (await checkCommand([
                "convert",
                "--version"
            ], 0)) {
                convertCommand = [
                    "convert"
                ];
            } else {
                console.error(`
Command convert (from ImageMagick) not found,
use --skip-image-item-gen to skip image item generation
or install ImageMagick : sudo apt install -y imagemagick
`);
                Deno.exit(3);
            }
        }
    }
    return convertCommand;
}
const extensionRegEx = /\.([^.?]+)(\?.*)?$/i;
const folderAudioItemRegEx = /^0-item\.(ogg|opus|wav|mp3)$/i;
const nightModeAudioItemRegEx = /^0-night-mode\.(ogg|opus|wav|mp3)$/i;
const folderImageItemRegEx = /^0-item\.(png|jpg|jpeg|bmp)$/i;
const fileAudioItemRegEx = /\.item\.(ogg|opus|wav|mp3)$/i;
const fileImageItemRegEx = /\.item\.(png|jpg|jpeg|bmp)$/i;
const storyRegEx = /\.(ogg|opus|wav|mp3)$/i;
const itemsRegEx = [
    folderAudioItemRegEx,
    folderImageItemRegEx,
    fileAudioItemRegEx,
    fileImageItemRegEx,
    nightModeAudioItemRegEx
];
function isFolder(f) {
    return !!f.files;
}
function isFile(f) {
    return !f.files;
}
function getNameWithoutExt(name) {
    return /(.*)\.[^.]+$/.test(name) ? /(.*)\.[^.]+$/.exec(name)[1] : name;
}
function getExtension(name) {
    return extensionRegEx.exec(name)?.[1] || "";
}
function getFolderAudioItem(folder) {
    const file = folder.files.find((f)=>folderAudioItemRegEx.test(f.name));
    if (file) {
        return `${file.sha1}.${getExtension(file.name)}`;
    } else {
        return null;
    }
}
function getNightModeAudioItem(folder) {
    const file = folder.files.find((f)=>nightModeAudioItemRegEx.test(f.name));
    if (file) {
        return `${file.sha1}.${getExtension(file.name)}`;
    } else {
        return null;
    }
}
function getFolderImageItem(folder) {
    const file = folder.files.find((f)=>folderImageItemRegEx.test(f.name));
    if (file) {
        return `${file.sha1}.${getExtension(file.name)}`;
    } else {
        return null;
    }
}
function getFileAudioItem(file, parent) {
    const nameWithoutExt = getNameWithoutExt(file.name);
    const audioItem = parent.files.find((f)=>f.name.startsWith(nameWithoutExt) && fileAudioItemRegEx.test(f.name));
    if (audioItem) {
        return `${audioItem.sha1}.${getExtension(audioItem.name)}`;
    } else {
        return null;
    }
}
function getFileImageItem(file, parent) {
    const nameWithoutExt = getNameWithoutExt(file.name);
    const ImageItem = parent.files.find((f)=>f.name.startsWith(nameWithoutExt) && fileImageItemRegEx.test(f.name));
    if (ImageItem) {
        return `${ImageItem.sha1}.${getExtension(ImageItem.name)}`;
    } else {
        return null;
    }
}
function getFileAudioStory(file) {
    return `${file.sha1}.${getExtension(file.name)}`;
}
function isStory(file) {
    return storyRegEx.test(file.name) && !itemsRegEx.some((regex)=>regex.test(file.name));
}
function isZipFile(file) {
    return /\.zip$/i.test(file.name);
}
function isAudioItem(file) {
    return fileAudioItemRegEx.test(file.name) || folderAudioItemRegEx.test(file.name);
}
function firstStoryFile(folder) {
    return folder.files.find((f)=>storyRegEx.test(f.name) && !itemsRegEx.some((regex)=>regex.test(f.name)));
}
function convertPath(path) {
    return Deno.build.os === "windows" ? convWindowsWslPath(path) : path;
}
function convWindowsWslPath(path, cwd) {
    const groups = /^[a-z]:/i.test(path) ? /(^.)(.*)$/.exec(path) : /(^.)(.*)$/.exec((cwd || Deno.cwd()) + "/" + path);
    return "/mnt/" + groups?.[1].toLowerCase() + groups?.[2].replace(/\\/g, "/").replace(/:/g, "");
}
function uniq(items) {
    return [
        ...new Set(items)
    ];
}
async function convertToImageItem(inputPath, outputPath) {
    console.log(bgBlue(`Try convert ${inputPath}  ${outputPath}`));
    const process1 = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            inputPath,
            "-vf",
            "scale=320:240:force_original_aspect_ratio=decrease,pad='320:240:(ow-iw)/2:(oh-ih)/2'",
            outputPath
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const output = new TextDecoder().decode(await process1.stderrOutput());
    const status = await process1.status();
    if (status.success) {
        console.log(bgGreen(" OK"));
    } else {
        console.log(bgRed(" KO : \n" + output));
    }
    process1.close();
}
let runPermissionOk = false;
async function checkRunPermission() {
    if (!runPermissionOk) {
        if ((await Deno.permissions.query({
            name: "run"
        })).state !== "granted") {
            throw new Error(`Missing Deno run permission ! add "--allow-run"`);
        }
        runPermissionOk = true;
    }
}
async function extractImagesFromAudio(rootpath, folder) {
    await checkRunPermission();
    for (const file of folder.files){
        if (isFolder(file)) {
            await extractImagesFromAudio(join3(rootpath, file.name), file);
        } else {
            if (isStory(file)) {
                const imageItem = getFileImageItem(file, folder);
                if (!imageItem) {
                    const inputPath = join3(rootpath, file.name);
                    const outputPath = join3(rootpath, `${getNameWithoutExt(file.name)}.item.png`);
                    await convertToImageItem(inputPath, outputPath);
                }
            }
        }
    }
}
async function generateImage(title, outputPath) {
    console.log(bgGreen(`Generate image to ${outputPath}`));
    const process1 = await Deno.run({
        cmd: [
            ...await getConvertCommand(),
            "-background",
            "black",
            "-fill",
            "white",
            "-gravity",
            "center",
            "-size",
            "320x240",
            "-font",
            "Arial",
            `caption:${title}`,
            outputPath
        ]
    });
    await process1.status();
    process1.close();
}
let hasPico2waveWslCache;
async function hasPico2waveWsl() {
    if (hasPico2waveWslCache === undefined) {
        hasPico2waveWslCache = await checkCommand([
            "wsl",
            "pico2wave",
            "--version"
        ], 1);
    }
    return hasPico2waveWslCache;
}
let hasPico2waveCache;
async function hasPico2wave() {
    if (hasPico2waveCache === undefined) {
        hasPico2waveCache = await checkCommand([
            "pico2wave",
            "--version"
        ], 1);
    }
    return hasPico2waveCache;
}
async function generateAudio(title, outputPath, lang, skipWsl) {
    console.log(bgBlue(`Generate audio to ${outputPath}`));
    if (Deno.build.os === "windows" && (skipWsl || !await hasPico2waveWsl())) {
        const audioFormat = "[System.Speech.AudioFormat.SpeechAudioFormatInfo]::" + "new(8000,[System.Speech.AudioFormat.AudioBitsPerSample]" + "::Sixteen,[System.Speech.AudioFormat.AudioChannel]::Mono)";
        const process1 = Deno.run({
            cmd: [
                "PowerShell",
                "-Command",
                `Add-Type -AssemblyName System.Speech; ` + `$speak = New-Object System.Speech.Synthesis.SpeechSynthesizer; ` + `$speak.SetOutputToWaveFile("${outputPath}",${audioFormat}); ` + `$speak.Speak(" . ${title.replace(/["' ]/g, " ")} . "); ` + `$speak.Dispose();`
            ]
        });
        await process1.status();
        process1.close();
    } else if (Deno.build.os === "darwin" && !await hasPico2wave()) {
        const process11 = Deno.run({
            cmd: [
                "say",
                "-o",
                convertPath(outputPath),
                "--file-format",
                "WAVE",
                "--data-format",
                "LEF32@22050",
                ` . ${title} . `
            ]
        });
        await process11.status();
        process11.close();
    } else {
        const process2 = Deno.run({
            cmd: [
                ...await getPico2waveCommand(),
                "-l",
                lang,
                "-w",
                convertPath(outputPath),
                ` . ${title} . `
            ]
        });
        await process2.status();
        process2.close();
    }
}
function getTitle(name) {
    if (/^[0-9]* *-? *$/.test(name)) {
        return name;
    } else {
        return /^[0-9]* *-? *(.*)$/.exec(name)?.[1].replace(/_/g, " ").trim();
    }
}
async function genMissingItems(rootpath, folder, genImage, genAudio, lang, isRoot, skipWsl) {
    if (genImage || genAudio) {
        await checkRunPermission();
        if (genImage && !getFolderImageItem(folder)) {
            await generateImage(getTitle(folder.name), `${rootpath}/0-item.png`);
        }
        if (genAudio && !getFolderAudioItem(folder)) {
            await generateAudio(getTitle(folder.name), `${rootpath}/0-item.wav`, lang, skipWsl);
        }
        if (genAudio && isRoot && !getNightModeAudioItem(folder)) {
            await generateAudio(__default2.t("NightModeTransition"), `${rootpath}/0-night-mode.wav`, lang, skipWsl);
        }
        for (const file of folder.files){
            if (isFolder(file)) {
                await genMissingItems(join3(rootpath, file.name), file, genImage, genAudio, lang, false, skipWsl);
            } else if (isStory(file)) {
                if (genImage && !getFileImageItem(file, folder)) {
                    await generateImage(getTitle(getNameWithoutExt(file.name)), `${rootpath}/${getNameWithoutExt(file.name)}.item.png`);
                }
                if (genAudio && !getFileAudioItem(file, folder)) {
                    await generateAudio(getTitle(getNameWithoutExt(file.name)), `${rootpath}/${getNameWithoutExt(file.name)}.item.wav`, lang, skipWsl);
                }
            }
        }
    }
}
async function convertAudioOfFolder(rootpath, folder, addDelay, seekStory) {
    await checkRunPermission();
    for (const file of folder.files){
        if (isFolder(file)) {
            await convertAudioOfFolder(join3(rootpath, file.name), file, addDelay, seekStory);
        } else {
            if (isStory(file) || isAudioItem(file)) {
                const inputPath = join3(rootpath, file.name);
                const outPath = join3(rootpath, `${getNameWithoutExt(file.name)}.mp3`);
                const skipPath = `${outPath}__skip-convert`;
                if (!await exists(skipPath)) {
                    const maxDb = await getMaxVolumeOfFile(inputPath);
                    const seek = isStory(file) ? seekStory : undefined;
                    const forceToConvert = addDelay || seek || maxDb >= 1;
                    if (forceToConvert || !await checkAudioFormat(inputPath)) {
                        await Deno.copyFile(inputPath, `${inputPath}.bak`);
                        const tmpPath = await Deno.makeTempFile({
                            dir: rootpath,
                            suffix: `.${getExtension(file.name)}`
                        });
                        await Deno.copyFile(inputPath, tmpPath);
                        await Deno.remove(inputPath);
                        await convertAudioFile(tmpPath, maxDb, outPath, addDelay, seek);
                        await Deno.remove(tmpPath);
                    } else {
                        console.log(bgGreen(" skip db<1"));
                    }
                    await Deno.writeTextFile(skipPath, "");
                }
            }
        }
    }
}
async function convertAudioFile(inputPath, maxDb, outputPath, addDelay, seek) {
    console.log(bgBlue(`Convert file ${inputPath}  ${outputPath}`));
    const cmd = [
        ...await getFfmpegCommand(),
        "-i",
        inputPath,
        "-af",
        `volume=${maxDb}dB,dynaudnorm${addDelay ? ",adelay=1000|1000|1000|1000|1000|1000,apad=pad_dur=1s" : ""}`,
        "-ac",
        "1",
        "-ar",
        "44100",
        "-map_metadata",
        "-1",
        ...seek ? [
            "-ss",
            seek
        ] : [],
        "-y",
        outputPath
    ];
    console.log(bgBlue('"' + cmd.join('" "') + '"'));
    const process1 = await Deno.run({
        cmd,
        stdout: "null",
        stdin: "null",
        stderr: "null"
    });
    const status = await process1.status();
    process1.close();
    if (status.success) {
        console.log(bgGreen(" OK"));
    } else {
        console.log(bgRed(" KO"));
    }
}
async function getMaxVolumeOfFile(inputPath) {
    const maxVolumeRegex = /max_volume: -([0-9]+.[0-9]+) dB/;
    let maxDb = 0;
    console.log(bgBlue(`get max volume of file ${inputPath}`));
    const process1 = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            inputPath,
            "-af",
            "volumedetect",
            "-vn",
            "-sn",
            "-dn",
            "-f",
            "null",
            "/dev/null"
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const output = new TextDecoder().decode(await process1.stderrOutput());
    const status = await process1.status();
    process1.close();
    if (status.success) {
        const maxVolLine = output.split("\\n").find((line)=>maxVolumeRegex.test(line));
        if (maxVolLine) {
            maxDb = parseFloat(maxVolumeRegex.exec(maxVolLine)[1]);
        }
        console.log(bgGreen(` OK : ${maxDb} Db`));
    } else {
        console.log(bgRed(" KO"));
    }
    return maxDb;
}
async function checkAudioFormat(filePath) {
    const info = await getFfmpegInfo(filePath);
    const isOk = /^ *Stream #0:0: Audio: mp3, 44100 Hz, mono,.*$/m.test(info);
    console.log(bgBlue(`checkAudioFormat of ${filePath} : Format is ${isOk ? "OK" : "KO"}`));
    return isOk;
}
async function getFfmpegInfo(filePath) {
    console.log(bgBlue(`get info of file ${filePath}`));
    const process1 = await Deno.run({
        cmd: [
            ...await getFfmpegCommand(),
            "-i",
            filePath,
            "-hide_banner",
            "-f",
            "null",
            "-"
        ],
        stdout: "null",
        stdin: "null",
        stderr: "piped"
    });
    const output = new TextDecoder().decode(await process1.stderrOutput());
    const status = await process1.status();
    process1.close();
    let info = "";
    if (status.success) {
        info = output;
    }
    console.log(bgGreen("info=" + info));
    return info;
}
function folderToPack(folder, nightMode = false) {
    const firstSubFolder = folder.files.find((f)=>isFolder(f));
    return {
        title: folder.name,
        description: "",
        format: "v1",
        version: 1,
        nightModeAvailable: nightMode,
        entrypoint: {
            class: "StageNode-Entrypoint",
            name: "Cover node",
            image: getFolderImageItem(folder),
            audio: getFolderAudioItem(folder),
            okTransition: {
                class: "ActionNode",
                name: "Action node",
                options: [
                    firstSubFolder ? folderToMenu(firstSubFolder, "") : fileToStory(firstStoryFile(folder))
                ]
            }
        }
    };
}
function folderToMenu(folder, path) {
    return {
        class: "StageNode-Menu",
        image: getFolderImageItem(folder),
        audio: getFolderAudioItem(folder),
        name: folder.name,
        okTransition: {
            class: "ActionNode",
            name: folder.name + " ActionNode",
            options: folder.files.map((f)=>isFolder(f) ? folderToMenu(f, path + "/" + f.name) : isStory(f) ? fileToStoryItem(f, folder) : isZipFile(f) ? fileToZipMenu(`${path}/${folder.name}/${f.name}`) : null).filter((f)=>f)
        }
    };
}
function fileToZipMenu(path) {
    return {
        class: "ZipMenu",
        path: path
    };
}
function fileToStoryItem(file, parent) {
    return {
        class: "StageNode-StoryItem",
        name: file.name + " item",
        audio: getFileAudioItem(file, parent),
        image: getFileImageItem(file, parent),
        okTransition: {
            name: file.name + " ActionNode",
            class: "ActionNode",
            options: [
                {
                    class: "StageNode-Story",
                    audio: getFileAudioStory(file),
                    image: null,
                    name: file.name + " Stage node",
                    okTransition: null
                }
            ]
        }
    };
}
function fileToStory(file) {
    return {
        class: "StageNode-Story",
        audio: `${file.sha1}.${getExtension(file.name)}`,
        image: null,
        name: file.name + " Stage node",
        okTransition: null
    };
}
async function serializePack(pack, storyPath, opt) {
    const serialized = {
        title: pack.title,
        version: pack.version,
        description: pack.description,
        format: pack.format,
        nightModeAvailable: pack.nightModeAvailable,
        actionNodes: [],
        stageNodes: []
    };
    const nightActionId = pack.nightModeAvailable ? crypto.randomUUID() : "";
    const groups = {};
    await exploreStageNode(pack.entrypoint, serialized, undefined, [], [], groups, storyPath, nightActionId);
    const firstActionId = serialized.stageNodes.find((s)=>s.squareOne)?.okTransition?.actionNode || "";
    serialized.actionNodes = serialized.actionNodes.reverse();
    serialized.stageNodes = serialized.stageNodes.reverse();
    if (nightActionId) {
        const nightStageNodeId = crypto.randomUUID();
        const nightAction = {
            id: nightActionId,
            name: "nightAction",
            options: [
                nightStageNodeId
            ],
            position: {
                x: 0,
                y: 0
            }
        };
        serialized.actionNodes.push(nightAction);
        const nightStage = {
            image: null,
            audio: opt?.nightModeAudioItemName || null,
            controlSettings: {
                autoplay: true,
                home: true,
                ok: true,
                pause: false,
                wheel: false
            },
            name: "nightStage",
            type: "stage",
            uuid: nightStageNodeId,
            homeTransition: {
                actionNode: firstActionId,
                optionIndex: 0
            },
            okTransition: {
                actionNode: firstActionId,
                optionIndex: 0
            },
            position: {
                x: 0,
                y: 0
            },
            squareOne: false
        };
        serialized.stageNodes.push(nightStage);
    }
    if (opt?.autoNextStoryTransition) {
        for (const menuId of Object.keys(groups)){
            const group = groups[menuId];
            for(let i = 1; i < group.length; i++){
                const stageId = group[i - 1].stage;
                const actionId = group[i].action;
                const stage = serialized.stageNodes.find((e)=>e.uuid === stageId);
                if (stage) {
                    stage.okTransition = {
                        actionNode: actionId,
                        optionIndex: 0
                    };
                }
            }
        }
    }
    return serialized;
}
function getControlSettings(stageNode, parent) {
    switch(stageNode.class){
        case "StageNode-Entrypoint":
            return {
                autoplay: false,
                home: false,
                ok: true,
                pause: false,
                wheel: true
            };
        case "StageNode-Menu":
            return {
                autoplay: !!parent?.options && parent?.options.length === 1,
                home: true,
                ok: true,
                pause: false,
                wheel: !!parent?.options && parent?.options.length > 1
            };
        case "StageNode-StoryItem":
            return {
                autoplay: false,
                home: true,
                ok: true,
                pause: false,
                wheel: true
            };
        case "StageNode-Story":
            return {
                autoplay: false,
                home: true,
                ok: false,
                pause: true,
                wheel: false
            };
    }
}
async function exploreStageNode(stageNode, serialized, parent, actionHistory, parentIDs, groups, storyPath, nightActionId) {
    const uuid = crypto.randomUUID();
    if (stageNode.class === "StageNode-Story") {
        const menu = parentIDs[parentIDs.length - 3];
        if (!groups[menu]) {
            groups[menu] = [];
        }
        groups[menu].push({
            stage: uuid,
            action: parentIDs[parentIDs.length - 1]
        });
    }
    const serializedStageNode = {
        audio: stageNode.audio,
        controlSettings: getControlSettings(stageNode, parent),
        homeTransition: actionHistory.length > 1 ? {
            actionNode: actionHistory[actionHistory.length - 2].id,
            optionIndex: actionHistory[actionHistory.length - 2].optionIndex
        } : null,
        image: stageNode.image,
        name: stageNode.name,
        okTransition: stageNode.okTransition ? {
            actionNode: await exploreActionNode(stageNode.okTransition, serialized, actionHistory, [
                ...parentIDs,
                uuid
            ], groups, storyPath, nightActionId),
            optionIndex: 0
        } : null,
        position: {
            x: 0,
            y: 0
        },
        squareOne: stageNode.class === "StageNode-Entrypoint",
        type: stageNode.class === "StageNode-Entrypoint" ? "cover" : "stage",
        uuid
    };
    if (serializedStageNode.okTransition === null && stageNode.class === "StageNode-Story" && actionHistory.length > 1) {
        if (nightActionId) {
            serializedStageNode.okTransition = {
                actionNode: nightActionId,
                optionIndex: 0
            };
        } else {
            serializedStageNode.okTransition = {
                actionNode: actionHistory[actionHistory.length - 2].id,
                optionIndex: actionHistory[actionHistory.length - 2].optionIndex
            };
        }
        serializedStageNode.controlSettings.autoplay = true;
    }
    serialized.stageNodes.push(serializedStageNode);
    return uuid;
}
async function exploreZipMenu(zipMenu, serialized, actionHistory, storyPath) {
    if (!serialized.zipPaths) {
        serialized.zipPaths = [];
    }
    serialized.zipPaths.push(zipMenu.path);
    const zipReader = new ZipReader(new BlobReader(new Blob([
        await Deno.readFile(`${storyPath}/${zipMenu.path}`)
    ])), {
        useWebWorkers: false
    });
    const entries = await zipReader.getEntries();
    const storyEntry = entries.find((entry)=>entry.filename === "story.json");
    if (!storyEntry) {
        console.error(`The zip file '${storyPath}/${zipMenu.path}' is not Studio pack zip !`);
        Deno.exit(6);
    }
    const blobWriter = new BlobWriter("application/json");
    const blob = await storyEntry.getData(blobWriter);
    const storyTxt = await blob.text();
    await zipReader.close();
    const story = JSON.parse(storyTxt);
    const entrypoint = story.stageNodes.find((stageNode)=>stageNode.squareOne === true);
    entrypoint.squareOne = false;
    entrypoint.type = "stage";
    entrypoint.homeTransition = actionHistory.length > 1 ? {
        actionNode: actionHistory[actionHistory.length - 2].id,
        optionIndex: actionHistory[actionHistory.length - 2].optionIndex
    } : null;
    if (!entrypoint.controlSettings) {
        entrypoint.controlSettings = {};
    }
    entrypoint.controlSettings.home = true;
    const entrypointActionNodeUuid = entrypoint.okTransition.actionNode;
    if (entrypointActionNodeUuid && actionHistory.length > 0) {
        const entrypointActionNode = story.actionNodes.find((actionNode)=>actionNode.id === entrypointActionNodeUuid);
        for (const option of entrypointActionNode.options){
            const stage = story.stageNodes.find((s)=>s.uuid === option);
            if (!stage.controlSettings) {
                stage.controlSettings = {};
            }
            stage.controlSettings.homeTransition = true;
            stage.homeTransition = {
                actionNode: actionHistory[actionHistory.length - 1].id,
                optionIndex: actionHistory[actionHistory.length - 1].optionIndex
            };
        }
    }
    serialized.actionNodes.push(...story.actionNodes);
    serialized.stageNodes.push(...story.stageNodes);
    return entrypoint.uuid;
}
async function exploreActionNode(actionNode, serialized, actionHistory, parentIDs, groups, storyPath, nightActionId) {
    const id = crypto.randomUUID();
    const options = [];
    for (const stageNode of actionNode.options){
        {
            const histo = [
                ...actionHistory,
                {
                    id,
                    optionIndex: options.length
                }
            ];
            if (stageNode.class == "ZipMenu") {
                options.push(await exploreZipMenu(stageNode, serialized, histo, storyPath));
            } else {
                options.push(await exploreStageNode(stageNode, serialized, actionNode, histo, [
                    ...parentIDs,
                    id
                ], groups, storyPath, nightActionId));
            }
        }
    }
    const serializedActionNode = {
        id,
        name: actionNode.name,
        options,
        position: {
            x: 0,
            y: 0
        }
    };
    serialized.actionNodes.push(serializedActionNode);
    return id;
}
function getAssetsSha1s(serializedPack) {
    return [
        ...serializedPack.stageNodes.map((stageNode)=>stageNode.image),
        ...serializedPack.stageNodes.map((stageNode)=>stageNode.audio)
    ].filter((sha)=>sha).map((sha)=>sha).map(getNameWithoutExt).sort();
}
function getSha1sMap(folder, path = "", map = {}) {
    folder.files.forEach((f)=>{
        if (isFile(f)) {
            map[f.sha1] = join3(path, f.name);
        } else {
            getSha1sMap(f, join3(path, f.name), map);
        }
    });
    return map;
}
function getAssetsPaths(serializedPack, folder) {
    const sha1s = uniq(getAssetsSha1s(serializedPack));
    const map = getSha1sMap(folder);
    return sha1s.map((sha1)=>({
            sha1,
            path: map[sha1]
        }));
}
async function createPackZip(zipPath, storyPath, serializedPack, assets) {
    console.log(`create ${zipPath}`);
    const blobWriter = new BlobWriter("application/zip");
    const fileInZip = [];
    const zipWriter = new ZipWriter(blobWriter, {
        useWebWorkers: false,
        dataDescriptor: false
    });
    const thumbnailPath = `${storyPath}/thumbnail.png`;
    if (await exists(thumbnailPath)) {
        fileInZip.push("thumbnail.png");
        await zipWriter.add("thumbnail.png", new BlobReader(new Blob([
            await Deno.readFile(thumbnailPath)
        ])));
    }
    if (serializedPack.zipPaths) {
        for (const zipPath1 of serializedPack.zipPaths){
            const zipReader = new ZipReader(new BlobReader(new Blob([
                await Deno.readFile(`${storyPath}/${zipPath1}`)
            ])), {
                useWebWorkers: false
            });
            const entries = await zipReader.getEntries();
            for (const entry of entries.filter((entry)=>entry.filename.startsWith("assets/"))){
                if (!fileInZip.find((f)=>f === entry.filename)) {
                    const blob = await entry.getData(new BlobWriter());
                    console.log(`add to zip : ${entry.filename}`);
                    fileInZip.push(entry.filename);
                    await zipWriter.add(entry.filename, new BlobReader(blob));
                }
            }
            await zipReader.close();
        }
    }
    delete serializedPack.zipPaths;
    await zipWriter.add("story.json", new BlobReader(new Blob([
        JSON.stringify(serializedPack, null, "  ")
    ])));
    for (const asset of assets.filter((asset)=>asset.path)){
        console.log(`add asset ${asset.path}`);
        if (!fileInZip.find((f)=>f === `assets/${asset.sha1}.${getExtension(asset.path)}`)) {
            await zipWriter.add(`assets/${asset.sha1}.${getExtension(asset.path)}`, new BlobReader(new Blob([
                await Deno.readFile(`${storyPath}/${asset.path}`)
            ])));
        }
    }
    console.log(`write ${zipPath}`);
    const blob1 = await zipWriter.close();
    await Deno.writeFile(zipPath, new Buffer(await blob1.arrayBuffer()).bytes());
}
async function getFolderWithUrlFromRssUrl(url, skipRssImageDl) {
    console.log(bgGreen(` url = ${url}`));
    const resp = await fetch(url);
    const xml = (await resp.text()).replace(/<\?xml-stylesheet [^>]+\?>/, "");
    const rss = parse3(xml).rss.channel;
    const imgUrl = rss.image?.url || rss.itunes?.image?.["@href"] || "";
    const fs = {
        name: rss.title,
        files: []
    };
    if (imgUrl) {
        fs.files.push({
            name: `0-item-to-resize.${getExtension(imgUrl)}`,
            url: imgUrl,
            sha1: ""
        });
    }
    const items = rss.item.sort((a, b)=>new Date(a.pubDate).getTime() - new Date(b.pubDate).getTime());
    console.log(bgBlue(` ${items.length} items`));
    if (rss.item.length <= 10) {
        fs.files.push(getFolderOfStories(items, skipRssImageDl));
    } else {
        fs.files.push(getFolderParts(items, skipRssImageDl));
    }
    return fs;
}
function getItemFileName(item) {
    const title = item.title.replace(/[\\\/:*?"<>|]/g, " ");
    return new Date(item.pubDate).getTime() + ` - ${title}.${getExtension(item.enclosure["@url"])}`;
}
function getFolderOfStories(items, skipRssImageDl) {
    return {
        name: __default2.t("storyQuestion"),
        files: items.flatMap((item)=>{
            const itemFiles = [
                {
                    name: getItemFileName(item),
                    url: item.enclosure["@url"],
                    sha1: ""
                }
            ];
            const imageUrl = item["itunes:image"]?.["@href"];
            if (!skipRssImageDl && imageUrl) {
                itemFiles.push({
                    name: `${getNameWithoutExt(getItemFileName(item))}.item.${getExtension(imageUrl)}`,
                    url: imageUrl,
                    sha1: ""
                });
            }
            return itemFiles;
        })
    };
}
function getFolderParts(items, skipRssImageDl) {
    const partCount = Math.ceil(items.length / 10);
    const parts = [];
    for(let i = 0; i < partCount; i++){
        const partSize = Math.floor(items.length / (partCount - i));
        const part = [];
        part.push(...items.splice(0, partSize));
        parts.push(part);
    }
    return {
        name: __default2.t("partQuestion"),
        files: parts.map((part, index)=>({
                name: `${__default2.t("partTitle")} ${index + 1}`,
                files: [
                    getFolderOfStories(part, skipRssImageDl)
                ]
            }))
    };
}
async function writeFolderWithUrl(folder, parentPath) {
    const path = join3(parentPath, folder.name);
    await Deno.mkdir(path, {
        recursive: true
    });
    for (const file of folder.files){
        isFolder(file) ? await writeFolderWithUrl(file, path) : await writeFileWithUrl(file, path);
    }
}
async function writeFileWithUrl(fileWithUrl, parentPath) {
    const filePath = join3(parentPath, fileWithUrl.name);
    console.log(bgBlue(`Download ${fileWithUrl.url}\n     ${filePath}`));
    if (await exists(filePath)) {
        console.log(bgGreen(`    skip`));
    } else {
        const resp = await fetch(fileWithUrl.url);
        const streamReader = resp.body?.getReader();
        if (streamReader) {
            const reader = readerFromStreamReader(streamReader);
            const file = await Deno.open(filePath, {
                create: true,
                write: true
            });
            await copy1(reader, file);
            file.close();
        }
    }
}
async function downloadRss(url, parentPath, skipRssImageDl) {
    const fs = await getFolderWithUrlFromRssUrl(url, skipRssImageDl);
    await writeFolderWithUrl(fs, parentPath);
    const storyPath = join3(parentPath, fs.name);
    const itemToResize = fs.files.find((f)=>isFile(f) && f.name.startsWith("0-item-to-resize"));
    if (itemToResize) {
        const itemToResizePath = join3(storyPath, itemToResize.name);
        await convertToImageItem(itemToResizePath, join3(storyPath, "0-item.png"));
        await Deno.remove(itemToResizePath);
    }
    return storyPath;
}
async function genThumbnail(folder, storyPath) {
    await checkRunPermission();
    const thumbnailPath = join3(storyPath, "thumbnail.png");
    if (!await exists(thumbnailPath)) {
        const itemFile = folder.files.find((f)=>folderImageItemRegEx.test(f.name));
        if (itemFile) {
            await convertToImageItem(join3(storyPath, itemFile.name), thumbnailPath);
        }
    }
}
async function generatePack(opt) {
    const start = Date.now();
    console.log({
        opt
    });
    const lang = opt.lang || await getLang();
    await initI18n(lang);
    if (opt.storyPath.startsWith("http")) {
        opt.storyPath = await downloadRss(opt.storyPath, ".", !!opt.skipRssImageDl);
        console.log(`downloaded in ${opt.storyPath}`);
    }
    if (!opt.skipNotRss) {
        let folder = await fsToFolder(opt.storyPath, false);
        if (!opt.skipExtractImageFromMp3) {
            await extractImagesFromAudio(opt.storyPath, folder);
            folder = await fsToFolder(opt.storyPath, false);
        }
        if (!opt.skipImageItemGen || !opt.skipAudioItemGen) {
            await genMissingItems(opt.storyPath, folder, !opt.skipImageItemGen, !opt.skipAudioItemGen, lang, true, !!opt.skipWsl);
            folder = await fsToFolder(opt.storyPath, false);
        }
        if (!opt.skipAudioConvert) {
            await convertAudioOfFolder(opt.storyPath, folder, !!opt.addDelay, opt.seekStory);
        }
        if (!opt.skipImageItemGen) {
            await genThumbnail(folder, opt.storyPath);
        }
        if (!opt.skipZipGeneration) {
            folder = await fsToFolder(opt.storyPath, true);
            const pack = folderToPack(folder, !!opt.nightMode);
            const nightModeAudioItemName = getNightModeAudioItem(folder);
            const serializedPack = await serializePack(pack, opt.storyPath, {
                autoNextStoryTransition: opt.autoNextStoryTransition,
                nightModeAudioItemName
            });
            const assets = getAssetsPaths(serializedPack, folder);
            const zipPath = `${opt.storyPath}-${Date.now()}.zip`;
            await createPackZip(zipPath, opt.storyPath, serializedPack, assets);
            console.log(`Done (${(Date.now() - start) / 1000} sec) :  ${opt.storyPath}  ${zipPath}`);
        }
    }
}
async function parseArgs(args) {
    await Yargs(args).command("$0 [options] <story-path>", "convert a folder to Studio pack zip", (y)=>{
        let width = y.terminalWidth();
        if (Deno.consoleSize) {
            width = Math.min(120, Deno.consoleSize(Deno.stdout.rid).columns);
        }
        return y.wrap(width);
    }, async (opts)=>await generatePack(opts)).usage("deno run -A studio_pack_generator.ts [options] <story path | RSS URL>    convert a folder or RSS url to Studio pack").option("lang", {
        alias: "l",
        demandOption: false,
        boolean: false,
        type: "string",
        describe: "the lang used to generate menu and items. Auto detected by default"
    }).option("skip-image-item-gen", {
        alias: "i",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip image item generation"
    }).option("skip-audio-item-gen", {
        alias: "a",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip audio item generation"
    }).option("skip-audio-convert", {
        alias: "v",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip convert audio (and skip increase volume)"
    }).option("skip-extract-image-from-mp3", {
        alias: "m",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip extract item image from story mp3"
    }).option("skip-zip-generation", {
        alias: "z",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "only process item generation, don't create zip"
    }).option("skip-not-rss", {
        alias: "s",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip all except download RSS files"
    }).option("auto-next-story-transition", {
        alias: "n",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "go to next story of group at end of stories"
    }).option("add-delay", {
        alias: "d",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "add 1 second at the beginning and the end of audio files"
    }).option("night-mode", {
        alias: "t",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "enable night mode : add transitions to an uniq endpoint"
    }).option("seek-story", {
        alias: "c",
        demandOption: false,
        boolean: false,
        type: "string",
        default: undefined,
        describe: "cut the beginning of stories: 'HH:mm:ss' format or 'N' sec"
    }).option("skip-wsl", {
        alias: "w",
        demandOption: false,
        boolean: true,
        default: false,
        describe: "disable WSL usage"
    }).option("skip-rss-image-dl", {
        demandOption: false,
        boolean: true,
        default: false,
        describe: "skip RSS image download of items"
    }).version(false).demandCommand(1).parse();
}
const importMeta2 = {
    url: "file:///data/Projets/Logiciels/deno/Studio-Pack-Generator/studio_pack_generator.ts",
    main: import.meta.main
};
if (importMeta2.main) {
    console.log(Deno.version);
    await parseArgs(Deno.args);
}
