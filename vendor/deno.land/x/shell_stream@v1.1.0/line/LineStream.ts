import { MapFunction, MapTransform } from "../transform/MapTransform.ts";
import {
  FilterFunction,
  FilterTransform,
} from "../transform/FilterTransform.ts";
import { GrepoTransform } from "../transform/GrepoTransform.ts";
import { streamToArray } from "../utils/StreamToArray.ts";
import { getRunStream, RunOptions, RunStream } from "../run/RunStream.ts";
import { HeadTransform } from "../transform/HeadTransform.ts";
import { TailTransform } from "../transform/TailTransform.ts";
import { SpongeTransform } from "../transform/SpongeTransform.ts";
import { UniqTransform } from "../transform/UniqTransform.ts";
import { CompareFn, SortTransform } from "../transform/SortTransform.ts";
import { Stream, waitRun } from "../Stream.ts";
import { MapAwaitTransform } from "../transform/MapAwaitTransform.ts";
import { parseCmdString } from "../utils/parseCmdString.ts";
import {
  MapAwaitParallelTransform,
} from "../transform/MapAwaitParallelTransform.ts";

export type TapFunction<T> = (line: T) => unknown;
export type LogTransformFunction<T> = (line: T) => string;

export class LineStream<T> {
  promisesToWaitOnClose: Promise<unknown>[] = [];
  /**
   * It takes a parent stream and a child stream, and returns a new stream that is
   * the parent stream with the child stream attached to it
   * @param {LineStream<unknown> | undefined} [parent] the parent of this instance.
   * @param {ReadableStream<T> | undefined} [linesStream] The stream to use as input
   */
  constructor(
    public parent?: LineStream<unknown> | undefined,
    public linesStream?: ReadableStream<T> | undefined,
  ) {
  }

  /**
   * @returns an array of all the parents of the current stream
   */
  getParents(): LineStream<unknown>[] {
    if (this.parent) {
      return [...this.parent.getParents(), this.parent];
    } else {
      return [];
    }
  }

  /**
   * convert the stream output to stream of lines
   * @returns linesStream
   */
  getLineReadableStream() {
    return this.linesStream!;
  }

  /**
   * @returns the file readable of the stream
   */
  toByteReadableStream(): ReadableStream<Uint8Array> {
    let isFirst = true;
    const addLineBreakFn = (line: T) => {
      if (isFirst) {
        isFirst = false;
        return line;
      } else {
        return "\n" + line;
      }
    };
    return this.getLineReadableStream()
      .pipeThrough(new MapTransform(addLineBreakFn))
      .pipeThrough(new TextEncoderStream());
  }

  /* wait the end of parents, and consume all element of the current stream */
  async wait(opt?: { checkSuccess?: boolean }): Promise<this> {
    if (!this.getLineReadableStream().locked) {
      await this.getLineReadableStream().pipeTo(new WritableStream<T>());
    }
    await this.parent?.wait(opt);
    if (this.promisesToWaitOnClose.length) {
      await Promise.all(this.promisesToWaitOnClose);
    }
    return this;
  }

  /* transform the stream with the return of mapFunction */
  map<U>(mapFunction: MapFunction<T, U>): LineStream<U> {
    return this.transform<U>(new MapTransform(mapFunction));
  }

  /* keep stream unchanged, run the `tapFunction` for each line */
  tap(tapFunction: TapFunction<T>) {
    return this.transform(
      new MapTransform((str) => {
        tapFunction(str);
        return str;
      }),
    );
  }

  /**
   * Logs the lines to the console
   * Use the transform function if specified to modify the line before the log
   * ```ts
   * import { Stream } from "https://deno.land/x/shell_stream/mod.ts";
   * await Stream.FromArray(["1", "2", "3"]).log().wait();
   * await Stream.FromArray(["1", "2", "3"]).log(bgRed).wait();
   * ```
   */
  log(transform?: LogTransformFunction<T>) {
    return this.tap((line) =>
      transform ? console.log(transform(line)) : console.log(line)
    );
  }

  /**
   * Logs the lines to the console, use JSON.stringify on each elements
   */
  logJson(replacer = null, space = "  ") {
    return this.log((el) => JSON.stringify(el, replacer, space));
  }

  /**
   * Logs the lines to the console, add the date as prefix before log
   */
  logWithTimestamp(transform?: LogTransformFunction<string>) {
    return this.tap((line) =>
      transform
        ? console.log(transform(`${new Date().toISOString()} ${line}`))
        : console.log(`${new Date().toISOString()} ${line}`)
    );
  }

  /**
   * keep only lines that match the filterFunction.
   */
  filter(filterFunction: FilterFunction<T>) {
    return this.transform(new FilterTransform(filterFunction));
  }

  /**
   * return a new LineStream, generated by transform the current with the
   * transformStream
   */
  transform<U>(transformStream: TransformStream<T, U>): LineStream<U> {
    return new LineStream<U>(
      this,
      this.getLineReadableStream().pipeThrough(transformStream),
    );
  }

  /**
   * keep only lines that match the regex.
   * If `opt.onlyMatching === true`, the stream is then all results matching the
   *  complete regex, like `grep -o` Linux command.
   * @param {RegExp | string} regex A regular expression to match against each
   * line.
   * @param [opt] - { onlyMatching?: boolean }
   * @returns A new LineStream.
   */
  grep(
    regex: RegExp | string,
    opt?: { onlyMatching?: boolean },
  ): LineStream<string | T> {
    const regEx = regex instanceof RegExp ? regex : new RegExp(regex);
    if (opt?.onlyMatching) {
      return this.transform(new GrepoTransform(regEx));
    } else {
      return this.filter((line: T) => regEx.test(String(line)));
    }
  }

  /**
   * alias of grep() with opt : `{ onlyMatching: true }`
   * filter the stream to match regex, and return only the matches
   */
  grepo(regex: RegExp | string) {
    return this.grep(regex, { onlyMatching: true });
  }

  /* return the stream output as an array  */
  async toArray(): Promise<T[]> {
    const array = await streamToArray(this.getLineReadableStream());
    await this.wait();
    return array;
  }

  /**
   * Write the stream output in the file
   * @param {Deno.FsFile | string} file file to write
   * @returns promise of itself.
   */
  async toFile(file: Deno.FsFile | string) {
    // check if a parent is a fromFile with the same path
    const firstStream = this.getParents()[0];
    //  "instanceof FileStream" fail : circular dependency ...
    const firstStreamFile =
      (firstStream as unknown as { file?: Deno.FsFile | string })?.["file"];
    if (
      typeof file === "string" && firstStreamFile && firstStreamFile === file
    ) {
      if (Stream.verbose) {
        console.log(
          "The output file is the same as the input, wait the end on the input stream before write the file",
        );
      }
      const bytes = await this.toBytes();
      const fsFile = await Deno.create(file);
      await fsFile.write(bytes);
      fsFile.close();
      return this.wait();
    } else {
      let fsFile;
      if (typeof file === "string") {
        fsFile = await Deno.create(file);
      } else {
        fsFile = file;
      }
      await this.toByteReadableStream().pipeTo(fsFile.writable);
      return this.wait();
    }
  }

  /**
   * @returns A promise of output of the stream, as string
   */
  async toString(): Promise<string> {
    const decoder = new TextDecoder();
    return (await this.toArray())
      .map((v) => v instanceof Uint8Array ? decoder.decode(v) : v)
      .join("\n");
  }

  /**
   * @returns A promise of output of the stream, as Uint8Array
   */
  async toBytes(): Promise<Uint8Array> {
    return new TextEncoder().encode(await this.toString());
  }

  /**
   * Generate a stream with the current stream as the stdin of the new process.
   * If cmd is a string, it will be parsed to array.
   * @param {string[] | string} cmdOrStr - A string or array of strings that will
   * be passed to the shell.
   * @param {RunOptions} opt - RunOptions
   * @returns A RunStream object.
   */
  run(cmdOrStr: string[] | string, opt: RunOptions = {}): RunStream {
    return new RunStream(cmdOrStr, opt, this);
  }

  /* return an iterable of the stream. */
  toIterable(): AsyncIterable<T> {
    const stream: ReadableStream<T> = this.getLineReadableStream();
    return (async function* () {
      const reader = stream.getReader();
      let res;
      while (!res?.done) {
        res = await reader.read();
        if (!res?.done) {
          yield res.value as T;
        }
      }
    })();
  }

  /**
   * split each input line by "delim" and return the array of parts at "indexes"
   * @param {string} delim the delimiter to split on
   * @param {number[]} indexes An array of indexes to return
   */
  cut(delim: string, indexes: number[]) {
    return this.map((line: T) => {
      const parts = String(line).split(delim);
      return indexes.map((i) => parts[i]);
    });
  }

  /**
   * Replace first occurrence of "searchValue" with "replacer"
   * @param {string | RegExp} searchValue string | RegExp
   * @param {string} replacer string
   */
  replace(searchValue: string | RegExp, replacer: string) {
    return this.map((line: T) => String(line).replace(searchValue, replacer));
  }

  /**
   * Replace all occurrences of "searchValue" with "replacer"
   * @param {string | RegExp} searchValue string | RegExp
   * @param {string} replacer string
   */
  replaceAll(searchValue: string | RegExp, replacer: string) {
    return this.map((line: T) =>
      String(line).replaceAll(searchValue, replacer)
    );
  }

  /* save each consumed element in the file "path" */
  tee(path: string): LineStream<T | string> {
    if (this.linesStream) {
      const streams = this.linesStream.tee();
      this.linesStream = streams[0];
      const promise = new LineStream(undefined, streams[1])
        .toFile(path);
      this.promisesToWaitOnClose.push(promise);
      return this;
    } else {
      const streams = this.toByteReadableStream().tee();
      this.promisesToWaitOnClose.push(
        Deno.create(path)
          .then((file) => streams[1].pipeTo(file.writable)),
      );
      return new LineStream(
        this,
        streams[0].pipeThrough(new TextDecoderStream()),
      );
    }
  }

  /* keep the first "max" items of the input stream */
  head(max = 1) {
    return this.transform(new HeadTransform(max));
  }

  /* keep the last "max" items of the input stream */
  tail(max = 1) {
    return this.transform(new TailTransform(max));
  }

  /* soaks up all its input before re-emit all */
  sponge() {
    return this.transform(new SpongeTransform());
  }

  /**
   * Emits element only if the element is different from the previous line
   */
  uniq() {
    return this.transform(new UniqTransform());
  }

  /* sorts its input and returns a sorted stream */
  sort(compareFn?: CompareFn<T>) {
    return this.transform(new SortTransform(compareFn));
  }

  /**
   * @returns true is the stream is successfully and if all parent RunStream are successfully
   */
  async success(): Promise<boolean> {
    await this.wait({ checkSuccess: true });
    const isFail: boolean = [...this.getParents(), this]
      .map(getRunStream)
      .some((r) => r?.processStatus?.success === false);
    return !isFail;
  }

  /**
   * @returns true is the stream have at least one fail (current or a parent)
   */
  async fail() {
    return !await this.success();
  }

  /**
   * apply the transform function to have a promise, emit the promise result
   */
  mapAwait<U>(mapFunction: MapFunction<T, Promise<U>>): LineStream<U> {
    return this.transform(new MapAwaitTransform<T, U>(mapFunction));
  }

  /**
   * Consume a stream of element, apply a function on it to have promises,
   * pause the consumption if there are "max" pending promise
   * ```ts
   * Stream.fromArray([
   *     "npm run lint",
   *     "npm run prettier-check",
   *     "npm run ts-check",
   *     "npm run test"
   *   ])
   *   .mapAwaitParallel(waitRun, 2) // ~= xargs -n 1 -P 2 bash -c
   *   .wait()
   *   .catch(console.error);
   * ```
   */
  mapAwaitParallel<U>(mapFunction: MapFunction<T, Promise<U>>, max?: number) {
    return this.transform(
      new MapAwaitParallelTransform<T, U>(mapFunction, max),
    );
  }
  /**
   * Like `xargs -n 1`, run a process with input element as last argument of cmd.
   * Alias for `mapAwait((e) => waitRun([...cmd, String(e)], opt))`.
   * ```ts
   * await Stream
   *   .fromArray(["exit 0", "exit 1", "exit 2", "exit 0"])
   *   .log((n) => bgRed(String(n)))
   *   .xargsN1("bash -c", { allowFail: true })
   *   .log((n) => bgBlue(n.processCmd.join(" ") + " = " + n.processStatus?.success))
   *   .wait();
   * ```
   */
  xargsN1(cmdOrStr: string[] | string, opt?: RunOptions) {
    const cmd = parseCmdString(cmdOrStr);
    return this.mapAwait((e) => waitRun([...cmd, String(e)], opt));
  }

  /**
   * Like `xargs -n 1 -P max`, run a process with input element as last argument
   * of cmd.
   * Alias for `mapAwaitParallel((e) => waitRun([...cmd, String(e)], opt), max)`
   * ```ts
   * const array = await Stream
   *   .fromArray([
   *     "sleep 0.5 && exit 0",
   *     "sleep 0.4 && exit 1",
   *     "sleep 0.3 && exit 2",
   *     "sleep 0.1 && exit 3",
   *   ])
   *   .xargsN1P("bash -c", 2, { allowFail: true })
   *   .toArray();
   * console.log(array.map((r) => r.processStatus?.code));
   * ```
   */
  xargsN1P(cmdOrStr: string[] | string, max?: number, opt?: RunOptions) {
    const cmd = parseCmdString(cmdOrStr);
    return this.mapAwaitParallel((e) => waitRun([...cmd, String(e)], opt), max);
  }

  // xargs(cmdOrStr: string[] | string, opt?: RunOptions): LineStream<string> {
  //   const cmd = parseCmdString(cmdOrStr);
  //   const readablePromise = this.toArray().then((array) =>
  //     run([...cmd, ...array.map((e) => String(e))], opt)
  //       .getLineReadableStream()
  //   );
  //   return new LineStream(this, promiseToStream(readablePromise));
  // }
}
